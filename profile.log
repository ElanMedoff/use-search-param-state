SCRIPT  /usr/local/Cellar/neovim/HEAD-92760a7/share/nvim/runtime/ftplugin/typescript.vim
Sourced 2 times
Total time:   0.000399
 Self time:   0.000399

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	TypeScript
                            " Maintainer:	Doug Kearns <dougkearns@gmail.com>
                            " Last Change:	2019 Aug 30
                            
    2              0.000093 if exists("b:did_ftplugin")
                              finish
    2              0.000003 endif
    2              0.000009 let b:did_ftplugin = 1
                            
    2              0.000017 let s:cpo_save = &cpo
    2              0.000027 set cpo-=C
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    2              0.000020 setlocal formatoptions-=t formatoptions+=croql
                            
                            " Set 'comments' to format dashed lists in comments.
    2              0.000015 setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://
                            
    2              0.000008 setlocal commentstring=//%s
                            
    2              0.000010 setlocal suffixesadd+=.ts,.d.ts,.tsx,.js,.jsx,.cjs,.mjs
                            
                            " Change the :browse e filter to primarily show TypeScript-related files.
    2              0.000027 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                                let  b:browsefilter="TypeScript Files (*.ts)\t*.ts\n" .
                            		\	"TypeScript Declaration Files (*.d.ts)\t*.d.ts\n" .
                            		\	"TSX Files (*.tsx)\t*.tsx\n" .
                            		\	"JavaScript Files (*.js)\t*.js\n" .
                            		\	"JavaScript Modules (*.es, *.cjs, *.mjs)\t*.es;*.cjs;*.mjs\n" .
                            		\	"JSON Files (*.json)\t*.json\n" .
                            		\	"All Files (*.*)\t*.*\n"
    2              0.000003 endif
                                   
    2              0.000009 let b:undo_ftplugin = "setl fo< com< cms< sua< | unlet! b:browsefilter" 
                            
    2              0.000027 let &cpo = s:cpo_save
    2              0.000014 unlet s:cpo_save

SCRIPT  /usr/local/Cellar/neovim/HEAD-92760a7/share/nvim/runtime/indent/typescript.vim
Sourced 1 time
Total time:   0.000440
 Self time:   0.000440

count  total (s)   self (s)
                            " Vim indent file
                            " Language: TypeScript
                            " Maintainer: See https://github.com/HerringtonDarkholme/yats.vim
                            " Last Change: 2019 Oct 18
                            " Acknowledgement: Based off of vim-ruby maintained by Nikolai Weibull http://vim-ruby.rubyforge.org
                            
                            " 0. Initialization {{{1
                            " =================
                            
                            " Only load this indent file when no other was loaded.
    1              0.000007 if exists("b:did_indent")
                              finish
    1              0.000001 endif
    1              0.000004 let b:did_indent = 1
                            
    1              0.000010 setlocal nosmartindent
                            
                            " Now, set up our indentation expression and keys that trigger it.
    1              0.000006 setlocal indentexpr=GetTypescriptIndent()
    1              0.000004 setlocal formatexpr=Fixedgq(v:lnum,v:count)
    1              0.000004 setlocal indentkeys=0{,0},0),0],0\,,!^F,o,O,e
                            
                            " Only define the function once.
    1              0.000004 if exists("*GetTypescriptIndent")
                              finish
    1              0.000001 endif
                            
    1              0.000007 let s:cpo_save = &cpo
    1              0.000006 set cpo&vim
                            
                            " 1. Variables {{{1
                            " ============
                            
    1              0.000005 let s:js_keywords = '^\s*\(break\|case\|catch\|continue\|debugger\|default\|delete\|do\|else\|finally\|for\|function\|if\|in\|instanceof\|new\|return\|switch\|this\|throw\|try\|typeof\|var\|void\|while\|with\)'
                            
                            " Regex of syntax group names that are or delimit string or are comments.
    1              0.000003 let s:syng_strcom = 'string\|regex\|comment\c'
                            
                            " Regex of syntax group names that are strings.
    1              0.000002 let s:syng_string = 'regex\c'
                            
                            " Regex of syntax group names that are strings or documentation.
    1              0.000002 let s:syng_multiline = 'comment\c'
                            
                            " Regex of syntax group names that are line comment.
    1              0.000002 let s:syng_linecom = 'linecomment\c'
                            
                            " Expression used to check whether we should skip a match with searchpair().
    1              0.000005 let s:skip_expr = "synIDattr(synID(line('.'),col('.'),1),'name') =~ '".s:syng_strcom."'"
                            
    1              0.000002 let s:line_term = '\s*\%(\%(\/\/\).*\)\=$'
                            
                            " Regex that defines continuation lines, not including (, {, or [.
    1              0.000005 let s:continuation_regex = '\%([\\*+/.:]\|\%(<%\)\@<![=-]\|\W[|&?]\|||\|&&\|[^=]=[^=].*,\)' . s:line_term
                            
                            " Regex that defines continuation lines.
                            " TODO: this needs to deal with if ...: and so on
    1              0.000002 let s:msl_regex = s:continuation_regex
                            
    1              0.000003 let s:one_line_scope_regex = '\<\%(if\|else\|for\|while\)\>[^{;]*' . s:line_term
                            
                            " Regex that defines blocks.
    1              0.000003 let s:block_regex = '\%([{[]\)\s*\%(|\%([*@]\=\h\w*,\=\s*\)\%(,\s*[*@]\=\h\w*\)*|\)\=' . s:line_term
                            
    1              0.000002 let s:var_stmt = '^\s*var'
                            
    1              0.000002 let s:comma_first = '^\s*,'
    1              0.000003 let s:comma_last = ',\s*$'
                            
    1              0.000002 let s:ternary = '^\s\+[?|:]'
    1              0.000002 let s:ternary_q = '^\s\+?'
                            
                            " 2. Auxiliary Functions {{{1
                            " ======================
                            
                            " Check if the character at lnum:col is inside a string, comment, or is ascii.
    1              0.000004 function s:IsInStringOrComment(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_strcom
                            endfunction
                            
                            " Check if the character at lnum:col is inside a string.
    1              0.000002 function s:IsInString(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_string
                            endfunction
                            
                            " Check if the character at lnum:col is inside a multi-line comment.
    1              0.000002 function s:IsInMultilineComment(lnum, col)
                              return !s:IsLineComment(a:lnum, a:col) && synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_multiline
                            endfunction
                            
                            " Check if the character at lnum:col is a line comment.
    1              0.000002 function s:IsLineComment(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_linecom
                            endfunction
                            
                            " Find line above 'lnum' that isn't empty, in a comment, or in a string.
    1              0.000002 function s:PrevNonBlankNonString(lnum)
                              let in_block = 0
                              let lnum = prevnonblank(a:lnum)
                              while lnum > 0
                                " Go in and out of blocks comments as necessary.
                                " If the line isn't empty (with opt. comment) or in a string, end search.
                                let line = getline(lnum)
                                if line =~ '/\*'
                                  if in_block
                                    let in_block = 0
                                  else
                                    break
                                  endif
                                elseif !in_block && line =~ '\*/'
                                  let in_block = 1
                                elseif !in_block && line !~ '^\s*\%(//\).*$' && !(s:IsInStringOrComment(lnum, 1) && s:IsInStringOrComment(lnum, strlen(line)))
                                  break
                                endif
                                let lnum = prevnonblank(lnum - 1)
                              endwhile
                              return lnum
                            endfunction
                            
                            " Find line above 'lnum' that started the continuation 'lnum' may be part of.
    1              0.000002 function s:GetMSL(lnum, in_one_line_scope)
                              " Start on the line we're at and use its indent.
                              let msl = a:lnum
                              let lnum = s:PrevNonBlankNonString(a:lnum - 1)
                              while lnum > 0
                                " If we have a continuation line, or we're in a string, use line as MSL.
                                " Otherwise, terminate search as we have found our MSL already.
                                let line = getline(lnum)
                                let col = match(line, s:msl_regex) + 1
                                if (col > 0 && !s:IsInStringOrComment(lnum, col)) || s:IsInString(lnum, strlen(line))
                                  let msl = lnum
                                else
                                  " Don't use lines that are part of a one line scope as msl unless the
                                  " flag in_one_line_scope is set to 1
                                  "
                                  if a:in_one_line_scope
                                    break
                                  end
                                  let msl_one_line = s:Match(lnum, s:one_line_scope_regex)
                                  if msl_one_line == 0
                                    break
                                  endif
                                endif
                                let lnum = s:PrevNonBlankNonString(lnum - 1)
                              endwhile
                              return msl
                            endfunction
                            
    1              0.000002 function s:RemoveTrailingComments(content)
                              let single = '\/\/\(.*\)\s*$'
                              let multi = '\/\*\(.*\)\*\/\s*$'
                              return substitute(substitute(a:content, single, '', ''), multi, '', '')
                            endfunction
                            
                            " Find if the string is inside var statement (but not the first string)
    1              0.000002 function s:InMultiVarStatement(lnum)
                              let lnum = s:PrevNonBlankNonString(a:lnum - 1)
                            
                            "  let type = synIDattr(synID(lnum, indent(lnum) + 1, 0), 'name')
                            
                              " loop through previous expressions to find a var statement
                              while lnum > 0
                                let line = getline(lnum)
                            
                                " if the line is a js keyword
                                if (line =~ s:js_keywords)
                                  " check if the line is a var stmt
                                  " if the line has a comma first or comma last then we can assume that we
                                  " are in a multiple var statement
                                  if (line =~ s:var_stmt)
                                    return lnum
                                  endif
                            
                                  " other js keywords, not a var
                                  return 0
                                endif
                            
                                let lnum = s:PrevNonBlankNonString(lnum - 1)
                              endwhile
                            
                              " beginning of program, not a var
                              return 0
                            endfunction
                            
                            " Find line above with beginning of the var statement or returns 0 if it's not
                            " this statement
    1              0.000002 function s:GetVarIndent(lnum)
                              let lvar = s:InMultiVarStatement(a:lnum)
                              let prev_lnum = s:PrevNonBlankNonString(a:lnum - 1)
                            
                              if lvar
                                let line = s:RemoveTrailingComments(getline(prev_lnum))
                            
                                " if the previous line doesn't end in a comma, return to regular indent
                                if (line !~ s:comma_last)
                                  return indent(prev_lnum) - shiftwidth()
                                else
                                  return indent(lvar) + shiftwidth()
                                endif
                              endif
                            
                              return -1
                            endfunction
                            
                            
                            " Check if line 'lnum' has more opening brackets than closing ones.
    1              0.000002 function s:LineHasOpeningBrackets(lnum)
                              let open_0 = 0
                              let open_2 = 0
                              let open_4 = 0
                              let line = getline(a:lnum)
                              let pos = match(line, '[][(){}]', 0)
                              while pos != -1
                                if !s:IsInStringOrComment(a:lnum, pos + 1)
                                  let idx = stridx('(){}[]', line[pos])
                                  if idx % 2 == 0
                                    let open_{idx} = open_{idx} + 1
                                  else
                                    let open_{idx - 1} = open_{idx - 1} - 1
                                  endif
                                endif
                                let pos = match(line, '[][(){}]', pos + 1)
                              endwhile
                              return (open_0 > 0) . (open_2 > 0) . (open_4 > 0)
                            endfunction
                            
    1              0.000002 function s:Match(lnum, regex)
                              let col = match(getline(a:lnum), a:regex) + 1
                              return col > 0 && !s:IsInStringOrComment(a:lnum, col) ? col : 0
                            endfunction
                            
    1              0.000002 function s:IndentWithContinuation(lnum, ind, width)
                              " Set up variables to use and search for MSL to the previous line.
                              let p_lnum = a:lnum
                              let lnum = s:GetMSL(a:lnum, 1)
                              let line = getline(lnum)
                            
                              " If the previous line wasn't a MSL and is continuation return its indent.
                              " TODO: the || s:IsInString() thing worries me a bit.
                              if p_lnum != lnum
                                if s:Match(p_lnum,s:continuation_regex)||s:IsInString(p_lnum,strlen(line))
                                  return a:ind
                                endif
                              endif
                            
                              " Set up more variables now that we know we aren't continuation bound.
                              let msl_ind = indent(lnum)
                            
                              " If the previous line ended with [*+/.-=], start a continuation that
                              " indents an extra level.
                              if s:Match(lnum, s:continuation_regex)
                                if lnum == p_lnum
                                  return msl_ind + a:width
                                else
                                  return msl_ind
                                endif
                              endif
                            
                              return a:ind
                            endfunction
                            
    1              0.000002 function s:InOneLineScope(lnum)
                              let msl = s:GetMSL(a:lnum, 1)
                              if msl > 0 && s:Match(msl, s:one_line_scope_regex)
                                return msl
                              endif
                              return 0
                            endfunction
                            
    1              0.000004 function s:ExitingOneLineScope(lnum)
                              let msl = s:GetMSL(a:lnum, 1)
                              if msl > 0
                                " if the current line is in a one line scope ..
                                if s:Match(msl, s:one_line_scope_regex)
                                  return 0
                                else
                                  let prev_msl = s:GetMSL(msl - 1, 1)
                                  if s:Match(prev_msl, s:one_line_scope_regex)
                                    return prev_msl
                                  endif
                                endif
                              endif
                              return 0
                            endfunction
                            
                            " 3. GetTypescriptIndent Function {{{1
                            " =========================
                            
    1              0.000002 function GetTypescriptIndent()
                              " 3.1. Setup {{{2
                              " ----------
                            
                              " Set up variables for restoring position in file.  Could use v:lnum here.
                              let vcol = col('.')
                            
                              " 3.2. Work on the current line {{{2
                              " -----------------------------
                            
                              let ind = -1
                              " Get the current line.
                              let line = getline(v:lnum)
                              " previous nonblank line number
                              let prevline = prevnonblank(v:lnum - 1)
                            
                              " If we got a closing bracket on an empty line, find its match and indent
                              " according to it.  For parentheses we indent to its column - 1, for the
                              " others we indent to the containing line's MSL's level.  Return -1 if fail.
                              let col = matchend(line, '^\s*[],})]')
                              if col > 0 && !s:IsInStringOrComment(v:lnum, col)
                                call cursor(v:lnum, col)
                            
                                let lvar = s:InMultiVarStatement(v:lnum)
                                if lvar
                                  let prevline_contents = s:RemoveTrailingComments(getline(prevline))
                            
                                  " check for comma first
                                  if (line[col - 1] =~ ',')
                                    " if the previous line ends in comma or semicolon don't indent
                                    if (prevline_contents =~ '[;,]\s*$')
                                      return indent(s:GetMSL(line('.'), 0))
                                    " get previous line indent, if it's comma first return prevline indent
                                    elseif (prevline_contents =~ s:comma_first)
                                      return indent(prevline)
                                    " otherwise we indent 1 level
                                    else
                                      return indent(lvar) + shiftwidth()
                                    endif
                                  endif
                                endif
                            
                            
                                let bs = strpart('(){}[]', stridx(')}]', line[col - 1]) * 2, 2)
                                if searchpair(escape(bs[0], '\['), '', bs[1], 'bW', s:skip_expr) > 0
                                  if line[col-1]==')' && col('.') != col('$') - 1
                                    let ind = virtcol('.')-1
                                  else
                                    let ind = indent(s:GetMSL(line('.'), 0))
                                  endif
                                endif
                                return ind
                              endif
                            
                              " If the line is comma first, dedent 1 level
                              if (getline(prevline) =~ s:comma_first)
                                return indent(prevline) - shiftwidth()
                              endif
                            
                              if (line =~ s:ternary)
                                if (getline(prevline) =~ s:ternary_q)
                                  return indent(prevline)
                                else
                                  return indent(prevline) + shiftwidth()
                                endif
                              endif
                            
                              " If we are in a multi-line comment, cindent does the right thing.
                              if s:IsInMultilineComment(v:lnum, 1) && !s:IsLineComment(v:lnum, 1)
                                return cindent(v:lnum)
                              endif
                            
                              " Check for multiple var assignments
                            "  let var_indent = s:GetVarIndent(v:lnum)
                            "  if var_indent >= 0
                            "    return var_indent
                            "  endif
                            
                              " 3.3. Work on the previous line. {{{2
                              " -------------------------------
                            
                              " If the line is empty and the previous nonblank line was a multi-line
                              " comment, use that comment's indent. Deduct one char to account for the
                              " space in ' */'.
                              if line =~ '^\s*$' && s:IsInMultilineComment(prevline, 1)
                                return indent(prevline) - 1
                              endif
                            
                              " Find a non-blank, non-multi-line string line above the current line.
                              let lnum = s:PrevNonBlankNonString(v:lnum - 1)
                            
                              " If the line is empty and inside a string, use the previous line.
                              if line =~ '^\s*$' && lnum != prevline
                                return indent(prevnonblank(v:lnum))
                              endif
                            
                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif
                            
                              " Set up variables for current line.
                              let line = getline(lnum)
                              let ind = indent(lnum)
                            
                              " If the previous line ended with a block opening, add a level of indent.
                              if s:Match(lnum, s:block_regex)
                                return indent(s:GetMSL(lnum, 0)) + shiftwidth()
                              endif
                            
                              " If the previous line contained an opening bracket, and we are still in it,
                              " add indent depending on the bracket type.
                              if line =~ '[[({]'
                                let counts = s:LineHasOpeningBrackets(lnum)
                                if counts[0] == '1' && searchpair('(', '', ')', 'bW', s:skip_expr) > 0
                                  if col('.') + 1 == col('$')
                                    return ind + shiftwidth()
                                  else
                                    return virtcol('.')
                                  endif
                                elseif counts[1] == '1' || counts[2] == '1'
                                  return ind + shiftwidth()
                                else
                                  call cursor(v:lnum, vcol)
                                end
                              endif
                            
                              " 3.4. Work on the MSL line. {{{2
                              " --------------------------
                            
                              let ind_con = ind
                              let ind = s:IndentWithContinuation(lnum, ind_con, shiftwidth())
                            
                              " }}}2
                              "
                              "
                              let ols = s:InOneLineScope(lnum)
                              if ols > 0
                                let ind = ind + shiftwidth()
                              else
                                let ols = s:ExitingOneLineScope(lnum)
                                while ols > 0 && ind > 0
                                  let ind = ind - shiftwidth()
                                  let ols = s:InOneLineScope(ols - 1)
                                endwhile
                              endif
                            
                              return ind
                            endfunction
                            
                            " }}}1
                            
    1              0.000011 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            
    1              0.000002 function! Fixedgq(lnum, count)
                                let l:tw = &tw ? &tw : 80
                            
                                let l:count = a:count
                                let l:first_char = indent(a:lnum) + 1
                            
                                if mode() == 'i' " gq was not pressed, but tw was set
                                    return 1
                                endif
                            
                                " This gq is only meant to do code with strings, not comments
                                if s:IsLineComment(a:lnum, l:first_char) || s:IsInMultilineComment(a:lnum, l:first_char)
                                    return 1
                                endif
                            
                                if len(getline(a:lnum)) < l:tw && l:count == 1 " No need for gq
                                    return 1
                                endif
                            
                                " Put all the lines on one line and do normal splitting after that
                                if l:count > 1
                                    while l:count > 1
                                        let l:count -= 1
                                        normal J
                                    endwhile
                                endif
                            
                                let l:winview = winsaveview()
                            
                                call cursor(a:lnum, l:tw + 1)
                                let orig_breakpoint = searchpairpos(' ', '', '\.', 'bcW', '', a:lnum)
                                call cursor(a:lnum, l:tw + 1)
                                let breakpoint = searchpairpos(' ', '', '\.', 'bcW', s:skip_expr, a:lnum)
                            
                                " No need for special treatment, normal gq handles edgecases better
                                if breakpoint[1] == orig_breakpoint[1]
                                    call winrestview(l:winview)
                                    return 1
                                endif
                            
                                " Try breaking after string
                                if breakpoint[1] <= indent(a:lnum)
                                    call cursor(a:lnum, l:tw + 1)
                                    let breakpoint = searchpairpos('\.', '', ' ', 'cW', s:skip_expr, a:lnum)
                                endif
                            
                            
                                if breakpoint[1] != 0
                                    call feedkeys("r\<CR>")
                                else
                                    let l:count = l:count - 1
                                endif
                            
                                " run gq on new lines
                                if l:count == 1
                                    call feedkeys("gqq")
                                endif
                            
                                return 0
                            endfunction

SCRIPT  /usr/local/Cellar/neovim/HEAD-92760a7/share/nvim/runtime/syntax/typescript.vim
Sourced 3 times
Total time:   0.016205
 Self time:   0.000738

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     TypeScript
                            " Maintainer:   Bram Moolenaar, Herrington Darkholme
                            " Last Change:	2019 Nov 30
                            " Based On:     Herrington Darkholme's yats.vim
                            " Changes:      Go to https:github.com/HerringtonDarkholme/yats.vim for recent changes.
                            " Origin:       https://github.com/othree/yajs
                            " Credits:      Kao Wei-Ko(othree), Jose Elera Campana, Zhao Yi, Claudio Fleiner, Scott Shattuck
                            "               (This file is based on their hard work), gumnos (From the #vim
                            "               IRC Channel in Freenode)
                            
                            " This is the same syntax that is in yats.vim, but:
                            " - flattened into one file
                            " - HiLink commands changed to "hi def link"
                            " - Setting 'cpo' to the Vim value
                            
    3              0.000021 if !exists("main_syntax")
    3              0.000010   if exists("b:current_syntax")
                                finish
    3              0.000003   endif
    3              0.000010   let main_syntax = 'typescript'
    3              0.000003 endif
                            
    3              0.000017 let s:cpo_save = &cpo
    3   0.000037   0.000026 set cpo&vim
                            
                            " this region is NOT used in TypeScriptReact
                            " nextgroup doesn't contain objectLiteral, let outer region contains it
    3              0.000063 syntax region typescriptTypeCast matchgroup=typescriptTypeBrackets
                              \ start=/< \@!/ end=/>/
                              \ contains=@typescriptType
                              \ nextgroup=@typescriptExpression
                              \ contained skipwhite oneline
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""
                            " Source the part common with typescriptreact.vim
    3   0.015883   0.000432 source <sfile>:h/shared/typescriptcommon.vim
                            
                            
    3              0.000010 let b:current_syntax = "typescript"
    3              0.000009 if main_syntax == 'typescript'
    3              0.000005   unlet main_syntax
    3              0.000002 endif
                            
    3   0.000028   0.000022 let &cpo = s:cpo_save
    3              0.000010 unlet s:cpo_save

SCRIPT  /usr/local/Cellar/neovim/HEAD-92760a7/share/nvim/runtime/syntax/shared/typescriptcommon.vim
Sourced 4 times
Total time:   0.025081
 Self time:   0.025040

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     TypeScript and TypeScriptReact
                            " Maintainer:   Bram Moolenaar, Herrington Darkholme
                            " Last Change:	2021 Sep 22
                            " Based On:     Herrington Darkholme's yats.vim
                            " Changes:      See https:github.com/HerringtonDarkholme/yats.vim
                            " Credits:      See yats.vim on github
                            
    4              0.000047 if &cpo =~ 'C'
    4              0.000029   let s:cpo_save = &cpo
    4   0.000046   0.000040   set cpo&vim
    4              0.000006 endif
                            
                            
                            " NOTE: this results in accurate highlighting, but can be slow.
    4              0.000012 syntax sync fromstart
                            
                            "Dollar sign is permitted anywhere in an identifier
    4   0.000153   0.000146 setlocal iskeyword-=$
    4              0.000027 if main_syntax == 'typescript' || main_syntax == 'typescriptreact'
    4   0.000133   0.000127   setlocal iskeyword+=$
                              " syntax cluster htmlJavaScript                 contains=TOP
    4              0.000005 endif
                            " For private field added from TypeScript 3.8
    4   0.000122   0.000117 setlocal iskeyword+=#
                            
                            " lowest priority on least used feature
    4              0.000069 syntax match   typescriptLabel                /[a-zA-Z_$]\k*:/he=e-1 contains=typescriptReserved nextgroup=@typescriptStatement skipwhite skipempty
                            
                            " other keywords like return,case,yield uses containedin
    4              0.000051 syntax region  typescriptBlock                 matchgroup=typescriptBraces start=/{/ end=/}/ contains=@typescriptStatement,@typescriptComments fold
    4              0.000073 syntax cluster afterIdentifier contains=
                              \ typescriptDotNotation,
                              \ typescriptFuncCallArg,
                              \ typescriptTemplate,
                              \ typescriptIndexExpr,
                              \ @typescriptSymbols,
                              \ typescriptTypeArguments
                            
    4              0.000051 syntax match   typescriptIdentifierName        /\<\K\k*/
                              \ nextgroup=@afterIdentifier
                              \ transparent
                              \ contains=@_semantic
                              \ skipnl skipwhite
                            
    4              0.000132 syntax match   typescriptProp contained /\K\k*!\?/
                              \ transparent
                              \ contains=@props
                              \ nextgroup=@afterIdentifier
                              \ skipwhite skipempty
                            
    4              0.000067 syntax region  typescriptIndexExpr      contained matchgroup=typescriptProperty start=/\[/rs=s+1 end=/]/he=e-1 contains=@typescriptValue nextgroup=@typescriptSymbols,typescriptDotNotation,typescriptFuncCallArg skipwhite skipempty
                            
    4              0.000032 syntax match   typescriptDotNotation           /\.\|?\.\|!\./ nextgroup=typescriptProp skipnl
    4              0.000036 syntax match   typescriptDotStyleNotation      /\.style\./ nextgroup=typescriptDOMStyle transparent
                            " syntax match   typescriptFuncCall              contained /[a-zA-Z]\k*\ze(/ nextgroup=typescriptFuncCallArg
    4              0.000064 syntax region  typescriptParenExp              matchgroup=typescriptParens start=/(/ end=/)/ contains=@typescriptComments,@typescriptValue,typescriptCastKeyword nextgroup=@typescriptSymbols skipwhite skipempty
    4              0.000050 syntax region  typescriptFuncCallArg           contained matchgroup=typescriptParens start=/(/ end=/)/ contains=@typescriptValue,@typescriptComments nextgroup=@typescriptSymbols,typescriptDotNotation skipwhite skipempty skipnl
    4              0.000060 syntax region  typescriptEventFuncCallArg      contained matchgroup=typescriptParens start=/(/ end=/)/ contains=@typescriptEventExpression
    4              0.000070 syntax region  typescriptEventString           contained start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1\|$/ contains=typescriptASCII,@events
                            
    4              0.000066 syntax region  typescriptDestructureString
                              \ start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1\|$/
                              \ contains=typescriptASCII
                              \ nextgroup=typescriptDestructureAs
                              \ contained skipwhite skipempty
                            
    4              0.000029 syntax cluster typescriptVariableDeclarations
                              \ contains=typescriptVariableDeclaration,@typescriptDestructures
                            
    4              0.000067 syntax match typescriptVariableDeclaration /[A-Za-z_$]\k*/
                              \ nextgroup=typescriptTypeAnnotation,typescriptAssign
                              \ contained skipwhite skipempty
                            
    4              0.000051 syntax cluster typescriptDestructureVariables contains=
                              \ typescriptRestOrSpread,
                              \ typescriptDestructureComma,
                              \ typescriptDestructureLabel,
                              \ typescriptDestructureVariable,
                              \ @typescriptDestructures
                            
    4              0.000029 syntax match typescriptDestructureVariable    /[A-Za-z_$]\k*/ contained
                              \ nextgroup=typescriptDefaultParam
                              \ contained skipwhite skipempty
                            
    4              0.000034 syntax match typescriptDestructureLabel       /[A-Za-z_$]\k*\ze\_s*:/
                              \ nextgroup=typescriptDestructureAs
                              \ contained skipwhite skipempty
                            
    4              0.000029 syntax match typescriptDestructureAs /:/
                              \ nextgroup=typescriptDestructureVariable,@typescriptDestructures
                              \ contained skipwhite skipempty
                            
    4              0.000024 syntax match typescriptDestructureComma /,/ contained
                            
    4              0.000030 syntax cluster typescriptDestructures contains=
                              \ typescriptArrayDestructure,
                              \ typescriptObjectDestructure
                            
    4              0.000062 syntax region typescriptArrayDestructure matchgroup=typescriptBraces
                              \ start=/\[/ end=/]/
                              \ contains=@typescriptDestructureVariables,@typescriptComments
                              \ nextgroup=typescriptTypeAnnotation,typescriptAssign
                              \ transparent contained skipwhite skipempty fold
                            
    4              0.000062 syntax region typescriptObjectDestructure matchgroup=typescriptBraces
                              \ start=/{/ end=/}/
                              \ contains=typescriptDestructureString,@typescriptDestructureVariables,@typescriptComments
                              \ nextgroup=typescriptTypeAnnotation,typescriptAssign
                              \ transparent contained skipwhite skipempty fold
                            
                            "Syntax in the JavaScript code
                            
                            " String
    4              0.000019 syntax match   typescriptASCII                 contained /\\\d\d\d/
                            
    4              0.000043 syntax region  typescriptTemplateSubstitution matchgroup=typescriptTemplateSB
                              \ start=/\${/ end=/}/
                              \ contains=@typescriptValue
                              \ contained
                            
                            
    4              0.000068 syntax region  typescriptString 
                              \ start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1+ end=+$+
                              \ contains=typescriptSpecial,@Spell
                              \ extend
                            
    4              0.000048 syntax match   typescriptSpecial            contained "\v\\%(x\x\x|u%(\x{4}|\{\x{1,6}})|c\u|.)"
                            
                            " From vim runtime
                            " <https://github.com/vim/vim/blob/master/runtime/syntax/javascript.vim#L48>
    4              0.000093 syntax region  typescriptRegexpString          start=+/[^/*]+me=e-1 skip=+\\\\\|\\/+ end=+/[gimuy]\{0,5\}\s*$+ end=+/[gimuy]\{0,5\}\s*[;.,)\]}:]+me=e-1 nextgroup=typescriptDotNotation oneline
                            
    4              0.000090 syntax region  typescriptTemplate
                              \ start=/`/  skip=/\\\\\|\\`\|\n/  end=/`\|$/
                              \ contains=typescriptTemplateSubstitution,typescriptSpecial,@Spell
                              \ nextgroup=@typescriptSymbols
                              \ skipwhite skipempty
                            
                            "Array
    4              0.000055 syntax region  typescriptArray matchgroup=typescriptBraces
                              \ start=/\[/ end=/]/
                              \ contains=@typescriptValue,@typescriptComments
                              \ nextgroup=@typescriptSymbols,typescriptDotNotation
                              \ skipwhite skipempty fold
                            
                            " Number
    4              0.000034 syntax match typescriptNumber /\<0[bB][01][01_]*\>/        nextgroup=@typescriptSymbols skipwhite skipempty
    4              0.000031 syntax match typescriptNumber /\<0[oO][0-7][0-7_]*\>/       nextgroup=@typescriptSymbols skipwhite skipempty
    4              0.000031 syntax match typescriptNumber /\<0[xX][0-9a-fA-F][0-9a-fA-F_]*\>/ nextgroup=@typescriptSymbols skipwhite skipempty
    4              0.000062 syntax match typescriptNumber /\<\%(\d[0-9_]*\%(\.\d[0-9_]*\)\=\|\.\d[0-9_]*\)\%([eE][+-]\=\d[0-9_]*\)\=\>/
                              \ nextgroup=typescriptSymbols skipwhite skipempty
                            
    4              0.000064 syntax region  typescriptObjectLiteral         matchgroup=typescriptBraces
                              \ start=/{/ end=/}/
                              \ contains=@typescriptComments,typescriptObjectLabel,typescriptStringProperty,typescriptComputedPropertyName,typescriptObjectAsyncKeyword
                              \ fold contained
                            
    4              0.000015 syntax keyword typescriptObjectAsyncKeyword async contained
                            
    4              0.000037 syntax match   typescriptObjectLabel  contained /\k\+\_s*/
                              \ nextgroup=typescriptObjectColon,@typescriptCallImpl
                              \ skipwhite skipempty
                            
    4              0.000057 syntax region  typescriptStringProperty   contained
                              \ start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1/
                              \ nextgroup=typescriptObjectColon,@typescriptCallImpl
                              \ skipwhite skipempty
                            
                            " syntax region  typescriptPropertyName    contained start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1(/me=e-1 nextgroup=@typescriptCallSignature skipwhite skipempty oneline
    4              0.000048 syntax region  typescriptComputedPropertyName  contained matchgroup=typescriptBraces
                              \ start=/\[/rs=s+1 end=/]/
                              \ contains=@typescriptValue
                              \ nextgroup=typescriptObjectColon,@typescriptCallImpl
                              \ skipwhite skipempty
                            
                            " syntax region  typescriptComputedPropertyName  contained matchgroup=typescriptPropertyName start=/\[/rs=s+1 end=/]\_s*:/he=e-1 contains=@typescriptValue nextgroup=@typescriptValue skipwhite skipempty
                            " syntax region  typescriptComputedPropertyName  contained matchgroup=typescriptPropertyName start=/\[/rs=s+1 end=/]\_s*(/me=e-1 contains=@typescriptValue nextgroup=@typescriptCallSignature skipwhite skipempty
                            " Value for object, statement for label statement
    4              0.000017 syntax match typescriptRestOrSpread /\.\.\./ contained
    4              0.000110 syntax match typescriptObjectSpread /\.\.\./ contained containedin=typescriptObjectLiteral,typescriptArray nextgroup=@typescriptValue
                            
    4              0.000022 syntax match typescriptObjectColon contained /:/ nextgroup=@typescriptValue skipwhite skipempty
                            
                            " + - ^ ~
    4              0.000031 syntax match typescriptUnaryOp /[+\-~!]/
                             \ nextgroup=@typescriptValue
                             \ skipwhite
                            
    4              0.000050 syntax region typescriptTernary matchgroup=typescriptTernaryOp start=/?[.?]\@!/ end=/:/ contained contains=@typescriptValue,@typescriptComments nextgroup=@typescriptValue skipwhite skipempty
                            
    4              0.000022 syntax match   typescriptAssign  /=/ nextgroup=@typescriptValue
                              \ skipwhite skipempty
                            
                            " 2: ==, ===
    4              0.000022 syntax match   typescriptBinaryOp contained /===\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 6: >>>=, >>>, >>=, >>, >=, >
    4              0.000034 syntax match   typescriptBinaryOp contained />\(>>=\|>>\|>=\|>\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 4: <<=, <<, <=, <
    4              0.000023 syntax match   typescriptBinaryOp contained /<\(<=\|<\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 3: ||, |=, |, ||=
    4              0.000021 syntax match   typescriptBinaryOp contained /||\?=\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 4: &&, &=, &, &&=
    4              0.000017 syntax match   typescriptBinaryOp contained /&&\?=\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: ??, ??=
    4              0.000018 syntax match   typescriptBinaryOp contained /??=\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: *=, *
    4              0.000018 syntax match   typescriptBinaryOp contained /\*=\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: %=, %
    4              0.000043 syntax match   typescriptBinaryOp contained /%=\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: /=, /
    4              0.000028 syntax match   typescriptBinaryOp contained +/\(=\|[^\*/]\@=\)+ nextgroup=@typescriptValue skipwhite skipempty
    4              0.000017 syntax match   typescriptBinaryOp contained /!==\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: !=, !==
    4              0.000022 syntax match   typescriptBinaryOp contained /+\(+\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 3: +, ++, +=
    4              0.000016 syntax match   typescriptBinaryOp contained /-\(-\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 3: -, --, -=
                            
                            " exponentiation operator
                            " 2: **, **=
    4              0.000018 syntax match typescriptBinaryOp contained /\*\*=\?/ nextgroup=@typescriptValue
                            
    4              0.000073 syntax cluster typescriptSymbols               contains=typescriptBinaryOp,typescriptKeywordOp,typescriptTernary,typescriptAssign,typescriptCastKeyword
                            
                            " runtime syntax/basic/reserved.vim
                            "Import
    4              0.000012 syntax keyword typescriptImport                from as
    4              0.000020 syntax keyword typescriptImport                import
                              \ nextgroup=typescriptImportType
                              \ skipwhite
    4              0.000011 syntax keyword typescriptImportType            type
                              \ contained
    4              0.000018 syntax keyword typescriptExport                export
                              \ nextgroup=typescriptExportType
                              \ skipwhite
    4              0.000019 syntax match typescriptExportType              /\<type\s*{\@=/
                              \ contained skipwhite skipempty skipnl
    4              0.000011 syntax keyword typescriptModule                namespace module
                            
                            "this
                            
                            "JavaScript Prototype
    4              0.000016 syntax keyword typescriptPrototype             prototype
                              \ nextgroup=@afterIdentifier
                            
    4              0.000018 syntax keyword typescriptCastKeyword           as
                              \ nextgroup=@typescriptType
                              \ skipwhite
                            
                            "Program Keywords
    4              0.000019 syntax keyword typescriptIdentifier            arguments this super
                              \ nextgroup=@afterIdentifier
                            
    4              0.000021 syntax keyword typescriptVariable              let var
                              \ nextgroup=@typescriptVariableDeclarations
                              \ skipwhite skipempty
                            
    4              0.000026 syntax keyword typescriptVariable const
                              \ nextgroup=typescriptEnum,@typescriptVariableDeclarations
                              \ skipwhite skipempty
                            
    4              0.000035 syntax region typescriptEnum matchgroup=typescriptEnumKeyword start=/enum / end=/\ze{/
                              \ nextgroup=typescriptBlock
                              \ skipwhite
                            
    4              0.000017 syntax keyword typescriptKeywordOp
                              \ contained in instanceof nextgroup=@typescriptValue
    4              0.000022 syntax keyword typescriptOperator              delete new typeof void
                              \ nextgroup=@typescriptValue
                              \ skipwhite skipempty
                            
    4              0.000010 syntax keyword typescriptForOperator           contained in of
    4              0.000016 syntax keyword typescriptBoolean               true false nextgroup=@typescriptSymbols skipwhite skipempty
    4              0.000017 syntax keyword typescriptNull                  null undefined nextgroup=@typescriptSymbols skipwhite skipempty
    4              0.000039 syntax keyword typescriptMessage               alert confirm prompt status
                              \ nextgroup=typescriptDotNotation,typescriptFuncCallArg
    4              0.000017 syntax keyword typescriptGlobal                self top parent
                              \ nextgroup=@afterIdentifier
                            
                            "Statement Keywords
    4              0.000023 syntax keyword typescriptConditional           if else switch
                              \ nextgroup=typescriptConditionalParen
                              \ skipwhite skipempty skipnl
    4              0.000010 syntax keyword typescriptConditionalElse       else
    4              0.000018 syntax keyword typescriptRepeat                do while for nextgroup=typescriptLoopParen skipwhite skipempty
    4              0.000019 syntax keyword typescriptRepeat                for nextgroup=typescriptLoopParen,typescriptAsyncFor skipwhite skipempty
    4              0.000016 syntax keyword typescriptBranch                break continue containedin=typescriptBlock
    4              0.000021 syntax keyword typescriptCase                  case nextgroup=@typescriptPrimitive skipwhite containedin=typescriptBlock
    4              0.000040 syntax keyword typescriptDefault               default containedin=typescriptBlock nextgroup=@typescriptValue,typescriptClassKeyword,typescriptInterfaceKeyword skipwhite oneline
    4              0.000009 syntax keyword typescriptStatementKeyword      with
    4              0.000018 syntax keyword typescriptStatementKeyword      yield skipwhite nextgroup=@typescriptValue containedin=typescriptBlock
    4              0.000017 syntax keyword typescriptStatementKeyword      return skipwhite contained nextgroup=@typescriptValue containedin=typescriptBlock
                            
    4              0.000008 syntax keyword typescriptTry                   try
    4              0.000012 syntax keyword typescriptExceptions            catch throw finally
    4              0.000008 syntax keyword typescriptDebugger              debugger
                            
    4              0.000013 syntax keyword typescriptAsyncFor              await nextgroup=typescriptLoopParen skipwhite skipempty contained
                            
    4              0.000058 syntax region  typescriptLoopParen             contained matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=typescriptVariable,typescriptForOperator,typescriptEndColons,@typescriptValue,@typescriptComments
                              \ nextgroup=typescriptBlock
                              \ skipwhite skipempty
    4              0.000034 syntax region  typescriptConditionalParen             contained matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=@typescriptValue,@typescriptComments
                              \ nextgroup=typescriptBlock
                              \ skipwhite skipempty
    4              0.000013 syntax match   typescriptEndColons             /[;,]/ contained
                            
    4              0.000028 syntax keyword typescriptAmbientDeclaration declare nextgroup=@typescriptAmbients
                              \ skipwhite skipempty
                            
    4              0.000043 syntax cluster typescriptAmbients contains=
                              \ typescriptVariable,
                              \ typescriptFuncKeyword,
                              \ typescriptClassKeyword,
                              \ typescriptAbstract,
                              \ typescriptEnumKeyword,typescriptEnum,
                              \ typescriptModule
                            
                            "Syntax coloring for Node.js shebang line
    4              0.000017 syntax match   shellbang "^#!.*node\>"
    4              0.000016 syntax match   shellbang "^#!.*iojs\>"
                            
                            
                            "JavaScript comments
    4              0.000013 syntax keyword typescriptCommentTodo TODO FIXME XXX TBD
    4              0.000024 syntax match typescriptMagicComment "@ts-\%(ignore\|expect-error\)\>"
    4              0.000034 syntax match   typescriptLineComment "//.*"
                              \ contains=@Spell,typescriptCommentTodo,typescriptRef,typescriptMagicComment
    4              0.000033 syntax region  typescriptComment
                              \ start="/\*"  end="\*/"
                              \ contains=@Spell,typescriptCommentTodo extend
    4              0.000022 syntax cluster typescriptComments
                              \ contains=typescriptDocComment,typescriptComment,typescriptLineComment
                            
    4              0.000028 syntax match   typescriptRef  +///\s*<reference\s\+.*\/>$+
                              \ contains=typescriptString
    4              0.000026 syntax match   typescriptRef  +///\s*<amd-dependency\s\+.*\/>$+
                              \ contains=typescriptString
    4              0.000033 syntax match   typescriptRef  +///\s*<amd-module\s\+.*\/>$+
                              \ contains=typescriptString
                            
                            "JSDoc
    4              0.000006 syntax case ignore
                            
    4              0.000046 syntax region  typescriptDocComment            matchgroup=typescriptComment
                              \ start="/\*\*"  end="\*/"
                              \ contains=typescriptDocNotation,typescriptCommentTodo,@Spell
                              \ fold keepend
    4              0.000015 syntax match   typescriptDocNotation           contained /@/ nextgroup=typescriptDocTags
                            
    4              0.000026 syntax keyword typescriptDocTags               contained constant constructor constructs function ignore inner private public readonly static
    4              0.000028 syntax keyword typescriptDocTags               contained const dict expose inheritDoc interface nosideeffects override protected struct internal
    4              0.000011 syntax keyword typescriptDocTags               contained example global
    4              0.000029 syntax keyword typescriptDocTags               contained alpha beta defaultValue eventProperty experimental label
    4              0.000016 syntax keyword typescriptDocTags               contained packageDocumentation privateRemarks remarks sealed typeParam
                            
                            " syntax keyword typescriptDocTags               contained ngdoc nextgroup=typescriptDocNGDirective
    4              0.000013 syntax keyword typescriptDocTags               contained ngdoc scope priority animations
    4              0.000024 syntax keyword typescriptDocTags               contained ngdoc restrict methodOf propertyOf eventOf eventType nextgroup=typescriptDocParam skipwhite
    4              0.000030 syntax keyword typescriptDocNGDirective        contained overview service object function method property event directive filter inputType error
                            
    4              0.000012 syntax keyword typescriptDocTags               contained abstract virtual access augments
                            
    4              0.000030 syntax keyword typescriptDocTags               contained arguments callback lends memberOf name type kind link mixes mixin tutorial nextgroup=typescriptDocParam skipwhite
    4              0.000014 syntax keyword typescriptDocTags               contained variation nextgroup=typescriptDocNumParam skipwhite
                            
    4              0.000024 syntax keyword typescriptDocTags               contained author class classdesc copyright default defaultvalue nextgroup=typescriptDocDesc skipwhite
    4              0.000018 syntax keyword typescriptDocTags               contained deprecated description external host nextgroup=typescriptDocDesc skipwhite
    4              0.000022 syntax keyword typescriptDocTags               contained file fileOverview overview namespace requires since version nextgroup=typescriptDocDesc skipwhite
    4              0.000017 syntax keyword typescriptDocTags               contained summary todo license preserve nextgroup=typescriptDocDesc skipwhite
                            
    4              0.000016 syntax keyword typescriptDocTags               contained borrows exports nextgroup=typescriptDocA skipwhite
    4              0.000028 syntax keyword typescriptDocTags               contained param arg argument property prop module nextgroup=typescriptDocNamedParamType,typescriptDocParamName skipwhite
    4              0.000026 syntax keyword typescriptDocTags               contained define enum extends implements this typedef nextgroup=typescriptDocParamType skipwhite
    4              0.000023 syntax keyword typescriptDocTags               contained return returns throws exception nextgroup=typescriptDocParamType,typescriptDocParamName skipwhite
    4              0.000012 syntax keyword typescriptDocTags               contained see nextgroup=typescriptDocRef skipwhite
                            
    4              0.000018 syntax keyword typescriptDocTags               contained function func method nextgroup=typescriptDocName skipwhite
    4              0.000013 syntax match   typescriptDocName               contained /\h\w*/
                            
    4              0.000015 syntax keyword typescriptDocTags               contained fires event nextgroup=typescriptDocEventRef skipwhite
    4              0.000021 syntax match   typescriptDocEventRef           contained /\h\w*#\(\h\w*\:\)\?\h\w*/
                            
    4              0.000019 syntax match   typescriptDocNamedParamType     contained /{.\+}/ nextgroup=typescriptDocParamName skipwhite
    4              0.000027 syntax match   typescriptDocParamName          contained /\[\?0-9a-zA-Z_\.]\+\]\?/ nextgroup=typescriptDocDesc skipwhite
    4              0.000015 syntax match   typescriptDocParamType          contained /{.\+}/ nextgroup=typescriptDocDesc skipwhite
    4              0.000027 syntax match   typescriptDocA                  contained /\%(#\|\w\|\.\|:\|\/\)\+/ nextgroup=typescriptDocAs skipwhite
    4              0.000018 syntax match   typescriptDocAs                 contained /\s*as\s*/ nextgroup=typescriptDocB skipwhite
    4              0.000017 syntax match   typescriptDocB                  contained /\%(#\|\w\|\.\|:\|\/\)\+/
    4              0.000019 syntax match   typescriptDocParam              contained /\%(#\|\w\|\.\|:\|\/\|-\)\+/
    4              0.000012 syntax match   typescriptDocNumParam           contained /\d\+/
    4              0.000059 syntax match   typescriptDocRef                contained /\%(#\|\w\|\.\|:\|\/\)\+/
    4              0.000026 syntax region  typescriptDocLinkTag            contained matchgroup=typescriptDocLinkTag start=/{/ end=/}/ contains=typescriptDocTags
                            
    4              0.000021 syntax cluster typescriptDocs                  contains=typescriptDocParamType,typescriptDocNamedParamType,typescriptDocParam
                            
    4              0.000035 if exists("main_syntax") && main_syntax == "typescript"
    3              0.000006   syntax sync clear
    3              0.000006   syntax sync ccomment typescriptComment minlines=200
    4              0.000005 endif
                            
    4              0.000005 syntax case match
                            
                            " Types
    4              0.000016 syntax match typescriptOptionalMark /?/ contained
                            
    4              0.000024 syntax cluster typescriptTypeParameterCluster contains=
                              \ typescriptTypeParameter,
                              \ typescriptGenericDefault
                            
    4              0.000027 syntax region typescriptTypeParameters matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=@typescriptTypeParameterCluster
                              \ contained
                            
    4              0.000022 syntax match typescriptTypeParameter /\K\k*/
                              \ nextgroup=typescriptConstraint
                              \ contained skipwhite skipnl
                            
    4              0.000018 syntax keyword typescriptConstraint extends
                              \ nextgroup=@typescriptType
                              \ contained skipwhite skipnl
                            
    4              0.000017 syntax match typescriptGenericDefault /=/
                              \ nextgroup=@typescriptType
                              \ contained skipwhite
                            
                            "><
                            " class A extend B<T> {} // ClassBlock
                            " func<T>() // FuncCallArg
    4              0.000042 syntax region typescriptTypeArguments matchgroup=typescriptTypeBrackets
                              \ start=/\></ end=/>/
                              \ contains=@typescriptType
                              \ nextgroup=typescriptFuncCallArg,@typescriptTypeOperator
                              \ contained skipwhite
                            
                            
    4              0.000032 syntax cluster typescriptType contains=
                              \ @typescriptPrimaryType,
                              \ typescriptUnion,
                              \ @typescriptFunctionType,
                              \ typescriptConstructorType
                            
                            " array type: A[]
                            " type indexing A['key']
    4              0.000035 syntax region typescriptTypeBracket contained
                              \ start=/\[/ end=/\]/
                              \ contains=typescriptString,typescriptNumber
                              \ nextgroup=@typescriptTypeOperator
                              \ skipwhite skipempty
                            
    4              0.000068 syntax cluster typescriptPrimaryType contains=
                              \ typescriptParenthesizedType,
                              \ typescriptPredefinedType,
                              \ typescriptTypeReference,
                              \ typescriptObjectType,
                              \ typescriptTupleType,
                              \ typescriptTypeQuery,
                              \ typescriptStringLiteralType,
                              \ typescriptTemplateLiteralType,
                              \ typescriptReadonlyArrayKeyword,
                              \ typescriptAssertType
                            
    4              0.000045 syntax region  typescriptStringLiteralType contained
                              \ start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1\|$/
                              \ nextgroup=typescriptUnion
                              \ skipwhite skipempty
                            
    4              0.000055 syntax region  typescriptTemplateLiteralType contained
                              \ start=/`/  skip=/\\\\\|\\`\|\n/  end=/`\|$/
                              \ contains=typescriptTemplateSubstitutionType
                              \ nextgroup=typescriptTypeOperator
                              \ skipwhite skipempty
                            
    4              0.000027 syntax region  typescriptTemplateSubstitutionType matchgroup=typescriptTemplateSB
                              \ start=/\${/ end=/}/
                              \ contains=@typescriptType
                              \ contained
                            
    4              0.000042 syntax region typescriptParenthesizedType matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=@typescriptType
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite skipempty fold
                            
    4              0.000034 syntax match typescriptTypeReference /\K\k*\(\.\K\k*\)*/
                              \ nextgroup=typescriptTypeArguments,@typescriptTypeOperator,typescriptUserDefinedType
                              \ skipwhite contained skipempty
                            
    4              0.000030 syntax keyword typescriptPredefinedType any number boolean string void never undefined null object unknown
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite skipempty
                            
    4              0.000024 syntax match typescriptPredefinedType /unique symbol/
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite skipempty
                            
    4              0.000056 syntax region typescriptObjectType matchgroup=typescriptBraces
                              \ start=/{/ end=/}/
                              \ contains=@typescriptTypeMember,typescriptEndColons,@typescriptComments,typescriptAccessibilityModifier,typescriptReadonlyModifier
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite skipnl fold
                            
    4              0.000031 syntax cluster typescriptTypeMember contains=
                              \ @typescriptCallSignature,
                              \ typescriptConstructSignature,
                              \ typescriptIndexSignature,
                              \ @typescriptMembers
                            
    4              0.000024 syntax match typescriptTupleLable /\K\k*?\?:/
                                \ contained
                            
    4              0.000043 syntax region typescriptTupleType matchgroup=typescriptBraces
                              \ start=/\[/ end=/\]/
                              \ contains=@typescriptType,@typescriptComments,typescriptRestOrSpread,typescriptTupleLable
                              \ contained skipwhite
                            
    4              0.000026 syntax cluster typescriptTypeOperator
                              \ contains=typescriptUnion,typescriptTypeBracket,typescriptConstraint,typescriptConditionalType
                            
    4              0.000017 syntax match typescriptUnion /|\|&/ contained nextgroup=@typescriptPrimaryType skipwhite skipempty
                            
    4              0.000019 syntax match typescriptConditionalType /?\|:/ contained nextgroup=@typescriptPrimaryType skipwhite skipempty
                            
    4              0.000018 syntax cluster typescriptFunctionType contains=typescriptGenericFunc,typescriptFuncType
    4              0.000039 syntax region typescriptGenericFunc matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=typescriptTypeParameter
                              \ nextgroup=typescriptFuncType
                              \ containedin=typescriptFunctionType
                              \ contained skipwhite skipnl
                            
    4              0.000085 syntax region typescriptFuncType matchgroup=typescriptParens
                              \ start=/(/ end=/)\s*=>/me=e-2
                              \ contains=@typescriptParameterList
                              \ nextgroup=typescriptFuncTypeArrow
                              \ contained skipwhite skipnl oneline
                            
    4              0.000027 syntax match typescriptFuncTypeArrow /=>/
                              \ nextgroup=@typescriptType
                              \ containedin=typescriptFuncType
                              \ contained skipwhite skipnl
                            
                            
    4              0.000018 syntax keyword typescriptConstructorType new
                              \ nextgroup=@typescriptFunctionType
                              \ contained skipwhite skipnl
                            
    4              0.000016 syntax keyword typescriptUserDefinedType is
                              \ contained nextgroup=@typescriptType skipwhite skipempty
                            
    4              0.000018 syntax keyword typescriptTypeQuery typeof keyof
                              \ nextgroup=typescriptTypeReference
                              \ contained skipwhite skipnl
                            
    4              0.000015 syntax keyword typescriptAssertType asserts
                              \ nextgroup=typescriptTypeReference
                              \ contained skipwhite skipnl
                            
    4              0.000016 syntax cluster typescriptCallSignature contains=typescriptGenericCall,typescriptCall
    4              0.000031 syntax region typescriptGenericCall matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=typescriptTypeParameter
                              \ nextgroup=typescriptCall
                              \ contained skipwhite skipnl
    4              0.000044 syntax region typescriptCall matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=typescriptDecorator,@typescriptParameterList,@typescriptComments
                              \ nextgroup=typescriptTypeAnnotation,typescriptBlock
                              \ contained skipwhite skipnl
                            
    4              0.000017 syntax match typescriptTypeAnnotation /:/
                              \ nextgroup=@typescriptType
                              \ contained skipwhite skipnl
                            
    4              0.000055 syntax cluster typescriptParameterList contains=
                              \ typescriptTypeAnnotation,
                              \ typescriptAccessibilityModifier,
                              \ typescriptReadonlyModifier,
                              \ typescriptOptionalMark,
                              \ typescriptRestOrSpread,
                              \ typescriptFuncComma,
                              \ typescriptDefaultParam
                            
    4              0.000009 syntax match typescriptFuncComma /,/ contained
                            
    4              0.000023 syntax match typescriptDefaultParam /=/
                              \ nextgroup=@typescriptValue
                              \ contained skipwhite
                            
    4              0.000016 syntax keyword typescriptConstructSignature new
                              \ nextgroup=@typescriptCallSignature
                              \ contained skipwhite
                            
    4              0.000041 syntax region typescriptIndexSignature matchgroup=typescriptBraces
                              \ start=/\[/ end=/\]/
                              \ contains=typescriptPredefinedType,typescriptMappedIn,typescriptString
                              \ nextgroup=typescriptTypeAnnotation
                              \ contained skipwhite oneline
                            
    4              0.000017 syntax keyword typescriptMappedIn in
                              \ nextgroup=@typescriptType
                              \ contained skipwhite skipnl skipempty
                            
    4              0.000019 syntax keyword typescriptAliasKeyword type
                              \ nextgroup=typescriptAliasDeclaration
                              \ skipwhite skipnl skipempty
                            
    4              0.000050 syntax region typescriptAliasDeclaration matchgroup=typescriptUnion
                              \ start=/ / end=/=/
                              \ nextgroup=@typescriptType
                              \ contains=typescriptConstraint,typescriptTypeParameters
                              \ contained skipwhite skipempty
                            
    4              0.000020 syntax keyword typescriptReadonlyArrayKeyword readonly
                              \ nextgroup=@typescriptPrimaryType
                              \ skipwhite
                            
                            
                            " extension
    4              0.000025 if get(g:, 'yats_host_keyword', 1)
    4              0.000019   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Function Boolean
                              " use of nextgroup Suggested by Doug Kearns
    4              0.000022   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Error EvalError nextgroup=typescriptFuncCallArg
    4              0.000014   syntax keyword typescriptGlobal containedin=typescriptIdentifierName InternalError
    4              0.000016   syntax keyword typescriptGlobal containedin=typescriptIdentifierName RangeError ReferenceError
    4              0.000013   syntax keyword typescriptGlobal containedin=typescriptIdentifierName StopIteration
    4              0.000014   syntax keyword typescriptGlobal containedin=typescriptIdentifierName SyntaxError TypeError
    4              0.000014   syntax keyword typescriptGlobal containedin=typescriptIdentifierName URIError Date
    4              0.000012   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Float32Array
    4              0.000012   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Float64Array
    4              0.000012   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Int16Array Int32Array
    4              0.000012   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Int8Array Uint16Array
    4              0.000012   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Uint32Array Uint8Array
    4              0.000011   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Uint8ClampedArray
    4              0.000011   syntax keyword typescriptGlobal containedin=typescriptIdentifierName ParallelArray
    4              0.000024   syntax keyword typescriptGlobal containedin=typescriptIdentifierName ArrayBuffer DataView
    4              0.000012   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Iterator Generator
    4              0.000012   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Reflect Proxy
    4              0.000012   syntax keyword typescriptGlobal containedin=typescriptIdentifierName arguments
    4              0.000015   hi def link typescriptGlobal Structure
    4              0.000021   syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName eval uneval nextgroup=typescriptFuncCallArg
    4              0.000018   syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName isFinite nextgroup=typescriptFuncCallArg
    4              0.000020   syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName isNaN parseFloat nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName parseInt nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName decodeURI nextgroup=typescriptFuncCallArg
    4              0.000017   syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName decodeURIComponent nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName encodeURI nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName encodeURIComponent nextgroup=typescriptFuncCallArg
    4              0.000012   syntax cluster props add=typescriptGlobalMethod
    4              0.000008   hi def link typescriptGlobalMethod Structure
                            
    4              0.000025   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Number nextgroup=typescriptGlobalNumberDot,typescriptFuncCallArg
    4              0.000025   syntax match   typescriptGlobalNumberDot /\./ contained nextgroup=typescriptNumberStaticProp,typescriptNumberStaticMethod,typescriptProp
    4              0.000014   syntax keyword typescriptNumberStaticProp contained EPSILON MAX_SAFE_INTEGER MAX_VALUE
    4              0.000011   syntax keyword typescriptNumberStaticProp contained MIN_SAFE_INTEGER MIN_VALUE NEGATIVE_INFINITY
    4              0.000009   syntax keyword typescriptNumberStaticProp contained NaN POSITIVE_INFINITY
    4              0.000009   hi def link typescriptNumberStaticProp Keyword
    4              0.000016   syntax keyword typescriptNumberStaticMethod contained isFinite isInteger isNaN isSafeInteger nextgroup=typescriptFuncCallArg
    4              0.000013   syntax keyword typescriptNumberStaticMethod contained parseFloat parseInt nextgroup=typescriptFuncCallArg
    4              0.000008   hi def link typescriptNumberStaticMethod Keyword
    4              0.000016   syntax keyword typescriptNumberMethod contained toExponential toFixed toLocaleString nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptNumberMethod contained toPrecision toSource toString valueOf nextgroup=typescriptFuncCallArg
    4              0.000015   syntax cluster props add=typescriptNumberMethod
    4              0.000006   hi def link typescriptNumberMethod Keyword
                            
    4              0.000023   syntax keyword typescriptGlobal containedin=typescriptIdentifierName String nextgroup=typescriptGlobalStringDot,typescriptFuncCallArg
    4              0.000019   syntax match   typescriptGlobalStringDot /\./ contained nextgroup=typescriptStringStaticMethod,typescriptProp
    4              0.000015   syntax keyword typescriptStringStaticMethod contained fromCharCode fromCodePoint raw nextgroup=typescriptFuncCallArg
    4              0.000006   hi def link typescriptStringStaticMethod Keyword
    4              0.000017   syntax keyword typescriptStringMethod contained anchor charAt charCodeAt codePointAt nextgroup=typescriptFuncCallArg
    4              0.000017   syntax keyword typescriptStringMethod contained concat endsWith includes indexOf lastIndexOf nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptStringMethod contained link localeCompare match normalize nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptStringMethod contained padStart padEnd repeat replace search nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptStringMethod contained slice split startsWith substr substring nextgroup=typescriptFuncCallArg
    4              0.000013   syntax keyword typescriptStringMethod contained toLocaleLowerCase toLocaleUpperCase nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptStringMethod contained toLowerCase toString toUpperCase trim nextgroup=typescriptFuncCallArg
    4              0.000014   syntax keyword typescriptStringMethod contained valueOf nextgroup=typescriptFuncCallArg
    4              0.000012   syntax cluster props add=typescriptStringMethod
    4              0.000006   hi def link typescriptStringMethod Keyword
                            
    4              0.000033   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Array nextgroup=typescriptGlobalArrayDot,typescriptFuncCallArg
    4              0.000018   syntax match   typescriptGlobalArrayDot /\./ contained nextgroup=typescriptArrayStaticMethod,typescriptProp
    4              0.000016   syntax keyword typescriptArrayStaticMethod contained from isArray of nextgroup=typescriptFuncCallArg
    4              0.000006   hi def link typescriptArrayStaticMethod Keyword
    4              0.000018   syntax keyword typescriptArrayMethod contained concat copyWithin entries every fill nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptArrayMethod contained filter find findIndex forEach indexOf nextgroup=typescriptFuncCallArg
    4              0.000017   syntax keyword typescriptArrayMethod contained includes join keys lastIndexOf map nextgroup=typescriptFuncCallArg
    4              0.000028   syntax keyword typescriptArrayMethod contained pop push reduce reduceRight reverse nextgroup=typescriptFuncCallArg
    4              0.000017   syntax keyword typescriptArrayMethod contained shift slice some sort splice toLocaleString nextgroup=typescriptFuncCallArg
    4              0.000013   syntax keyword typescriptArrayMethod contained toSource toString unshift nextgroup=typescriptFuncCallArg
    4              0.000011   syntax cluster props add=typescriptArrayMethod
    4              0.000006   hi def link typescriptArrayMethod Keyword
                            
    4              0.000156   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Object nextgroup=typescriptGlobalObjectDot,typescriptFuncCallArg
    4              0.000025   syntax match   typescriptGlobalObjectDot /\./ contained nextgroup=typescriptObjectStaticMethod,typescriptProp
    4              0.000018   syntax keyword typescriptObjectStaticMethod contained create defineProperties defineProperty nextgroup=typescriptFuncCallArg
    4              0.000018   syntax keyword typescriptObjectStaticMethod contained entries freeze getOwnPropertyDescriptors nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptObjectStaticMethod contained getOwnPropertyDescriptor getOwnPropertyNames nextgroup=typescriptFuncCallArg
    4              0.000014   syntax keyword typescriptObjectStaticMethod contained getOwnPropertySymbols getPrototypeOf nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptObjectStaticMethod contained is isExtensible isFrozen isSealed nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptObjectStaticMethod contained keys preventExtensions values nextgroup=typescriptFuncCallArg
    4              0.000008   hi def link typescriptObjectStaticMethod Keyword
    4              0.000015   syntax keyword typescriptObjectMethod contained getOwnPropertyDescriptors hasOwnProperty nextgroup=typescriptFuncCallArg
    4              0.000014   syntax keyword typescriptObjectMethod contained isPrototypeOf propertyIsEnumerable nextgroup=typescriptFuncCallArg
    4              0.000024   syntax keyword typescriptObjectMethod contained toLocaleString toString valueOf seal nextgroup=typescriptFuncCallArg
    4              0.000013   syntax keyword typescriptObjectMethod contained setPrototypeOf nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptObjectMethod
    4              0.000007   hi def link typescriptObjectMethod Keyword
                            
    4              0.000024   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Symbol nextgroup=typescriptGlobalSymbolDot,typescriptFuncCallArg
    4              0.000028   syntax match   typescriptGlobalSymbolDot /\./ contained nextgroup=typescriptSymbolStaticProp,typescriptSymbolStaticMethod,typescriptProp
    4              0.000012   syntax keyword typescriptSymbolStaticProp contained length iterator match replace
    4              0.000013   syntax keyword typescriptSymbolStaticProp contained search split hasInstance isConcatSpreadable
    4              0.000011   syntax keyword typescriptSymbolStaticProp contained unscopables species toPrimitive
    4              0.000010   syntax keyword typescriptSymbolStaticProp contained toStringTag
    4              0.000007   hi def link typescriptSymbolStaticProp Keyword
    4              0.000015   syntax keyword typescriptSymbolStaticMethod contained for keyFor nextgroup=typescriptFuncCallArg
    4              0.000007   hi def link typescriptSymbolStaticMethod Keyword
                            
    4              0.000016   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Function
    4              0.000016   syntax keyword typescriptFunctionMethod contained apply bind call nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptFunctionMethod
    4              0.000007   hi def link typescriptFunctionMethod Keyword
                            
    4              0.000024   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Math nextgroup=typescriptGlobalMathDot,typescriptFuncCallArg
    4              0.000030   syntax match   typescriptGlobalMathDot /\./ contained nextgroup=typescriptMathStaticProp,typescriptMathStaticMethod,typescriptProp
    4              0.000033   syntax keyword typescriptMathStaticProp contained E LN10 LN2 LOG10E LOG2E PI SQRT1_2
    4              0.000009   syntax keyword typescriptMathStaticProp contained SQRT2
    4              0.000007   hi def link typescriptMathStaticProp Keyword
    4              0.000018   syntax keyword typescriptMathStaticMethod contained abs acos acosh asin asinh atan nextgroup=typescriptFuncCallArg
    4              0.000022   syntax keyword typescriptMathStaticMethod contained atan2 atanh cbrt ceil clz32 cos nextgroup=typescriptFuncCallArg
    4              0.000027   syntax keyword typescriptMathStaticMethod contained cosh exp expm1 floor fround hypot nextgroup=typescriptFuncCallArg
    4              0.000017   syntax keyword typescriptMathStaticMethod contained imul log log10 log1p log2 max nextgroup=typescriptFuncCallArg
    4              0.000018   syntax keyword typescriptMathStaticMethod contained min pow random round sign sin nextgroup=typescriptFuncCallArg
    4              0.000017   syntax keyword typescriptMathStaticMethod contained sinh sqrt tan tanh trunc nextgroup=typescriptFuncCallArg
    4              0.000007   hi def link typescriptMathStaticMethod Keyword
                            
    4              0.000025   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Date nextgroup=typescriptGlobalDateDot,typescriptFuncCallArg
    4              0.000020   syntax match   typescriptGlobalDateDot /\./ contained nextgroup=typescriptDateStaticMethod,typescriptProp
    4              0.000015   syntax keyword typescriptDateStaticMethod contained UTC now parse nextgroup=typescriptFuncCallArg
    4              0.000007   hi def link typescriptDateStaticMethod Keyword
    4              0.000017   syntax keyword typescriptDateMethod contained getDate getDay getFullYear getHours nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptDateMethod contained getMilliseconds getMinutes getMonth nextgroup=typescriptFuncCallArg
    4              0.000019   syntax keyword typescriptDateMethod contained getSeconds getTime getTimezoneOffset nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptDateMethod contained getUTCDate getUTCDay getUTCFullYear nextgroup=typescriptFuncCallArg
    4              0.000014   syntax keyword typescriptDateMethod contained getUTCHours getUTCMilliseconds getUTCMinutes nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptDateMethod contained getUTCMonth getUTCSeconds setDate setFullYear nextgroup=typescriptFuncCallArg
    4              0.000014   syntax keyword typescriptDateMethod contained setHours setMilliseconds setMinutes nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptDateMethod contained setMonth setSeconds setTime setUTCDate nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptDateMethod contained setUTCFullYear setUTCHours setUTCMilliseconds nextgroup=typescriptFuncCallArg
    4              0.000014   syntax keyword typescriptDateMethod contained setUTCMinutes setUTCMonth setUTCSeconds nextgroup=typescriptFuncCallArg
    4              0.000017   syntax keyword typescriptDateMethod contained toDateString toISOString toJSON toLocaleDateString nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptDateMethod contained toLocaleFormat toLocaleString toLocaleTimeString nextgroup=typescriptFuncCallArg
    4              0.000020   syntax keyword typescriptDateMethod contained toSource toString toTimeString toUTCString nextgroup=typescriptFuncCallArg
    4              0.000013   syntax keyword typescriptDateMethod contained valueOf nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptDateMethod
    4              0.000007   hi def link typescriptDateMethod Keyword
                            
    4              0.000024   syntax keyword typescriptGlobal containedin=typescriptIdentifierName JSON nextgroup=typescriptGlobalJSONDot,typescriptFuncCallArg
    4              0.000019   syntax match   typescriptGlobalJSONDot /\./ contained nextgroup=typescriptJSONStaticMethod,typescriptProp
    4              0.000014   syntax keyword typescriptJSONStaticMethod contained parse stringify nextgroup=typescriptFuncCallArg
    4              0.000007   hi def link typescriptJSONStaticMethod Keyword
                            
    4              0.000023   syntax keyword typescriptGlobal containedin=typescriptIdentifierName RegExp nextgroup=typescriptGlobalRegExpDot,typescriptFuncCallArg
    4              0.000018   syntax match   typescriptGlobalRegExpDot /\./ contained nextgroup=typescriptRegExpStaticProp,typescriptProp
    4              0.000009   syntax keyword typescriptRegExpStaticProp contained lastIndex
    4              0.000007   hi def link typescriptRegExpStaticProp Keyword
    4              0.000014   syntax keyword typescriptRegExpProp contained global ignoreCase multiline source sticky
    4              0.000013   syntax cluster props add=typescriptRegExpProp
    4              0.000006   hi def link typescriptRegExpProp Keyword
    4              0.000016   syntax keyword typescriptRegExpMethod contained exec test nextgroup=typescriptFuncCallArg
    4              0.000027   syntax cluster props add=typescriptRegExpMethod
    4              0.000007   hi def link typescriptRegExpMethod Keyword
                            
    4              0.000017   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Map WeakMap
    4              0.000008   syntax keyword typescriptES6MapProp contained size
    4              0.000013   syntax cluster props add=typescriptES6MapProp
    4              0.000006   hi def link typescriptES6MapProp Keyword
    4              0.000021   syntax keyword typescriptES6MapMethod contained clear delete entries forEach get has nextgroup=typescriptFuncCallArg
    4              0.000017   syntax keyword typescriptES6MapMethod contained keys set values nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptES6MapMethod
    4              0.000006   hi def link typescriptES6MapMethod Keyword
                            
    4              0.000016   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Set WeakSet
    4              0.000010   syntax keyword typescriptES6SetProp contained size
    4              0.000013   syntax cluster props add=typescriptES6SetProp
    4              0.000006   hi def link typescriptES6SetProp Keyword
    4              0.000020   syntax keyword typescriptES6SetMethod contained add clear delete entries forEach has nextgroup=typescriptFuncCallArg
    4              0.000012   syntax keyword typescriptES6SetMethod contained values nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptES6SetMethod
    4              0.000006   hi def link typescriptES6SetMethod Keyword
                            
    4              0.000015   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Proxy
    4              0.000011   syntax keyword typescriptProxyAPI contained getOwnPropertyDescriptor getOwnPropertyNames
    4              0.000013   syntax keyword typescriptProxyAPI contained defineProperty deleteProperty freeze seal
    4              0.000014   syntax keyword typescriptProxyAPI contained preventExtensions has hasOwn get set enumerate
    4              0.000012   syntax keyword typescriptProxyAPI contained iterate ownKeys apply construct
    4              0.000006   hi def link typescriptProxyAPI Keyword
                            
    4              0.000023   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Promise nextgroup=typescriptGlobalPromiseDot,typescriptFuncCallArg
    4              0.000020   syntax match   typescriptGlobalPromiseDot /\./ contained nextgroup=typescriptPromiseStaticMethod,typescriptProp
    4              0.000017   syntax keyword typescriptPromiseStaticMethod contained resolve reject all race nextgroup=typescriptFuncCallArg
    4              0.000007   hi def link typescriptPromiseStaticMethod Keyword
    4              0.000017   syntax keyword typescriptPromiseMethod contained then catch finally nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptPromiseMethod
    4              0.000007   hi def link typescriptPromiseMethod Keyword
                            
    4              0.000015   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Reflect
    4              0.000019   syntax keyword typescriptReflectMethod contained apply construct defineProperty deleteProperty nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptReflectMethod contained enumerate get getOwnPropertyDescriptor nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptReflectMethod contained getPrototypeOf has isExtensible ownKeys nextgroup=typescriptFuncCallArg
    4              0.000019   syntax keyword typescriptReflectMethod contained preventExtensions set setPrototypeOf nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptReflectMethod
    4              0.000006   hi def link typescriptReflectMethod Keyword
                            
    4              0.000029   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Intl
    4              0.000017   syntax keyword typescriptIntlMethod contained Collator DateTimeFormat NumberFormat nextgroup=typescriptFuncCallArg
    4              0.000012   syntax keyword typescriptIntlMethod contained PluralRules nextgroup=typescriptFuncCallArg
    4              0.000012   syntax cluster props add=typescriptIntlMethod
    4              0.000006   hi def link typescriptIntlMethod Keyword
                            
    4              0.000022   syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName global process
    4              0.000017   syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName console Buffer
    4              0.000016   syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName module exports
    4              0.000014   syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName setTimeout
    4              0.000015   syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName clearTimeout
    4              0.000014   syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName setInterval
    4              0.000014   syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName clearInterval
    4              0.000111   hi def link typescriptNodeGlobal Structure
                            
    4              0.000014   syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName describe
    4              0.000029   syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName it test before
    4              0.000016   syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName after beforeEach
    4              0.000013   syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName afterEach
    4              0.000013   syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName beforeAll
    4              0.000014   syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName afterAll
    4              0.000015   syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName expect assert
                            
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName AbortController
    4              0.000016   syntax keyword typescriptBOM containedin=typescriptIdentifierName AbstractWorker AnalyserNode
    4              0.000017   syntax keyword typescriptBOM containedin=typescriptIdentifierName App Apps ArrayBuffer
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName ArrayBufferView
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName Attr AudioBuffer
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioBufferSourceNode
    4              0.000017   syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioContext AudioDestinationNode
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioListener AudioNode
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioParam BatteryManager
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName BiquadFilterNode
    4              0.000017   syntax keyword typescriptBOM containedin=typescriptIdentifierName BlobEvent BluetoothAdapter
    4              0.000017   syntax keyword typescriptBOM containedin=typescriptIdentifierName BluetoothDevice
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName BluetoothManager
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName CameraCapabilities
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName CameraControl CameraManager
    4              0.000016   syntax keyword typescriptBOM containedin=typescriptIdentifierName CanvasGradient CanvasImageSource
    4              0.000016   syntax keyword typescriptBOM containedin=typescriptIdentifierName CanvasPattern CanvasRenderingContext2D
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName CaretPosition CDATASection
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName ChannelMergerNode
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName ChannelSplitterNode
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName CharacterData ChildNode
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName ChromeWorker Comment
    4              0.000017   syntax keyword typescriptBOM containedin=typescriptIdentifierName Connection Console
    4              0.000017   syntax keyword typescriptBOM containedin=typescriptIdentifierName ContactManager Contacts
    4              0.000016   syntax keyword typescriptBOM containedin=typescriptIdentifierName ConvolverNode Coordinates
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName CSS CSSConditionRule
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSGroupingRule
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSKeyframeRule
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSKeyframesRule
    4              0.000022   syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSMediaRule CSSNamespaceRule
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSPageRule CSSRule
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSRuleList CSSStyleDeclaration
    4              0.000016   syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSStyleRule CSSStyleSheet
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSSupportsRule
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName DataTransfer DataView
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName DedicatedWorkerGlobalScope
    4              0.000016   syntax keyword typescriptBOM containedin=typescriptIdentifierName DelayNode DeviceAcceleration
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName DeviceRotationRate
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName DeviceStorage DirectoryEntry
    4              0.000024   syntax keyword typescriptBOM containedin=typescriptIdentifierName DirectoryEntrySync
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName DirectoryReader
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName DirectoryReaderSync
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName Document DocumentFragment
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName DocumentTouch DocumentType
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMCursor DOMError
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMException DOMHighResTimeStamp
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMImplementation
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMImplementationRegistry
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMParser DOMRequest
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMString DOMStringList
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMStringMap DOMTimeStamp
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMTokenList DynamicsCompressorNode
    4              0.000017   syntax keyword typescriptBOM containedin=typescriptIdentifierName Element Entry EntrySync
    4              0.000016   syntax keyword typescriptBOM containedin=typescriptIdentifierName Extensions FileException
    4              0.000018   syntax keyword typescriptBOM containedin=typescriptIdentifierName Float32Array Float64Array
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName FMRadio FormData
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName GainNode Gamepad
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName GamepadButton Geolocation
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName History HTMLAnchorElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLAreaElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLAudioElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLBaseElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLBodyElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLBRElement HTMLButtonElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLCanvasElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLCollection HTMLDataElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLDataListElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLDivElement HTMLDListElement
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLDocument HTMLElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLEmbedElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLFieldSetElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLFormControlsCollection
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLFormElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLHeadElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLHeadingElement
    4              0.000021   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLHRElement HTMLHtmlElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLIFrameElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLImageElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLInputElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLKeygenElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLLabelElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLLegendElement
    4              0.000018   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLLIElement HTMLLinkElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLMapElement HTMLMediaElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLMetaElement
    4              0.000024   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLMeterElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLModElement HTMLObjectElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOListElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOptGroupElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOptionElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOptionsCollection
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOutputElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLParagraphElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLParamElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLPreElement HTMLProgressElement
    4              0.000027   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLQuoteElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLScriptElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLSelectElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLSourceElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLSpanElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLStyleElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableCaptionElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableCellElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableColElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableDataCellElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableHeaderCellElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableRowElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableSectionElement
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTextAreaElement
    4              0.000012   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTimeElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTitleElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTrackElement
    4              0.000012   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLUListElement
    4              0.000012   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLUnknownElement
    4              0.000012   syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLVideoElement
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBCursor IDBCursorSync
    4              0.000012   syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBCursorWithValue
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBDatabase IDBDatabaseSync
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBEnvironment IDBEnvironmentSync
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBFactory IDBFactorySync
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBIndex IDBIndexSync
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBKeyRange IDBObjectStore
    4              0.000012   syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBObjectStoreSync
    4              0.000012   syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBOpenDBRequest
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBRequest IDBTransaction
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBTransactionSync
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBVersionChangeEvent
    4              0.000019   syntax keyword typescriptBOM containedin=typescriptIdentifierName ImageData IndexedDB
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName Int16Array Int32Array
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName Int8Array L10n LinkStyle
    4              0.000025   syntax keyword typescriptBOM containedin=typescriptIdentifierName LocalFileSystem
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName LocalFileSystemSync
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName Location LockedFile
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName MediaQueryList MediaQueryListListener
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName MediaRecorder MediaSource
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName MediaStream MediaStreamTrack
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName MutationObserver
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName Navigator NavigatorGeolocation
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName NavigatorID NavigatorLanguage
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName NavigatorOnLine
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName NavigatorPlugins
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName Node NodeFilter
    4              0.000016   syntax keyword typescriptBOM containedin=typescriptIdentifierName NodeIterator NodeList
    4              0.000016   syntax keyword typescriptBOM containedin=typescriptIdentifierName Notification OfflineAudioContext
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName OscillatorNode PannerNode
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName ParentNode Performance
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName PerformanceNavigation
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName PerformanceTiming
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName Permissions PermissionSettings
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName Plugin PluginArray
    4              0.000016   syntax keyword typescriptBOM containedin=typescriptIdentifierName Position PositionError
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName PositionOptions
    4              0.000020   syntax keyword typescriptBOM containedin=typescriptIdentifierName PowerManager ProcessingInstruction
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName PromiseResolver
    4              0.000033   syntax keyword typescriptBOM containedin=typescriptIdentifierName PushManager Range
    4              0.000060   syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCConfiguration
    4              0.000045   syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCPeerConnection
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCPeerConnectionErrorCallback
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCSessionDescription
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCSessionDescriptionCallback
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName ScriptProcessorNode
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName Selection SettingsLock
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SettingsManager
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName SharedWorker StyleSheet
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName StyleSheetList SVGAElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAngle SVGAnimateColorElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedAngle
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedBoolean
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedEnumeration
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedInteger
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedLength
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedLengthList
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedNumber
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedNumberList
    4              0.000017   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedPoints
    4              0.000027   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedPreserveAspectRatio
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedRect
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedString
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedTransformList
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimateElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimateMotionElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimateTransformElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimationElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGCircleElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGClipPathElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGCursorElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGDefsElement SVGDescElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGElement SVGEllipseElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFilterElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontElement SVGFontFaceElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceFormatElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceNameElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceSrcElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceUriElement
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGForeignObjectElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGGElement SVGGlyphElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGGradientElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGHKernElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGImageElement
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGLength SVGLengthList
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGLinearGradientElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGLineElement SVGMaskElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGMatrix SVGMissingGlyphElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGMPathElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGNumber SVGNumberList
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPathElement SVGPatternElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPoint SVGPolygonElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPolylineElement
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPreserveAspectRatio
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGRadialGradientElement
    4              0.000018   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGRect SVGRectElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGScriptElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGSetElement SVGStopElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGStringList SVGStylable
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGStyleElement
    4              0.000016   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGSVGElement SVGSwitchElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGSymbolElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTests SVGTextElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTextPositioningElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTitleElement
    4              0.000026   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTransform SVGTransformable
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTransformList
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTRefElement SVGTSpanElement
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGUseElement SVGViewElement
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGVKernElement
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName TCPServerSocket
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName TCPSocket Telephony
    4              0.000020   syntax keyword typescriptBOM containedin=typescriptIdentifierName TelephonyCall Text
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName TextDecoder TextEncoder
    4              0.000108   syntax keyword typescriptBOM containedin=typescriptIdentifierName TextMetrics TimeRanges
    4              0.000016   syntax keyword typescriptBOM containedin=typescriptIdentifierName Touch TouchList
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName Transferable TreeWalker
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName Uint16Array Uint32Array
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName Uint8Array Uint8ClampedArray
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName URLSearchParams
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName URLUtilsReadOnly
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName UserProximityEvent
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName ValidityState VideoPlaybackQuality
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName WaveShaperNode WebBluetooth
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName WebGLRenderingContext
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName WebSMS WebSocket
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName WebVTT WifiManager
    4              0.000015   syntax keyword typescriptBOM containedin=typescriptIdentifierName Window Worker WorkerConsole
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName WorkerLocation WorkerNavigator
    4              0.000014   syntax keyword typescriptBOM containedin=typescriptIdentifierName XDomainRequest XMLDocument
    4              0.000013   syntax keyword typescriptBOM containedin=typescriptIdentifierName XMLHttpRequestEventTarget
    4              0.000008   hi def link typescriptBOM Structure
                            
    4              0.000015   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName applicationCache
    4              0.000014   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName closed
    4              0.000014   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName Components
    4              0.000014   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName controllers
    4              0.000014   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName dialogArguments
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName document
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName frameElement
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName frames
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName fullScreen
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName history
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName innerHeight
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName innerWidth
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName length
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName location
    4              0.000014   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName locationbar
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName menubar
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName messageManager
    4              0.000018   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName name navigator
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName opener
    4              0.000025   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName outerHeight
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName outerWidth
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName pageXOffset
    4              0.000018   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName pageYOffset
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName parent
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName performance
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName personalbar
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName returnValue
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName screen
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName screenX
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName screenY
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollbars
    4              0.000014   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollMaxX
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollMaxY
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollX
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollY
    4              0.000015   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName self sidebar
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName status
    4              0.000014   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName statusbar
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName toolbar
    4              0.000016   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName top visualViewport
    4              0.000013   syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName window
    4              0.000015   syntax cluster props add=typescriptBOMWindowProp
    4              0.000008   hi def link typescriptBOMWindowProp Structure
    4              0.000022   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName alert nextgroup=typescriptFuncCallArg
    4              0.000020   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName atob nextgroup=typescriptFuncCallArg
    4              0.000019   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName blur nextgroup=typescriptFuncCallArg
    4              0.000018   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName btoa nextgroup=typescriptFuncCallArg
    4              0.000020   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName clearImmediate nextgroup=typescriptFuncCallArg
    4              0.000019   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName clearInterval nextgroup=typescriptFuncCallArg
    4              0.000019   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName clearTimeout nextgroup=typescriptFuncCallArg
    4              0.000019   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName close nextgroup=typescriptFuncCallArg
    4              0.000019   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName confirm nextgroup=typescriptFuncCallArg
    4              0.000019   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName dispatchEvent nextgroup=typescriptFuncCallArg
    4              0.000019   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName find nextgroup=typescriptFuncCallArg
    4              0.000018   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName focus nextgroup=typescriptFuncCallArg
    4              0.000019   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getAttention nextgroup=typescriptFuncCallArg
    4              0.000020   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getAttentionWithCycleCount nextgroup=typescriptFuncCallArg
    4              0.000019   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getComputedStyle nextgroup=typescriptFuncCallArg
    4              0.000020   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getDefaulComputedStyle nextgroup=typescriptFuncCallArg
    4              0.000030   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getSelection nextgroup=typescriptFuncCallArg
    4              0.000018   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName matchMedia nextgroup=typescriptFuncCallArg
    4              0.000018   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName maximize nextgroup=typescriptFuncCallArg
    4              0.000018   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName moveBy nextgroup=typescriptFuncCallArg
    4              0.000018   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName moveTo nextgroup=typescriptFuncCallArg
    4              0.000018   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName open nextgroup=typescriptFuncCallArg
    4              0.000018   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName openDialog nextgroup=typescriptFuncCallArg
    4              0.000018   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName postMessage nextgroup=typescriptFuncCallArg
    4              0.000018   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName print nextgroup=typescriptFuncCallArg
    4              0.000018   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName prompt nextgroup=typescriptFuncCallArg
    4              0.000023   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName removeEventListener nextgroup=typescriptFuncCallArg
    4              0.000018   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName resizeBy nextgroup=typescriptFuncCallArg
    4              0.000038   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName resizeTo nextgroup=typescriptFuncCallArg
    4              0.000021   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName restore nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scroll nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollBy nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollByLines nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollByPages nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollTo nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setCursor nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setImmediate nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setInterval nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setResizable nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setTimeout nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName showModalDialog nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName sizeToContent nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName stop nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName updateCommands nextgroup=typescriptFuncCallArg
    4              0.000014   syntax cluster props add=typescriptBOMWindowMethod
    4              0.000008   hi def link typescriptBOMWindowMethod Structure
    4              0.000014   syntax keyword typescriptBOMWindowEvent contained onabort onbeforeunload onblur onchange
    4              0.000012   syntax keyword typescriptBOMWindowEvent contained onclick onclose oncontextmenu ondevicelight
    4              0.000010   syntax keyword typescriptBOMWindowEvent contained ondevicemotion ondeviceorientation
    4              0.000010   syntax keyword typescriptBOMWindowEvent contained ondeviceproximity ondragdrop onerror
    4              0.000011   syntax keyword typescriptBOMWindowEvent contained onfocus onhashchange onkeydown onkeypress
    4              0.000011   syntax keyword typescriptBOMWindowEvent contained onkeyup onload onmousedown onmousemove
    4              0.000009   syntax keyword typescriptBOMWindowEvent contained onmouseout onmouseover onmouseup
    4              0.000023   syntax keyword typescriptBOMWindowEvent contained onmozbeforepaint onpaint onpopstate
    4              0.000011   syntax keyword typescriptBOMWindowEvent contained onreset onresize onscroll onselect
    4              0.000017   syntax keyword typescriptBOMWindowEvent contained onsubmit onunload onuserproximity
    4              0.000009   syntax keyword typescriptBOMWindowEvent contained onpageshow onpagehide
    4              0.000007   hi def link typescriptBOMWindowEvent Keyword
    4              0.000015   syntax keyword typescriptBOMWindowCons containedin=typescriptIdentifierName DOMParser
    4              0.000013   syntax keyword typescriptBOMWindowCons containedin=typescriptIdentifierName QueryInterface
    4              0.000012   syntax keyword typescriptBOMWindowCons containedin=typescriptIdentifierName XMLSerializer
    4              0.000006   hi def link typescriptBOMWindowCons Structure
                            
    4              0.000012   syntax keyword typescriptBOMNavigatorProp contained battery buildID connection cookieEnabled
    4              0.000010   syntax keyword typescriptBOMNavigatorProp contained doNotTrack maxTouchPoints oscpu
    4              0.000009   syntax keyword typescriptBOMNavigatorProp contained productSub push serviceWorker
    4              0.000008   syntax keyword typescriptBOMNavigatorProp contained vendor vendorSub
    4              0.000017   syntax cluster props add=typescriptBOMNavigatorProp
    4              0.000007   hi def link typescriptBOMNavigatorProp Keyword
    4              0.000016   syntax keyword typescriptBOMNavigatorMethod contained addIdleObserver geolocation nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptBOMNavigatorMethod contained getDeviceStorage getDeviceStorages nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptBOMNavigatorMethod contained getGamepads getUserMedia registerContentHandler nextgroup=typescriptFuncCallArg
    4              0.000013   syntax keyword typescriptBOMNavigatorMethod contained removeIdleObserver requestWakeLock nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptBOMNavigatorMethod contained share vibrate watch registerProtocolHandler nextgroup=typescriptFuncCallArg
    4              0.000012   syntax keyword typescriptBOMNavigatorMethod contained sendBeacon nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptBOMNavigatorMethod
    4              0.000006   hi def link typescriptBOMNavigatorMethod Keyword
    4              0.000012   syntax keyword typescriptServiceWorkerMethod contained register nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptServiceWorkerMethod
    4              0.000006   hi def link typescriptServiceWorkerMethod Keyword
                            
    4              0.000017   syntax keyword typescriptBOMLocationProp contained href protocol host hostname port
    4              0.000011   syntax keyword typescriptBOMLocationProp contained pathname search hash username password
    4              0.000007   syntax keyword typescriptBOMLocationProp contained origin
    4              0.000013   syntax cluster props add=typescriptBOMLocationProp
    4              0.000006   hi def link typescriptBOMLocationProp Keyword
    4              0.000017   syntax keyword typescriptBOMLocationMethod contained assign reload replace toString nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptBOMLocationMethod
    4              0.000006   hi def link typescriptBOMLocationMethod Keyword
                            
    4              0.000012   syntax keyword typescriptBOMHistoryProp contained length current next previous state
    4              0.000007   syntax keyword typescriptBOMHistoryProp contained scrollRestoration
    4              0.000012   syntax cluster props add=typescriptBOMHistoryProp
    4              0.000006   hi def link typescriptBOMHistoryProp Keyword
    4              0.000018   syntax keyword typescriptBOMHistoryMethod contained back forward go pushState replaceState nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptBOMHistoryMethod
    4              0.000006   hi def link typescriptBOMHistoryMethod Keyword
                            
    4              0.000014   syntax keyword typescriptGlobal containedin=typescriptIdentifierName console
    4              0.000018   syntax keyword typescriptConsoleMethod contained count dir error group groupCollapsed nextgroup=typescriptFuncCallArg
    4              0.000018   syntax keyword typescriptConsoleMethod contained groupEnd info log time timeEnd trace nextgroup=typescriptFuncCallArg
    4              0.000011   syntax keyword typescriptConsoleMethod contained warn nextgroup=typescriptFuncCallArg
    4              0.000012   syntax cluster props add=typescriptConsoleMethod
    4              0.000006   hi def link typescriptConsoleMethod Keyword
                            
    4              0.000013   syntax keyword typescriptXHRGlobal containedin=typescriptIdentifierName XMLHttpRequest
    4              0.000006   hi def link typescriptXHRGlobal Structure
    4              0.000010   syntax keyword typescriptXHRProp contained onreadystatechange readyState response
    4              0.000011   syntax keyword typescriptXHRProp contained responseText responseType responseXML status
    4              0.000012   syntax keyword typescriptXHRProp contained statusText timeout ontimeout upload withCredentials
    4              0.000022   syntax cluster props add=typescriptXHRProp
    4              0.000006   hi def link typescriptXHRProp Keyword
    4              0.000015   syntax keyword typescriptXHRMethod contained abort getAllResponseHeaders getResponseHeader nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptXHRMethod contained open overrideMimeType send setRequestHeader nextgroup=typescriptFuncCallArg
    4              0.000012   syntax cluster props add=typescriptXHRMethod
    4              0.000006   hi def link typescriptXHRMethod Keyword
                            
    4              0.000014   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Blob BlobBuilder
    4              0.000014   syntax keyword typescriptGlobal containedin=typescriptIdentifierName File FileReader
    4              0.000012   syntax keyword typescriptGlobal containedin=typescriptIdentifierName FileReaderSync
    4              0.000022   syntax keyword typescriptGlobal containedin=typescriptIdentifierName URL nextgroup=typescriptGlobalURLDot,typescriptFuncCallArg
    4              0.000025   syntax match   typescriptGlobalURLDot /\./ contained nextgroup=typescriptURLStaticMethod,typescriptProp
    4              0.000013   syntax keyword typescriptGlobal containedin=typescriptIdentifierName URLUtils
    4              0.000013   syntax keyword typescriptFileMethod contained readAsArrayBuffer readAsBinaryString nextgroup=typescriptFuncCallArg
    4              0.000013   syntax keyword typescriptFileMethod contained readAsDataURL readAsText nextgroup=typescriptFuncCallArg
    4              0.000012   syntax cluster props add=typescriptFileMethod
    4              0.000006   hi def link typescriptFileMethod Keyword
    4              0.000010   syntax keyword typescriptFileReaderProp contained error readyState result
    4              0.000012   syntax cluster props add=typescriptFileReaderProp
    4              0.000006   hi def link typescriptFileReaderProp Keyword
    4              0.000017   syntax keyword typescriptFileReaderMethod contained abort readAsArrayBuffer readAsBinaryString nextgroup=typescriptFuncCallArg
    4              0.000014   syntax keyword typescriptFileReaderMethod contained readAsDataURL readAsText nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptFileReaderMethod
    4              0.000006   hi def link typescriptFileReaderMethod Keyword
    4              0.000012   syntax keyword typescriptFileListMethod contained item nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptFileListMethod
    4              0.000006   hi def link typescriptFileListMethod Keyword
    4              0.000014   syntax keyword typescriptBlobMethod contained append getBlob getFile nextgroup=typescriptFuncCallArg
    4              0.000014   syntax cluster props add=typescriptBlobMethod
    4              0.000006   hi def link typescriptBlobMethod Keyword
    4              0.000014   syntax keyword typescriptURLUtilsProp contained hash host hostname href origin password
    4              0.000012   syntax keyword typescriptURLUtilsProp contained pathname port protocol search searchParams
    4              0.000007   syntax keyword typescriptURLUtilsProp contained username
    4              0.000013   syntax cluster props add=typescriptURLUtilsProp
    4              0.000006   hi def link typescriptURLUtilsProp Keyword
    4              0.000013   syntax keyword typescriptURLStaticMethod contained createObjectURL revokeObjectURL nextgroup=typescriptFuncCallArg
    4              0.000006   hi def link typescriptURLStaticMethod Keyword
                            
    4              0.000014   syntax keyword typescriptCryptoGlobal containedin=typescriptIdentifierName crypto
    4              0.000006   hi def link typescriptCryptoGlobal Structure
    4              0.000016   syntax keyword typescriptSubtleCryptoMethod contained encrypt decrypt sign verify nextgroup=typescriptFuncCallArg
    4              0.000012   syntax keyword typescriptSubtleCryptoMethod contained digest nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptSubtleCryptoMethod
    4              0.000006   hi def link typescriptSubtleCryptoMethod Keyword
    4              0.000008   syntax keyword typescriptCryptoProp contained subtle
    4              0.000012   syntax cluster props add=typescriptCryptoProp
    4              0.000006   hi def link typescriptCryptoProp Keyword
    4              0.000027   syntax keyword typescriptCryptoMethod contained getRandomValues nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptCryptoMethod
    4              0.000006   hi def link typescriptCryptoMethod Keyword
                            
    4              0.000014   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Headers Request
    4              0.000013   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Response
    4              0.000018   syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName fetch nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptGlobalMethod
    4              0.000007   hi def link typescriptGlobalMethod Structure
    4              0.000018   syntax keyword typescriptHeadersMethod contained append delete get getAll has set nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptHeadersMethod
    4              0.000016   hi def link typescriptHeadersMethod Keyword
    4              0.000014   syntax keyword typescriptRequestProp contained method url headers context referrer
    4              0.000011   syntax keyword typescriptRequestProp contained mode credentials cache
    4              0.000013   syntax cluster props add=typescriptRequestProp
    4              0.000006   hi def link typescriptRequestProp Keyword
    4              0.000012   syntax keyword typescriptRequestMethod contained clone nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptRequestMethod
    4              0.000006   hi def link typescriptRequestMethod Keyword
    4              0.000012   syntax keyword typescriptResponseProp contained type url status statusText headers
    4              0.000007   syntax keyword typescriptResponseProp contained redirected
    4              0.000013   syntax cluster props add=typescriptResponseProp
    4              0.000006   hi def link typescriptResponseProp Keyword
    4              0.000012   syntax keyword typescriptResponseMethod contained clone nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptResponseMethod
    4              0.000006   hi def link typescriptResponseMethod Keyword
                            
    4              0.000010   syntax keyword typescriptServiceWorkerProp contained controller ready
    4              0.000014   syntax cluster props add=typescriptServiceWorkerProp
    4              0.000006   hi def link typescriptServiceWorkerProp Keyword
    4              0.000013   syntax keyword typescriptServiceWorkerMethod contained register getRegistration nextgroup=typescriptFuncCallArg
    4              0.000015   syntax cluster props add=typescriptServiceWorkerMethod
    4              0.000006   hi def link typescriptServiceWorkerMethod Keyword
    4              0.000013   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Cache
    4              0.000018   syntax keyword typescriptCacheMethod contained match matchAll add addAll put delete nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptCacheMethod contained keys nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptCacheMethod
    4              0.000006   hi def link typescriptCacheMethod Keyword
                            
    4              0.000015   syntax keyword typescriptEncodingGlobal containedin=typescriptIdentifierName TextEncoder
    4              0.000013   syntax keyword typescriptEncodingGlobal containedin=typescriptIdentifierName TextDecoder
    4              0.000007   hi def link typescriptEncodingGlobal Structure
    4              0.000010   syntax keyword typescriptEncodingProp contained encoding fatal ignoreBOM
    4              0.000013   syntax cluster props add=typescriptEncodingProp
    4              0.000006   hi def link typescriptEncodingProp Keyword
    4              0.000015   syntax keyword typescriptEncodingMethod contained encode decode nextgroup=typescriptFuncCallArg
    4              0.000014   syntax cluster props add=typescriptEncodingMethod
    4              0.000006   hi def link typescriptEncodingMethod Keyword
                            
    4              0.000013   syntax keyword typescriptGlobal containedin=typescriptIdentifierName Geolocation
    4              0.000014   syntax keyword typescriptGeolocationMethod contained getCurrentPosition watchPosition nextgroup=typescriptFuncCallArg
    4              0.000017   syntax keyword typescriptGeolocationMethod contained clearWatch nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptGeolocationMethod
    4              0.000006   hi def link typescriptGeolocationMethod Keyword
                            
    4              0.000013   syntax keyword typescriptGlobal containedin=typescriptIdentifierName NetworkInformation
    4              0.000010   syntax keyword typescriptBOMNetworkProp contained downlink downlinkMax effectiveType
    4              0.000009   syntax keyword typescriptBOMNetworkProp contained rtt type
    4              0.000013   syntax cluster props add=typescriptBOMNetworkProp
    4              0.000006   hi def link typescriptBOMNetworkProp Keyword
                            
    4              0.000012   syntax keyword typescriptGlobal containedin=typescriptIdentifierName PaymentRequest
    4              0.000015   syntax keyword typescriptPaymentMethod contained show abort canMakePayment nextgroup=typescriptFuncCallArg
    4              0.000013   syntax cluster props add=typescriptPaymentMethod
    4              0.000006   hi def link typescriptPaymentMethod Keyword
    4              0.000011   syntax keyword typescriptPaymentProp contained shippingAddress shippingOption result
    4              0.000013   syntax cluster props add=typescriptPaymentProp
    4              0.000006   hi def link typescriptPaymentProp Keyword
    4              0.000011   syntax keyword typescriptPaymentEvent contained onshippingaddresschange onshippingoptionchange
    4              0.000006   hi def link typescriptPaymentEvent Keyword
    4              0.000014   syntax keyword typescriptPaymentResponseMethod contained complete nextgroup=typescriptFuncCallArg
    4              0.000015   syntax cluster props add=typescriptPaymentResponseMethod
    4              0.000007   hi def link typescriptPaymentResponseMethod Keyword
    4              0.000010   syntax keyword typescriptPaymentResponseProp contained details methodName payerEmail
    4              0.000009   syntax keyword typescriptPaymentResponseProp contained payerPhone shippingAddress
    4              0.000008   syntax keyword typescriptPaymentResponseProp contained shippingOption
    4              0.000023   syntax cluster props add=typescriptPaymentResponseProp
    4              0.000007   hi def link typescriptPaymentResponseProp Keyword
    4              0.000012   syntax keyword typescriptPaymentAddressProp contained addressLine careOf city country
    4              0.000010   syntax keyword typescriptPaymentAddressProp contained country dependentLocality languageCode
    4              0.000009   syntax keyword typescriptPaymentAddressProp contained organization phone postalCode
    4              0.000009   syntax keyword typescriptPaymentAddressProp contained recipient region sortingCode
    4              0.000014   syntax cluster props add=typescriptPaymentAddressProp
    4              0.000006   hi def link typescriptPaymentAddressProp Keyword
    4              0.000011   syntax keyword typescriptPaymentShippingOptionProp contained id label amount selected
    4              0.000015   syntax cluster props add=typescriptPaymentShippingOptionProp
    4              0.000007   hi def link typescriptPaymentShippingOptionProp Keyword
                            
    4              0.000010   syntax keyword typescriptDOMNodeProp contained attributes baseURI baseURIObject childNodes
    4              0.000010   syntax keyword typescriptDOMNodeProp contained firstChild lastChild localName namespaceURI
    4              0.000010   syntax keyword typescriptDOMNodeProp contained nextSibling nodeName nodePrincipal
    4              0.000012   syntax keyword typescriptDOMNodeProp contained nodeType nodeValue ownerDocument parentElement
    4              0.000012   syntax keyword typescriptDOMNodeProp contained parentNode prefix previousSibling textContent
    4              0.000013   syntax cluster props add=typescriptDOMNodeProp
    4              0.000006   hi def link typescriptDOMNodeProp Keyword
    4              0.000016   syntax keyword typescriptDOMNodeMethod contained appendChild cloneNode compareDocumentPosition nextgroup=typescriptFuncCallArg
    4              0.000014   syntax keyword typescriptDOMNodeMethod contained getUserData hasAttributes hasChildNodes nextgroup=typescriptFuncCallArg
    4              0.000014   syntax keyword typescriptDOMNodeMethod contained insertBefore isDefaultNamespace isEqualNode nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptDOMNodeMethod contained isSameNode isSupported lookupNamespaceURI nextgroup=typescriptFuncCallArg
    4              0.000016   syntax keyword typescriptDOMNodeMethod contained lookupPrefix normalize removeChild nextgroup=typescriptFuncCallArg
    4              0.000020   syntax keyword typescriptDOMNodeMethod contained replaceChild setUserData nextgroup=typescriptFuncCallArg
    4              0.000018   syntax match typescriptDOMNodeMethod contained /contains/
    4              0.000014   syntax cluster props add=typescriptDOMNodeMethod
    4              0.000006   hi def link typescriptDOMNodeMethod Keyword
    4              0.000012   syntax keyword typescriptDOMNodeType contained ELEMENT_NODE ATTRIBUTE_NODE TEXT_NODE
    4              0.000011   syntax keyword typescriptDOMNodeType contained CDATA_SECTION_NODEN_NODE ENTITY_REFERENCE_NODE
    4              0.000010   syntax keyword typescriptDOMNodeType contained ENTITY_NODE PROCESSING_INSTRUCTION_NODEN_NODE
    4              0.000017   syntax keyword typescriptDOMNodeType contained COMMENT_NODE DOCUMENT_NODE DOCUMENT_TYPE_NODE
    4              0.000008   syntax keyword typescriptDOMNodeType contained DOCUMENT_FRAGMENT_NODE NOTATION_NODE
    4              0.000006   hi def link typescriptDOMNodeType Keyword
                            
    4              0.000010   syntax keyword typescriptDOMElemAttrs contained accessKey clientHeight clientLeft
    4              0.000010   syntax keyword typescriptDOMElemAttrs contained clientTop clientWidth id innerHTML
    4              0.000011   syntax keyword typescriptDOMElemAttrs contained length onafterscriptexecute onbeforescriptexecute
    4              0.000011   syntax keyword typescriptDOMElemAttrs contained oncopy oncut onpaste onwheel scrollHeight
    4              0.000010   syntax keyword typescriptDOMElemAttrs contained scrollLeft scrollTop scrollWidth tagName
    4              0.000010   syntax keyword typescriptDOMElemAttrs contained classList className name outerHTML
    4              0.000007   syntax keyword typescriptDOMElemAttrs contained style
    4              0.000006   hi def link typescriptDOMElemAttrs Keyword
    4              0.000010   syntax keyword typescriptDOMElemFuncs contained getAttributeNS getAttributeNode getAttributeNodeNS
    4              0.000008   syntax keyword typescriptDOMElemFuncs contained getBoundingClientRect getClientRects
    4              0.000008   syntax keyword typescriptDOMElemFuncs contained getElementsByClassName getElementsByTagName
    4              0.000008   syntax keyword typescriptDOMElemFuncs contained getElementsByTagNameNS hasAttribute
    4              0.000008   syntax keyword typescriptDOMElemFuncs contained hasAttributeNS insertAdjacentHTML
    4              0.000008   syntax keyword typescriptDOMElemFuncs contained matches querySelector querySelectorAll
    4              0.000008   syntax keyword typescriptDOMElemFuncs contained removeAttribute removeAttributeNS
    4              0.000008   syntax keyword typescriptDOMElemFuncs contained removeAttributeNode requestFullscreen
    4              0.000019   syntax keyword typescriptDOMElemFuncs contained requestPointerLock scrollIntoView
    4              0.000010   syntax keyword typescriptDOMElemFuncs contained setAttribute setAttributeNS setAttributeNode
    4              0.000009   syntax keyword typescriptDOMElemFuncs contained setAttributeNodeNS setCapture supports
    4              0.000007   syntax keyword typescriptDOMElemFuncs contained getAttribute
    4              0.000006   hi def link typescriptDOMElemFuncs Keyword
                            
    4              0.000012   syntax keyword typescriptDOMDocProp contained activeElement body cookie defaultView
    4              0.000013   syntax keyword typescriptDOMDocProp contained designMode dir domain embeds forms head
    4              0.000011   syntax keyword typescriptDOMDocProp contained images lastModified links location plugins
    4              0.000010   syntax keyword typescriptDOMDocProp contained postMessage readyState referrer registerElement
    4              0.000011   syntax keyword typescriptDOMDocProp contained scripts styleSheets title vlinkColor
    4              0.000009   syntax keyword typescriptDOMDocProp contained xmlEncoding characterSet compatMode
    4              0.000012   syntax keyword typescriptDOMDocProp contained contentType currentScript doctype documentElement
    4              0.000013   syntax keyword typescriptDOMDocProp contained documentURI documentURIObject firstChild
    4              0.000010   syntax keyword typescriptDOMDocProp contained implementation lastStyleSheetSet namespaceURI
    4              0.000009   syntax keyword typescriptDOMDocProp contained nodePrincipal ononline pointerLockElement
    4              0.000010   syntax keyword typescriptDOMDocProp contained popupNode preferredStyleSheetSet selectedStyleSheetSet
    4              0.000009   syntax keyword typescriptDOMDocProp contained styleSheetSets textContent tooltipNode
    4              0.000014   syntax cluster props add=typescriptDOMDocProp
    4              0.000006   hi def link typescriptDOMDocProp Keyword
    4              0.000016   syntax keyword typescriptDOMDocMethod contained caretPositionFromPoint close createNodeIterator nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptDOMDocMethod contained createRange createTreeWalker elementFromPoint nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptDOMDocMethod contained getElementsByName adoptNode createAttribute nextgroup=typescriptFuncCallArg
    4              0.000025   syntax keyword typescriptDOMDocMethod contained createCDATASection createComment createDocumentFragment nextgroup=typescriptFuncCallArg
    4              0.000014   syntax keyword typescriptDOMDocMethod contained createElement createElementNS createEvent nextgroup=typescriptFuncCallArg
    4              0.000012   syntax keyword typescriptDOMDocMethod contained createExpression createNSResolver nextgroup=typescriptFuncCallArg
    4              0.000013   syntax keyword typescriptDOMDocMethod contained createProcessingInstruction createTextNode nextgroup=typescriptFuncCallArg
    4              0.000014   syntax keyword typescriptDOMDocMethod contained enableStyleSheetsForSet evaluate execCommand nextgroup=typescriptFuncCallArg
    4              0.000014   syntax keyword typescriptDOMDocMethod contained exitPointerLock getBoxObjectFor getElementById nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptDOMDocMethod contained getElementsByClassName getElementsByTagName nextgroup=typescriptFuncCallArg
    4              0.000014   syntax keyword typescriptDOMDocMethod contained getElementsByTagNameNS getSelection nextgroup=typescriptFuncCallArg
    4              0.000015   syntax keyword typescriptDOMDocMethod contained hasFocus importNode loadOverlay open nextgroup=typescriptFuncCallArg
    4              0.000012   syntax keyword typescriptDOMDocMethod contained queryCommandSupported querySelector nextgroup=typescriptFuncCallArg
    4              0.000013   syntax keyword typescriptDOMDocMethod contained querySelectorAll write writeln nextgroup=typescriptFuncCallArg
    4              0.000014   syntax cluster props add=typescriptDOMDocMethod
    4              0.000006   hi def link typescriptDOMDocMethod Keyword
                            
    4              0.000015   syntax keyword typescriptDOMEventTargetMethod contained addEventListener removeEventListener nextgroup=typescriptEventFuncCallArg
    4              0.000014   syntax keyword typescriptDOMEventTargetMethod contained dispatchEvent waitUntil nextgroup=typescriptEventFuncCallArg
    4              0.000015   syntax cluster props add=typescriptDOMEventTargetMethod
    4              0.000006   hi def link typescriptDOMEventTargetMethod Keyword
    4              0.000014   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName AnimationEvent
    4              0.000014   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName AudioProcessingEvent
    4              0.000013   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName BeforeInputEvent
    4              0.000022   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName BeforeUnloadEvent
    4              0.000013   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName BlobEvent
    4              0.000013   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName ClipboardEvent
    4              0.000013   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CloseEvent
    4              0.000013   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CompositionEvent
    4              0.000013   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CSSFontFaceLoadEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CustomEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceLightEvent
    4              0.000013   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceMotionEvent
    4              0.000013   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceOrientationEvent
    4              0.000018   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceProximityEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DOMTransactionEvent
    4              0.000013   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DragEvent
    4              0.000013   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName EditingBeforeInputEvent
    4              0.000013   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName ErrorEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName FocusEvent
    4              0.000013   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName GamepadEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName HashChangeEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName IDBVersionChangeEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName KeyboardEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MediaStreamEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MessageEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MouseEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MutationEvent
    4              0.000028   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName OfflineAudioCompletionEvent
    4              0.000013   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName PageTransitionEvent
    4              0.000013   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName PointerEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName PopStateEvent
    4              0.000013   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName ProgressEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName RelatedEvent
    4              0.000014   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName RTCPeerConnectionIceEvent
    4              0.000013   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName SensorEvent
    4              0.000040   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName StorageEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName SVGEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName SVGZoomEvent
    4              0.000049   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TimeEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TouchEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TrackEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TransitionEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName UIEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName UserProximityEvent
    4              0.000012   syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName WheelEvent
    4              0.000007   hi def link typescriptDOMEventCons Structure
    4              0.000011   syntax keyword typescriptDOMEventProp contained bubbles cancelable currentTarget defaultPrevented
    4              0.000011   syntax keyword typescriptDOMEventProp contained eventPhase target timeStamp type isTrusted
    4              0.000007   syntax keyword typescriptDOMEventProp contained isReload
    4              0.000014   syntax cluster props add=typescriptDOMEventProp
    4              0.000017   hi def link typescriptDOMEventProp Keyword
    4              0.000020   syntax keyword typescriptDOMEventMethod contained initEvent preventDefault stopImmediatePropagation nextgroup=typescriptEventFuncCallArg
    4              0.000017   syntax keyword typescriptDOMEventMethod contained stopPropagation respondWith default nextgroup=typescriptEventFuncCallArg
    4              0.000014   syntax cluster props add=typescriptDOMEventMethod
    4              0.000006   hi def link typescriptDOMEventMethod Keyword
                            
    4              0.000009   syntax keyword typescriptDOMStorage contained sessionStorage localStorage
    4              0.000006   hi def link typescriptDOMStorage Keyword
    4              0.000008   syntax keyword typescriptDOMStorageProp contained length
    4              0.000014   syntax cluster props add=typescriptDOMStorageProp
    4              0.000006   hi def link typescriptDOMStorageProp Keyword
    4              0.000017   syntax keyword typescriptDOMStorageMethod contained getItem key setItem removeItem nextgroup=typescriptFuncCallArg
    4              0.000012   syntax keyword typescriptDOMStorageMethod contained clear nextgroup=typescriptFuncCallArg
    4              0.000015   syntax cluster props add=typescriptDOMStorageMethod
    4              0.000006   hi def link typescriptDOMStorageMethod Keyword
                            
    4              0.000012   syntax keyword typescriptDOMFormProp contained acceptCharset action elements encoding
    4              0.000011   syntax keyword typescriptDOMFormProp contained enctype length method name target
    4              0.000015   syntax cluster props add=typescriptDOMFormProp
    4              0.000006   hi def link typescriptDOMFormProp Keyword
    4              0.000015   syntax keyword typescriptDOMFormMethod contained reportValidity reset submit nextgroup=typescriptFuncCallArg
    4              0.000015   syntax cluster props add=typescriptDOMFormMethod
    4              0.000006   hi def link typescriptDOMFormMethod Keyword
                            
    4              0.000010   syntax keyword typescriptDOMStyle contained alignContent alignItems alignSelf animation
    4              0.000009   syntax keyword typescriptDOMStyle contained animationDelay animationDirection animationDuration
    4              0.000008   syntax keyword typescriptDOMStyle contained animationFillMode animationIterationCount
    4              0.000009   syntax keyword typescriptDOMStyle contained animationName animationPlayState animationTimingFunction
    4              0.000009   syntax keyword typescriptDOMStyle contained appearance backfaceVisibility background
    4              0.000008   syntax keyword typescriptDOMStyle contained backgroundAttachment backgroundBlendMode
    4              0.000012   syntax keyword typescriptDOMStyle contained backgroundClip backgroundColor backgroundImage
    4              0.000009   syntax keyword typescriptDOMStyle contained backgroundOrigin backgroundPosition backgroundRepeat
    4              0.000009   syntax keyword typescriptDOMStyle contained backgroundSize border borderBottom borderBottomColor
    4              0.000007   syntax keyword typescriptDOMStyle contained borderBottomLeftRadius borderBottomRightRadius
    4              0.000009   syntax keyword typescriptDOMStyle contained borderBottomStyle borderBottomWidth borderCollapse
    4              0.000008   syntax keyword typescriptDOMStyle contained borderColor borderImage borderImageOutset
    4              0.000009   syntax keyword typescriptDOMStyle contained borderImageRepeat borderImageSlice borderImageSource
    4              0.000008   syntax keyword typescriptDOMStyle contained borderImageWidth borderLeft borderLeftColor
    4              0.000008   syntax keyword typescriptDOMStyle contained borderLeftStyle borderLeftWidth borderRadius
    4              0.000008   syntax keyword typescriptDOMStyle contained borderRight borderRightColor borderRightStyle
    4              0.000009   syntax keyword typescriptDOMStyle contained borderRightWidth borderSpacing borderStyle
    4              0.000008   syntax keyword typescriptDOMStyle contained borderTop borderTopColor borderTopLeftRadius
    4              0.000011   syntax keyword typescriptDOMStyle contained borderTopRightRadius borderTopStyle borderTopWidth
    4              0.000010   syntax keyword typescriptDOMStyle contained borderWidth bottom boxDecorationBreak
    4              0.000011   syntax keyword typescriptDOMStyle contained boxShadow boxSizing breakAfter breakBefore
    4              0.000010   syntax keyword typescriptDOMStyle contained breakInside captionSide caretColor caretShape
    4              0.000013   syntax keyword typescriptDOMStyle contained caret clear clip clipPath color columns
    4              0.000011   syntax keyword typescriptDOMStyle contained columnCount columnFill columnGap columnRule
    4              0.000010   syntax keyword typescriptDOMStyle contained columnRuleColor columnRuleStyle columnRuleWidth
    4              0.000011   syntax keyword typescriptDOMStyle contained columnSpan columnWidth content counterIncrement
    4              0.000011   syntax keyword typescriptDOMStyle contained counterReset cursor direction display
    4              0.000012   syntax keyword typescriptDOMStyle contained emptyCells flex flexBasis flexDirection
    4              0.000025   syntax keyword typescriptDOMStyle contained flexFlow flexGrow flexShrink flexWrap
    4              0.000011   syntax keyword typescriptDOMStyle contained float font fontFamily fontFeatureSettings
    4              0.000009   syntax keyword typescriptDOMStyle contained fontKerning fontLanguageOverride fontSize
    4              0.000010   syntax keyword typescriptDOMStyle contained fontSizeAdjust fontStretch fontStyle fontSynthesis
    4              0.000009   syntax keyword typescriptDOMStyle contained fontVariant fontVariantAlternates fontVariantCaps
    4              0.000008   syntax keyword typescriptDOMStyle contained fontVariantEastAsian fontVariantLigatures
    4              0.000008   syntax keyword typescriptDOMStyle contained fontVariantNumeric fontVariantPosition
    4              0.000011   syntax keyword typescriptDOMStyle contained fontWeight grad grid gridArea gridAutoColumns
    4              0.000009   syntax keyword typescriptDOMStyle contained gridAutoFlow gridAutoPosition gridAutoRows
    4              0.000009   syntax keyword typescriptDOMStyle contained gridColumn gridColumnStart gridColumnEnd
    4              0.000010   syntax keyword typescriptDOMStyle contained gridRow gridRowStart gridRowEnd gridTemplate
    4              0.000020   syntax keyword typescriptDOMStyle contained gridTemplateAreas gridTemplateRows gridTemplateColumns
    4              0.000012   syntax keyword typescriptDOMStyle contained height hyphens imageRendering imageResolution
    4              0.000014   syntax keyword typescriptDOMStyle contained imageOrientation imeMode inherit justifyContent
    4              0.000011   syntax keyword typescriptDOMStyle contained left letterSpacing lineBreak lineHeight
    4              0.000008   syntax keyword typescriptDOMStyle contained listStyle listStyleImage listStylePosition
    4              0.000010   syntax keyword typescriptDOMStyle contained listStyleType margin marginBottom marginLeft
    4              0.000011   syntax keyword typescriptDOMStyle contained marginRight marginTop marks mask maskType
    4              0.000010   syntax keyword typescriptDOMStyle contained maxHeight maxWidth minHeight minWidth
    4              0.000009   syntax keyword typescriptDOMStyle contained mixBlendMode objectFit objectPosition
    4              0.000012   syntax keyword typescriptDOMStyle contained opacity order orphans outline outlineColor
    4              0.000009   syntax keyword typescriptDOMStyle contained outlineOffset outlineStyle outlineWidth
    4              0.000014   syntax keyword typescriptDOMStyle contained overflow overflowWrap overflowX overflowY
    4              0.000009   syntax keyword typescriptDOMStyle contained overflowClipBox padding paddingBottom
    4              0.000009   syntax keyword typescriptDOMStyle contained paddingLeft paddingRight paddingTop pageBreakAfter
    4              0.000008   syntax keyword typescriptDOMStyle contained pageBreakBefore pageBreakInside perspective
    4              0.000008   syntax keyword typescriptDOMStyle contained perspectiveOrigin pointerEvents position
    4              0.000009   syntax keyword typescriptDOMStyle contained quotes resize right shapeImageThreshold
    4              0.000010   syntax keyword typescriptDOMStyle contained shapeMargin shapeOutside tableLayout tabSize
    4              0.000009   syntax keyword typescriptDOMStyle contained textAlign textAlignLast textCombineHorizontal
    4              0.000009   syntax keyword typescriptDOMStyle contained textDecoration textDecorationColor textDecorationLine
    4              0.000009   syntax keyword typescriptDOMStyle contained textDecorationStyle textIndent textOrientation
    4              0.000009   syntax keyword typescriptDOMStyle contained textOverflow textRendering textShadow
    4              0.000009   syntax keyword typescriptDOMStyle contained textTransform textUnderlinePosition top
    4              0.000009   syntax keyword typescriptDOMStyle contained touchAction transform transformOrigin
    4              0.000012   syntax keyword typescriptDOMStyle contained transformStyle transition transitionDelay
    4              0.000008   syntax keyword typescriptDOMStyle contained transitionDuration transitionProperty
    4              0.000010   syntax keyword typescriptDOMStyle contained transitionTimingFunction unicodeBidi unicodeRange
    4              0.000009   syntax keyword typescriptDOMStyle contained userSelect userZoom verticalAlign visibility
    4              0.000009   syntax keyword typescriptDOMStyle contained whiteSpace width willChange wordBreak
    4              0.000009   syntax keyword typescriptDOMStyle contained wordSpacing wordWrap writingMode zIndex
    4              0.000006   hi def link typescriptDOMStyle Keyword
                            
                            
                            
    4              0.000022   let typescript_props = 1
    4              0.000009   syntax keyword typescriptAnimationEvent contained animationend animationiteration
    4              0.000010   syntax keyword typescriptAnimationEvent contained animationstart beginEvent endEvent
    4              0.000007   syntax keyword typescriptAnimationEvent contained repeatEvent
    4              0.000011   syntax cluster events add=typescriptAnimationEvent
    4              0.000007   hi def link typescriptAnimationEvent Title
    4              0.000020   syntax keyword typescriptCSSEvent contained CssRuleViewRefreshed CssRuleViewChanged
    4              0.000009   syntax keyword typescriptCSSEvent contained CssRuleViewCSSLinkClicked transitionend
    4              0.000012   syntax cluster events add=typescriptCSSEvent
    4              0.000006   hi def link typescriptCSSEvent Title
    4              0.000013   syntax keyword typescriptDatabaseEvent contained blocked complete error success upgradeneeded
    4              0.000007   syntax keyword typescriptDatabaseEvent contained versionchange
    4              0.000012   syntax cluster events add=typescriptDatabaseEvent
    4              0.000006   hi def link typescriptDatabaseEvent Title
    4              0.000014   syntax keyword typescriptDocumentEvent contained DOMLinkAdded DOMLinkRemoved DOMMetaAdded
    4              0.000009   syntax keyword typescriptDocumentEvent contained DOMMetaRemoved DOMWillOpenModalDialog
    4              0.000009   syntax keyword typescriptDocumentEvent contained DOMModalDialogClosed unload
    4              0.000011   syntax cluster events add=typescriptDocumentEvent
    4              0.000006   hi def link typescriptDocumentEvent Title
    4              0.000009   syntax keyword typescriptDOMMutationEvent contained DOMAttributeNameChanged DOMAttrModified
    4              0.000009   syntax keyword typescriptDOMMutationEvent contained DOMCharacterDataModified DOMContentLoaded
    4              0.000008   syntax keyword typescriptDOMMutationEvent contained DOMElementNameChanged DOMNodeInserted
    4              0.000009   syntax keyword typescriptDOMMutationEvent contained DOMNodeInsertedIntoDocument DOMNodeRemoved
    4              0.000009   syntax keyword typescriptDOMMutationEvent contained DOMNodeRemovedFromDocument DOMSubtreeModified
    4              0.000011   syntax cluster events add=typescriptDOMMutationEvent
    4              0.000006   hi def link typescriptDOMMutationEvent Title
    4              0.000013   syntax keyword typescriptDragEvent contained drag dragdrop dragend dragenter dragexit
    4              0.000011   syntax keyword typescriptDragEvent contained draggesture dragleave dragover dragstart
    4              0.000008   syntax keyword typescriptDragEvent contained drop
    4              0.000011   syntax cluster events add=typescriptDragEvent
    4              0.000006   hi def link typescriptDragEvent Title
    4              0.000011   syntax keyword typescriptElementEvent contained invalid overflow underflow DOMAutoComplete
    4              0.000009   syntax keyword typescriptElementEvent contained command commandupdate
    4              0.000011   syntax cluster events add=typescriptElementEvent
    4              0.000006   hi def link typescriptElementEvent Title
    4              0.000018   syntax keyword typescriptFocusEvent contained blur change DOMFocusIn DOMFocusOut focus
    4              0.000009   syntax keyword typescriptFocusEvent contained focusin focusout
    4              0.000011   syntax cluster events add=typescriptFocusEvent
    4              0.000006   hi def link typescriptFocusEvent Title
    4              0.000009   syntax keyword typescriptFormEvent contained reset submit
    4              0.000012   syntax cluster events add=typescriptFormEvent
    4              0.000006   hi def link typescriptFormEvent Title
    4              0.000008   syntax keyword typescriptFrameEvent contained DOMFrameContentLoaded
    4              0.000011   syntax cluster events add=typescriptFrameEvent
    4              0.000006   hi def link typescriptFrameEvent Title
    4              0.000011   syntax keyword typescriptInputDeviceEvent contained click contextmenu DOMMouseScroll
    4              0.000010   syntax keyword typescriptInputDeviceEvent contained dblclick gamepadconnected gamepaddisconnected
    4              0.000011   syntax keyword typescriptInputDeviceEvent contained keydown keypress keyup MozGamepadButtonDown
    4              0.000013   syntax keyword typescriptInputDeviceEvent contained MozGamepadButtonUp mousedown mouseenter
    4              0.000010   syntax keyword typescriptInputDeviceEvent contained mouseleave mousemove mouseout
    4              0.000010   syntax keyword typescriptInputDeviceEvent contained mouseover mouseup mousewheel MozMousePixelScroll
    4              0.000009   syntax keyword typescriptInputDeviceEvent contained pointerlockchange pointerlockerror
    4              0.000007   syntax keyword typescriptInputDeviceEvent contained wheel
    4              0.000012   syntax cluster events add=typescriptInputDeviceEvent
    4              0.000006   hi def link typescriptInputDeviceEvent Title
    4              0.000010   syntax keyword typescriptMediaEvent contained audioprocess canplay canplaythrough
    4              0.000012   syntax keyword typescriptMediaEvent contained durationchange emptied ended ended loadeddata
    4              0.000009   syntax keyword typescriptMediaEvent contained loadedmetadata MozAudioAvailable pause
    4              0.000013   syntax keyword typescriptMediaEvent contained play playing ratechange seeked seeking
    4              0.000010   syntax keyword typescriptMediaEvent contained stalled suspend timeupdate volumechange
    4              0.000008   syntax keyword typescriptMediaEvent contained waiting complete
    4              0.000012   syntax cluster events add=typescriptMediaEvent
    4              0.000006   hi def link typescriptMediaEvent Title
    4              0.000009   syntax keyword typescriptMenuEvent contained DOMMenuItemActive DOMMenuItemInactive
    4              0.000011   syntax cluster events add=typescriptMenuEvent
    4              0.000016   hi def link typescriptMenuEvent Title
    4              0.000012   syntax keyword typescriptNetworkEvent contained datachange dataerror disabled enabled
    4              0.000012   syntax keyword typescriptNetworkEvent contained offline online statuschange connectionInfoUpdate
    4              0.000012   syntax cluster events add=typescriptNetworkEvent
    4              0.000006   hi def link typescriptNetworkEvent Title
    4              0.000012   syntax keyword typescriptProgressEvent contained abort error load loadend loadstart
    4              0.000009   syntax keyword typescriptProgressEvent contained progress timeout uploadprogress
    4              0.000012   syntax cluster events add=typescriptProgressEvent
    4              0.000006   hi def link typescriptProgressEvent Title
    4              0.000011   syntax keyword typescriptResourceEvent contained cached error load
    4              0.000012   syntax cluster events add=typescriptResourceEvent
    4              0.000006   hi def link typescriptResourceEvent Title
    4              0.000013   syntax keyword typescriptScriptEvent contained afterscriptexecute beforescriptexecute
    4              0.000013   syntax cluster events add=typescriptScriptEvent
    4              0.000006   hi def link typescriptScriptEvent Title
    4              0.000010   syntax keyword typescriptSensorEvent contained compassneedscalibration devicelight
    4              0.000010   syntax keyword typescriptSensorEvent contained devicemotion deviceorientation deviceproximity
    4              0.000009   syntax keyword typescriptSensorEvent contained orientationchange userproximity
    4              0.000012   syntax cluster events add=typescriptSensorEvent
    4              0.000006   hi def link typescriptSensorEvent Title
    4              0.000010   syntax keyword typescriptSessionHistoryEvent contained pagehide pageshow popstate
    4              0.000013   syntax cluster events add=typescriptSessionHistoryEvent
    4              0.000007   hi def link typescriptSessionHistoryEvent Title
    4              0.000009   syntax keyword typescriptStorageEvent contained change storage
    4              0.000012   syntax cluster events add=typescriptStorageEvent
    4              0.000006   hi def link typescriptStorageEvent Title
    4              0.000060   syntax keyword typescriptSVGEvent contained SVGAbort SVGError SVGLoad SVGResize SVGScroll
    4              0.000021   syntax keyword typescriptSVGEvent contained SVGUnload SVGZoom
    4              0.000025   syntax cluster events add=typescriptSVGEvent
    4              0.000006   hi def link typescriptSVGEvent Title
    4              0.000008   syntax keyword typescriptTabEvent contained visibilitychange
    4              0.000012   syntax cluster events add=typescriptTabEvent
    4              0.000006   hi def link typescriptTabEvent Title
    4              0.000011   syntax keyword typescriptTextEvent contained compositionend compositionstart compositionupdate
    4              0.000012   syntax keyword typescriptTextEvent contained copy cut paste select text
    4              0.000012   syntax cluster events add=typescriptTextEvent
    4              0.000005   hi def link typescriptTextEvent Title
    4              0.000011   syntax keyword typescriptTouchEvent contained touchcancel touchend touchenter touchleave
    4              0.000008   syntax keyword typescriptTouchEvent contained touchmove touchstart
    4              0.000012   syntax cluster events add=typescriptTouchEvent
    4              0.000006   hi def link typescriptTouchEvent Title
    4              0.000011   syntax keyword typescriptUpdateEvent contained checking downloading error noupdate
    4              0.000008   syntax keyword typescriptUpdateEvent contained obsolete updateready
    4              0.000012   syntax cluster events add=typescriptUpdateEvent
    4              0.000006   hi def link typescriptUpdateEvent Title
    4              0.000013   syntax keyword typescriptValueChangeEvent contained hashchange input readystatechange
    4              0.000013   syntax cluster events add=typescriptValueChangeEvent
    4              0.000006   hi def link typescriptValueChangeEvent Title
    4              0.000011   syntax keyword typescriptViewEvent contained fullscreen fullscreenchange fullscreenerror
    4              0.000009   syntax keyword typescriptViewEvent contained resize scroll
    4              0.000012   syntax cluster events add=typescriptViewEvent
    4              0.000006   hi def link typescriptViewEvent Title
    4              0.000011   syntax keyword typescriptWebsocketEvent contained close error message open
    4              0.000013   syntax cluster events add=typescriptWebsocketEvent
    4              0.000006   hi def link typescriptWebsocketEvent Title
    4              0.000010   syntax keyword typescriptWindowEvent contained DOMWindowCreated DOMWindowClose DOMTitleChanged
    4              0.000013   syntax cluster events add=typescriptWindowEvent
    4              0.000006   hi def link typescriptWindowEvent Title
    4              0.000011   syntax keyword typescriptUncategorizedEvent contained beforeunload message open show
    4              0.000013   syntax cluster events add=typescriptUncategorizedEvent
    4              0.000039   hi def link typescriptUncategorizedEvent Title
    4              0.000015   syntax keyword typescriptServiceWorkerEvent contained install activate fetch
    4              0.000015   syntax cluster events add=typescriptServiceWorkerEvent
    4              0.000006   hi def link typescriptServiceWorkerEvent Title
                            
                            
    4              0.000005 endif
                            
                            " patch
                            " patch for generated code
    4              0.000035 syntax keyword typescriptGlobal Promise
                              \ nextgroup=typescriptGlobalPromiseDot,typescriptFuncCallArg,typescriptTypeArguments oneline
    4              0.000045 syntax keyword typescriptGlobal Map WeakMap
                              \ nextgroup=typescriptGlobalPromiseDot,typescriptFuncCallArg,typescriptTypeArguments oneline
                            
    4              0.000021 syntax keyword typescriptConstructor           contained constructor
                              \ nextgroup=@typescriptCallSignature
                              \ skipwhite skipempty
                            
                            
    4              0.000024 syntax cluster memberNextGroup contains=typescriptMemberOptionality,typescriptTypeAnnotation,@typescriptCallSignature
                            
    4              0.000030 syntax match typescriptMember /#\?\K\k*/
                              \ nextgroup=@memberNextGroup
                              \ contained skipwhite
                            
    4              0.000027 syntax match typescriptMethodAccessor contained /\v(get|set)\s\K/me=e-1
                              \ nextgroup=@typescriptMembers
                            
    4              0.000044 syntax cluster typescriptPropertyMemberDeclaration contains=
                              \ typescriptClassStatic,
                              \ typescriptAccessibilityModifier,
                              \ typescriptReadonlyModifier,
                              \ typescriptMethodAccessor,
                              \ @typescriptMembers
                              " \ typescriptMemberVariableDeclaration
                            
    4              0.000027 syntax match typescriptMemberOptionality /?\|!/ contained
                              \ nextgroup=typescriptTypeAnnotation,@typescriptCallSignature
                              \ skipwhite skipempty
                            
    4              0.000021 syntax cluster typescriptMembers contains=typescriptMember,typescriptStringMember,typescriptComputedMember
                            
    4              0.000028 syntax keyword typescriptClassStatic static
                              \ nextgroup=@typescriptMembers,typescriptAsyncFuncKeyword,typescriptReadonlyModifier
                              \ skipwhite contained
                            
    4              0.000011 syntax keyword typescriptAccessibilityModifier public private protected contained
                            
    4              0.000008 syntax keyword typescriptReadonlyModifier readonly contained
                            
    4              0.000056 syntax region  typescriptStringMember   contained
                              \ start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1/
                              \ nextgroup=@memberNextGroup
                              \ skipwhite skipempty
                            
    4              0.000047 syntax region  typescriptComputedMember   contained matchgroup=typescriptProperty
                              \ start=/\[/rs=s+1 end=/]/
                              \ contains=@typescriptValue,typescriptMember,typescriptMappedIn
                              \ nextgroup=@memberNextGroup
                              \ skipwhite skipempty
                            
                            "don't add typescriptMembers to nextgroup, let outer scope match it
                            " so we won't match abstract method outside abstract class
    4              0.000021 syntax keyword typescriptAbstract              abstract
                              \ nextgroup=typescriptClassKeyword
                              \ skipwhite skipnl
    4              0.000026 syntax keyword typescriptClassKeyword          class
                              \ nextgroup=typescriptClassName,typescriptClassExtends,typescriptClassBlock
                              \ skipwhite
                            
    4              0.000028 syntax match   typescriptClassName             contained /\K\k*/
                              \ nextgroup=typescriptClassBlock,typescriptClassExtends,typescriptClassTypeParameter
                              \ skipwhite skipnl
                            
    4              0.000047 syntax region typescriptClassTypeParameter
                              \ start=/</ end=/>/
                              \ contains=@typescriptTypeParameterCluster
                              \ nextgroup=typescriptClassBlock,typescriptClassExtends
                              \ contained skipwhite skipnl
                            
    4              0.000016 syntax keyword typescriptClassExtends          contained extends implements nextgroup=typescriptClassHeritage skipwhite skipnl
                            
    4              0.000057 syntax match   typescriptClassHeritage         contained /\v(\k|\.|\(|\))+/
                              \ nextgroup=typescriptClassBlock,typescriptClassExtends,typescriptMixinComma,typescriptClassTypeArguments
                              \ contains=@typescriptValue
                              \ skipwhite skipnl
                              \ contained
                            
    4              0.000041 syntax region typescriptClassTypeArguments matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=@typescriptType
                              \ nextgroup=typescriptClassExtends,typescriptClassBlock,typescriptMixinComma
                              \ contained skipwhite skipnl
                            
    4              0.000014 syntax match typescriptMixinComma /,/ contained nextgroup=typescriptClassHeritage skipwhite skipnl
                            
                            " we need add arrowFunc to class block for high order arrow func
                            " see test case
    4              0.000177 syntax region  typescriptClassBlock matchgroup=typescriptBraces start=/{/ end=/}/
                              \ contains=@typescriptPropertyMemberDeclaration,typescriptAbstract,@typescriptComments,typescriptBlock,typescriptAssign,typescriptDecorator,typescriptAsyncFuncKeyword,typescriptArrowFunc
                              \ contained fold
                            
    4              0.000016 syntax keyword typescriptInterfaceKeyword          interface nextgroup=typescriptInterfaceName skipwhite
    4              0.000030 syntax match   typescriptInterfaceName             contained /\k\+/
                              \ nextgroup=typescriptObjectType,typescriptInterfaceExtends,typescriptInterfaceTypeParameter
                              \ skipwhite skipnl
    4              0.000038 syntax region typescriptInterfaceTypeParameter
                              \ start=/</ end=/>/
                              \ contains=@typescriptTypeParameterCluster
                              \ nextgroup=typescriptObjectType,typescriptInterfaceExtends
                              \ contained
                              \ skipwhite skipnl
                            
    4              0.000015 syntax keyword typescriptInterfaceExtends          contained extends nextgroup=typescriptInterfaceHeritage skipwhite skipnl
                            
    4              0.000036 syntax match typescriptInterfaceHeritage contained /\v(\k|\.)+/
                              \ nextgroup=typescriptObjectType,typescriptInterfaceComma,typescriptInterfaceTypeArguments
                              \ skipwhite
                            
    4              0.000050 syntax region typescriptInterfaceTypeArguments matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/ skip=/\s*,\s*/
                              \ contains=@typescriptType
                              \ nextgroup=typescriptObjectType,typescriptInterfaceComma
                              \ contained skipwhite
                            
    4              0.000014 syntax match typescriptInterfaceComma /,/ contained nextgroup=typescriptInterfaceHeritage skipwhite skipnl
                            
                            "Block VariableStatement EmptyStatement ExpressionStatement IfStatement IterationStatement ContinueStatement BreakStatement ReturnStatement WithStatement LabelledStatement SwitchStatement ThrowStatement TryStatement DebuggerStatement
    4              0.000102 syntax cluster typescriptStatement
                              \ contains=typescriptBlock,typescriptVariable,
                              \ @typescriptTopExpression,typescriptAssign,
                              \ typescriptConditional,typescriptRepeat,typescriptBranch,
                              \ typescriptLabel,typescriptStatementKeyword,
                              \ typescriptFuncKeyword,
                              \ typescriptTry,typescriptExceptions,typescriptDebugger,
                              \ typescriptExport,typescriptInterfaceKeyword,typescriptEnum,
                              \ typescriptModule,typescriptAliasKeyword,typescriptImport
                            
    4              0.000032 syntax cluster typescriptPrimitive  contains=typescriptString,typescriptTemplate,typescriptRegexpString,typescriptNumber,typescriptBoolean,typescriptNull,typescriptArray
                            
    4              0.000025 syntax cluster typescriptEventTypes            contains=typescriptEventString,typescriptTemplate,typescriptNumber,typescriptBoolean,typescriptNull
                            
                            " top level expression: no arrow func
                            " also no func keyword. funcKeyword is contained in statement
                            " funcKeyword allows overloading (func without body)
                            " funcImpl requires body
    4              0.000059 syntax cluster typescriptTopExpression
                              \ contains=@typescriptPrimitive,
                              \ typescriptIdentifier,typescriptIdentifierName,
                              \ typescriptOperator,typescriptUnaryOp,
                              \ typescriptParenExp,typescriptRegexpString,
                              \ typescriptGlobal,typescriptAsyncFuncKeyword,
                              \ typescriptClassKeyword,typescriptTypeCast
                            
                            " no object literal, used in type cast and arrow func
                            " TODO: change func keyword to funcImpl
    4              0.000022 syntax cluster typescriptExpression
                              \ contains=@typescriptTopExpression,
                              \ typescriptArrowFuncDef,
                              \ typescriptFuncImpl
                            
    4              0.000017 syntax cluster typescriptValue
                              \ contains=@typescriptExpression,typescriptObjectLiteral
                            
    4              0.000036 syntax cluster typescriptEventExpression       contains=typescriptArrowFuncDef,typescriptParenExp,@typescriptValue,typescriptRegexpString,@typescriptEventTypes,typescriptOperator,typescriptGlobal,jsxRegion
                            
    4              0.000021 syntax keyword typescriptAsyncFuncKeyword      async
                              \ nextgroup=typescriptFuncKeyword,typescriptArrowFuncDef
                              \ skipwhite
                            
    4              0.000016 syntax keyword typescriptAsyncFuncKeyword      await
                              \ nextgroup=@typescriptValue
                              \ skipwhite
                            
    4              0.000026 syntax keyword typescriptFuncKeyword           function
                              \ nextgroup=typescriptAsyncFunc,typescriptFuncName,@typescriptCallSignature
                              \ skipwhite skipempty
                            
    4              0.000020 syntax match   typescriptAsyncFunc             contained /*/
                              \ nextgroup=typescriptFuncName,@typescriptCallSignature
                              \ skipwhite skipempty
                            
    4              0.000020 syntax match   typescriptFuncName              contained /\K\k*/
                              \ nextgroup=@typescriptCallSignature
                              \ skipwhite
                            
                            " destructuring ({ a: ee }) =>
    4              0.000060 syntax match   typescriptArrowFuncDef          contained /(\(\s*\({\_[^}]*}\|\k\+\)\(:\_[^)]\)\?,\?\)\+)\s*=>/
                              \ contains=typescriptArrowFuncArg,typescriptArrowFunc
                              \ nextgroup=@typescriptExpression,typescriptBlock
                              \ skipwhite skipempty
                            
                            " matches `(a) =>` or `([a]) =>` or
                            " `(
                            "  a) =>`
    4              0.000046 syntax match   typescriptArrowFuncDef          contained /(\(\_s*[a-zA-Z\$_\[.]\_[^)]*\)*)\s*=>/
                              \ contains=typescriptArrowFuncArg,typescriptArrowFunc
                              \ nextgroup=@typescriptExpression,typescriptBlock
                              \ skipwhite skipempty
                            
    4              0.000031 syntax match   typescriptArrowFuncDef          contained /\K\k*\s*=>/
                              \ contains=typescriptArrowFuncArg,typescriptArrowFunc
                              \ nextgroup=@typescriptExpression,typescriptBlock
                              \ skipwhite skipempty
                            
                            " TODO: optimize this pattern
    4              0.000050 syntax region   typescriptArrowFuncDef          contained start=/(\_[^(^)]*):/ end=/=>/
                              \ contains=typescriptArrowFuncArg,typescriptArrowFunc,typescriptTypeAnnotation
                              \ nextgroup=@typescriptExpression,typescriptBlock
                              \ skipwhite skipempty keepend
                            
    4              0.000013 syntax match   typescriptArrowFunc             /=>/
    4              0.000011 syntax match   typescriptArrowFuncArg          contained /\K\k*/
    4              0.000027 syntax region  typescriptArrowFuncArg          contained start=/<\|(/ end=/\ze=>/ contains=@typescriptCallSignature
                            
    4              0.000024 syntax region typescriptReturnAnnotation contained start=/:/ end=/{/me=e-1 contains=@typescriptType nextgroup=typescriptBlock
                            
                            
    4              0.000041 syntax region typescriptFuncImpl contained start=/function\>/ end=/{/me=e-1
                              \ contains=typescriptFuncKeyword
                              \ nextgroup=typescriptBlock
                            
    4              0.000016 syntax cluster typescriptCallImpl contains=typescriptGenericImpl,typescriptParamImpl
    4              0.000038 syntax region typescriptGenericImpl matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/ skip=/\s*,\s*/
                              \ contains=typescriptTypeParameter
                              \ nextgroup=typescriptParamImpl
                              \ contained skipwhite
    4              0.000047 syntax region typescriptParamImpl matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=typescriptDecorator,@typescriptParameterList,@typescriptComments
                              \ nextgroup=typescriptReturnAnnotation,typescriptBlock
                              \ contained skipwhite skipnl
                            
    4              0.000048 syntax match typescriptDecorator /@\([_$a-zA-Z][_$a-zA-Z0-9]*\.\)*[_$a-zA-Z][_$a-zA-Z0-9]*\>/
                              \ nextgroup=typescriptFuncCallArg,typescriptTypeArguments
                              \ contains=@_semantic,typescriptDotNotation
                            
                            " Define the default highlighting.
    4              0.000010 hi def link typescriptReserved             Error
                            
    4              0.000008 hi def link typescriptEndColons            Exception
    4              0.000010 hi def link typescriptSymbols              Normal
    4              0.000007 hi def link typescriptBraces               Function
    4              0.000006 hi def link typescriptParens               Normal
    4              0.000006 hi def link typescriptComment              Comment
    4              0.000007 hi def link typescriptLineComment          Comment
    4              0.000006 hi def link typescriptDocComment           Comment
    4              0.000007 hi def link typescriptCommentTodo          Todo
    4              0.000007 hi def link typescriptMagicComment         SpecialComment
    4              0.000006 hi def link typescriptRef                  Include
    4              0.000033 hi def link typescriptDocNotation          SpecialComment
    4              0.000006 hi def link typescriptDocTags              SpecialComment
    4              0.000007 hi def link typescriptDocNGParam           typescriptDocParam
    4              0.000006 hi def link typescriptDocParam             Function
    4              0.000005 hi def link typescriptDocNumParam          Function
    4              0.000005 hi def link typescriptDocEventRef          Function
    4              0.000006 hi def link typescriptDocNamedParamType    Type
    4              0.000006 hi def link typescriptDocParamName         Type
    4              0.000005 hi def link typescriptDocParamType         Type
    4              0.000005 hi def link typescriptString               String
    4              0.000006 hi def link typescriptSpecial              Special
    4              0.000006 hi def link typescriptStringLiteralType    String
    4              0.000005 hi def link typescriptTemplateLiteralType  String
    4              0.000005 hi def link typescriptStringMember         String
    4              0.000021 hi def link typescriptTemplate             String
    4              0.000005 hi def link typescriptEventString          String
    4              0.000005 hi def link typescriptDestructureString    String
    4              0.000005 hi def link typescriptASCII                Special
    4              0.000053 hi def link typescriptTemplateSB           Label
    4              0.000009 hi def link typescriptRegexpString         String
    4              0.000006 hi def link typescriptGlobal               Constant
    4              0.000006 hi def link typescriptTestGlobal           Function
    4              0.000006 hi def link typescriptPrototype            Type
    4              0.000006 hi def link typescriptConditional          Conditional
    4              0.000006 hi def link typescriptConditionalElse      Conditional
    4              0.000007 hi def link typescriptCase                 Conditional
    4              0.000006 hi def link typescriptDefault              typescriptCase
    4              0.000005 hi def link typescriptBranch               Conditional
    4              0.000006 hi def link typescriptIdentifier           Structure
    4              0.000006 hi def link typescriptVariable             Identifier
    4              0.000006 hi def link typescriptDestructureVariable  PreProc
    4              0.000006 hi def link typescriptEnumKeyword          Identifier
    4              0.000005 hi def link typescriptRepeat               Repeat
    4              0.000006 hi def link typescriptForOperator          Repeat
    4              0.000006 hi def link typescriptStatementKeyword     Statement
    4              0.000005 hi def link typescriptMessage              Keyword
    4              0.000006 hi def link typescriptOperator             Identifier
    4              0.000017 hi def link typescriptKeywordOp            Identifier
    4              0.000006 hi def link typescriptCastKeyword          Special
    4              0.000006 hi def link typescriptType                 Type
    4              0.000006 hi def link typescriptNull                 Boolean
    4              0.000006 hi def link typescriptNumber               Number
    4              0.000006 hi def link typescriptBoolean              Boolean
    4              0.000007 hi def link typescriptObjectLabel          typescriptLabel
    4              0.000006 hi def link typescriptDestructureLabel     Function
    4              0.000006 hi def link typescriptLabel                Label
    4              0.000006 hi def link typescriptTupleLable           Label
    4              0.000006 hi def link typescriptStringProperty       String
    4              0.000006 hi def link typescriptImport               Special
    4              0.000006 hi def link typescriptImportType           Special
    4              0.000006 hi def link typescriptAmbientDeclaration   Special
    4              0.000006 hi def link typescriptExport               Special
    4              0.000006 hi def link typescriptExportType           Special
    4              0.000006 hi def link typescriptModule               Special
    4              0.000006 hi def link typescriptTry                  Special
    4              0.000006 hi def link typescriptExceptions           Special
                            
    4              0.000006 hi def link typescriptMember              Function
    4              0.000006 hi def link typescriptMethodAccessor       Operator
                            
    4              0.000006 hi def link typescriptAsyncFuncKeyword     Keyword
    4              0.000006 hi def link typescriptObjectAsyncKeyword   Keyword
    4              0.000006 hi def link typescriptAsyncFor             Keyword
    4              0.000006 hi def link typescriptFuncKeyword          Keyword
    4              0.000006 hi def link typescriptAsyncFunc            Keyword
    4              0.000006 hi def link typescriptArrowFunc            Type
    4              0.000006 hi def link typescriptFuncName             Function
    4              0.000006 hi def link typescriptFuncArg              PreProc
    4              0.000006 hi def link typescriptArrowFuncArg         PreProc
    4              0.000007 hi def link typescriptFuncComma            Operator
                            
    4              0.000006 hi def link typescriptClassKeyword         Keyword
    4              0.000006 hi def link typescriptClassExtends         Keyword
                            " hi def link typescriptClassName            Function
    4              0.000006 hi def link typescriptAbstract             Special
                            " hi def link typescriptClassHeritage        Function
                            " hi def link typescriptInterfaceHeritage    Function
    4              0.000006 hi def link typescriptClassStatic          StorageClass
    4              0.000006 hi def link typescriptReadonlyModifier     Keyword
    4              0.000006 hi def link typescriptInterfaceKeyword     Keyword
    4              0.000006 hi def link typescriptInterfaceExtends     Keyword
    4              0.000006 hi def link typescriptInterfaceName        Function
                            
    4              0.000006 hi def link shellbang                      Comment
                            
    4              0.000006 hi def link typescriptTypeParameter         Identifier
    4              0.000006 hi def link typescriptConstraint            Keyword
    4              0.000006 hi def link typescriptPredefinedType        Type
    4              0.000006 hi def link typescriptReadonlyArrayKeyword  Keyword
    4              0.000007 hi def link typescriptUnion                 Operator
    4              0.000007 hi def link typescriptFuncTypeArrow         Function
    4              0.000007 hi def link typescriptConstructorType       Function
    4              0.000006 hi def link typescriptTypeQuery             Keyword
    4              0.000006 hi def link typescriptAccessibilityModifier Keyword
    4              0.000006 hi def link typescriptOptionalMark          PreProc
    4              0.000006 hi def link typescriptFuncType              Special
    4              0.000006 hi def link typescriptMappedIn              Special
    4              0.000006 hi def link typescriptCall                  PreProc
    4              0.000006 hi def link typescriptParamImpl             PreProc
    4              0.000007 hi def link typescriptConstructSignature    Identifier
    4              0.000006 hi def link typescriptAliasDeclaration      Identifier
    4              0.000006 hi def link typescriptAliasKeyword          Keyword
    4              0.000007 hi def link typescriptUserDefinedType       Keyword
    4              0.000006 hi def link typescriptTypeReference         Identifier
    4              0.000006 hi def link typescriptConstructor           Keyword
    4              0.000006 hi def link typescriptDecorator             Special
    4              0.000006 hi def link typescriptAssertType            Keyword
                            
    4              0.000006 hi link typeScript             NONE
                            
    4              0.000027 if exists('s:cpo_save')
    4   0.000078   0.000061   let &cpo = s:cpo_save
    4              0.000012   unlet s:cpo_save
    4              0.000012 endif

SCRIPT  /Users/elanmedoff/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/task.vim
Sourced 1 time
Total time:   0.000136
 Self time:   0.000136

count  total (s)   self (s)
                            " ============================================================================
                            " Description: Manage long running tasks.
                            " Author: Qiming Zhao <chemzqm@gmail.com>
                            " Licence: Anti 966 licence
                            " Version: 0.1
                            " Last Modified:  Dec 12, 2020
                            " ============================================================================
    1              0.000003 scriptencoding utf-8
                            
    1              0.000010 let s:is_vim = !has('nvim')
    1              0.000002 let s:running_task = {}
                            " neovim emit strings that part of lines.
    1              0.000001 let s:out_remain_text = {}
    1              0.000003 let s:err_remain_text = {}
                            
    1              0.000003 function! coc#task#start(id, opts)
                              if coc#task#running(a:id)
                                call coc#task#stop(a:id)
                              endif
                              let cmd = [a:opts['cmd']] + get(a:opts, 'args', [])
                              let cwd = get(a:opts, 'cwd', getcwd())
                              let env = get(a:opts, 'env', {})
                              " cmd args cwd pty
                              if s:is_vim
                                let options = {
                                      \ 'cwd': cwd,
                                      \ 'err_mode': 'nl',
                                      \ 'out_mode': 'nl',
                                      \ 'err_cb': {channel, message -> s:on_stderr(a:id, [message])},
                                      \ 'out_cb': {channel, message -> s:on_stdout(a:id, [message])},
                                      \ 'exit_cb': {channel, code -> s:on_exit(a:id, code)},
                                      \ 'env': env,
                                      \}
                                if has("patch-8.1.350")
                                  let options['noblock'] = 1
                                endif
                                if get(a:opts, 'pty', 0)
                                  let options['pty'] = 1
                                endif
                                let job = job_start(cmd, options)
                                let status = job_status(job)
                                if status !=# 'run'
                                  echohl Error | echom 'Failed to start '.a:id.' task' | echohl None
                                  return v:false
                                endif
                                let s:running_task[a:id] = job
                              else
                                let options = {
                                      \ 'cwd': cwd,
                                      \ 'on_stderr': {channel, msgs -> s:on_stderr(a:id, msgs)},
                                      \ 'on_stdout': {channel, msgs -> s:on_stdout(a:id, msgs)},
                                      \ 'on_exit': {channel, code -> s:on_exit(a:id, code)},
                                      \ 'detach': get(a:opts, 'detach', 0),
                                      \}
                                let original = {}
                                if !empty(env)
                                  if has('nvim-0.5.0')
                                    let options['env'] = env
                                  elseif exists('*setenv') && exists('*getenv')
                                    for key in keys(env)
                                      let original[key] = getenv(key)
                                      call setenv(key, env[key])
                                    endfor
                                  endif
                                endif
                                if get(a:opts, 'pty', 0)
                                  let options['pty'] = 1
                                endif
                                let chan_id = jobstart(cmd, options)
                                if !empty(original)
                                  for key in keys(original)
                                    call setenv(key, original[key])
                                  endfor
                                endif
                                if chan_id <= 0
                                  echohl Error | echom 'Failed to start '.a:id.' task' | echohl None
                                  return v:false
                                endif
                                let s:running_task[a:id] = chan_id
                              endif
                              return v:true
                            endfunction
                            
    1              0.000002 function! coc#task#stop(id)
                              let job = get(s:running_task, a:id, v:null)
                              if !job | return | endif
                              if s:is_vim
                                call job_stop(job, 'term')
                              else
                                call jobstop(job)
                              endif
                              sleep 50m
                              let running = coc#task#running(a:id)
                              if running
                                echohl Error | echom 'job '.a:id. ' stop failed.' | echohl None
                              endif
                            endfunction
                            
    1              0.000002 function! s:on_exit(id, code) abort
                              if get(g:, 'coc_vim_leaving', 0) | return | endif
                              if has('nvim')
                                let s:out_remain_text[a:id] = ''
                                let s:err_remain_text[a:id] = ''
                              endif
                              if has_key(s:running_task, a:id)
                                call remove(s:running_task, a:id)
                              endif
                              call coc#rpc#notify('TaskExit', [a:id, a:code])
                            endfunction
                            
    1              0.000001 function! s:on_stderr(id, msgs)
                              if get(g:, 'coc_vim_leaving', 0) | return | endif
                              if empty(a:msgs)
                                return
                              endif
                              if s:is_vim
                                call coc#rpc#notify('TaskStderr', [a:id, a:msgs])
                              else
                                let remain = get(s:err_remain_text, a:id, '')
                                let eof = (a:msgs == [''])
                                let msgs = copy(a:msgs)
                                if len(remain) > 0
                                  if msgs[0] == ''
                                    let msgs[0] = remain
                                  else
                                    let msgs[0] = remain . msgs[0]
                                  endif
                                endif
                                let last = msgs[len(msgs) - 1]
                                let s:err_remain_text[a:id] = len(last) > 0 ? last : ''
                                " all lines from 0 to n - 2
                                if len(msgs) > 1
                                  call coc#rpc#notify('TaskStderr', [a:id, msgs[:len(msgs)-2]])
                                elseif eof && len(msgs[0]) > 0
                                  call coc#rpc#notify('TaskStderr', [a:id, msgs])
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! s:on_stdout(id, msgs)
                              if empty(a:msgs)
                                return
                              endif
                              if s:is_vim
                                call coc#rpc#notify('TaskStdout', [a:id, a:msgs])
                              else
                                let remain = get(s:out_remain_text, a:id, '')
                                let eof = (a:msgs == [''])
                                let msgs = copy(a:msgs)
                                if len(remain) > 0
                                  if msgs[0] == ''
                                    let msgs[0] = remain
                                  else
                                    let msgs[0] = remain . msgs[0]
                                  endif
                                endif
                                let last = msgs[len(msgs) - 1]
                                let s:out_remain_text[a:id] = len(last) > 0 ? last : ''
                                " all lines from 0 to n - 2
                                if len(msgs) > 1
                                  call coc#rpc#notify('TaskStdout', [a:id, msgs[:len(msgs)-2]])
                                elseif eof && len(msgs[0]) > 0
                                  call coc#rpc#notify('TaskStdout', [a:id, msgs])
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! coc#task#running(id)
                              if !has_key(s:running_task, a:id) == 1
                                return v:false
                              endif
                              let job = s:running_task[a:id]
                              if s:is_vim
                                let status = job_status(job)
                                return status ==# 'run'
                              endif
                              let [code] = jobwait([job], 10)
                              return code == -1
                            endfunction

SCRIPT  /Users/elanmedoff/.local/share/nvim/site/pack/packer/start/vim-smoothie/autoload/smoothie.vim
Sourced 1 time
Total time:   0.000430
 Self time:   0.000415

count  total (s)   self (s)
    1              0.000011 function! s:editor_supports_fast_redraw() abort
                              " Currently enabled only for Neovim, because it causes screen flickering on
                              " regular Vim.
                              return has('nvim')
                            endfunction
                            
    1              0.000003 function! s:terminal_supports_fast_redraw() abort
                              " Currently only Kitty is known not to cause any flickering when calling
                              " `:mode`.
                              return $TERM ==# 'xterm-kitty'
                            endfunction
                            
                            ""
                            " Note: the configuration options mentioned there are intentionally hidden
                            " from the user, since they're not guaranteed to be backward-compatible with
                            " future releases of the plugin. Change them at your own risk!
                            
    1              0.000011 if !exists('g:smoothie_update_interval')
                              ""
                              " Time (in milliseconds) between subsequent screen/cursor position updates.
                              " Lower value produces smoother animation.  Might be useful to increase it
                              " when running Vim over low-bandwidth/high-latency connections.
    1              0.000006   let g:smoothie_update_interval = 20
    1              0.000002 endif
                            
    1              0.000004 if !exists('g:smoothie_speed_constant_factor')
                              ""
                              " This value controls constant term of the velocity curve. Increasing this
                              " boosts primarily cursor speed at the end of animation.
    1              0.000003   let g:smoothie_speed_constant_factor = 10
    1              0.000001 endif
                            
    1              0.000003 if !exists('g:smoothie_speed_linear_factor')
                              ""
                              " This value controls linear term of the velocity curve. Increasing this
                              " boosts primarily cursor speed at the beginning of animation.
    1              0.000002   let g:smoothie_speed_linear_factor = 10
    1              0.000001 endif
                            
    1              0.000004 if !exists('g:smoothie_speed_exponentiation_factor')
                              ""
                              " This value controls exponent of the power function in the velocity curve.
                              " Generally should be less or equal to 1.0. Lower values produce longer but
                              " perceivably smoother animation.
    1              0.000004   let g:smoothie_speed_exponentiation_factor = 0.9
    1              0.000001 endif
                            
    1              0.000003 if !exists('g:smoothie_redraw_at_finish')
                              ""
                              " Force screen redraw when the animation is finished, which clears sporadic
                              " display artifacts which I encountered f.ex. when scrolling through buffers
                              " containing emoji. Enabled by default only if both editor and terminal
                              " supports doing this in a glitch-free way.
    1   0.000040   0.000025   let g:smoothie_redraw_at_finish = s:editor_supports_fast_redraw() && s:terminal_supports_fast_redraw()
    1              0.000001 endif
                            
    1              0.000004 let s:target_view = {}
                            
    1              0.000002 let s:subline_progress_view = {}
                            
    1              0.000003 let s:animated_view_elements = ['lnum', 'topline']
                            
                            ""
                            " Start the animation timer if not already running.  Should be called when
                            " updating the target, when there's a chance we're not already moving.
    1              0.000003 function! s:start_moving() abort
                              call s:ensure_subline_progress_view_initialized()
                              if !exists('s:timer_id')
                                let s:timer_id = timer_start(g:smoothie_update_interval, function('s:animation_tick'), {'repeat': -1})
                                let s:last_tick_time = reltime()
                              endif
                            endfunction
                            
    1              0.000002 function! s:ensure_subline_progress_view_initialized() abort
                              if empty(s:subline_progress_view)
                                for key in s:animated_view_elements
                                  let s:subline_progress_view[key] = 0.0
                                endfor
                              endif
                            endfunction
                            
                            ""
                            " Ensure the window and the cursor is positioned at their final destinations,
                            " and disable the animation timer to conserve power.
    1              0.000002 function! s:finish_moving() abort
                              call winrestview(s:target_view)
                              if g:smoothie_redraw_at_finish
                                mode
                              endif
                              let s:target_view = {}
                              let s:subline_progress_view = {}
                              if exists('s:timer_id')
                                call timer_stop(s:timer_id)
                                unlet s:timer_id
                              endif
                            endfunction
                            
                            ""
                            " Skip animation and jump to target position immediately if we're moving and
                            " the user is about to leave the window or switch to a different buffer.
    1              0.000002 function! s:handle_leave_event() abort
                              if !empty(s:target_view)
                                call s:finish_moving()
                              endif
                            endfunction
                            
    1              0.000018 augroup smoothie_leave_handlers
    1              0.000016   autocmd!
    1              0.000012   autocmd WinLeave,BufLeave * call s:handle_leave_event()
    1              0.000001 augroup end
                            
                            ""
                            " TODO: current algorithm is rather crude, would be good to research better
                            " alternatives.
    1              0.000003 function! s:compute_velocity_element(target_distance_element) abort
                              let l:absolute_speed = g:smoothie_speed_constant_factor + g:smoothie_speed_linear_factor * pow(abs(a:target_distance_element), g:smoothie_speed_exponentiation_factor)
                              if a:target_distance_element < 0
                                return -l:absolute_speed
                              else
                                return l:absolute_speed
                              endif
                            endfunction
                            
    1              0.000002 function! s:compute_target_distance() abort
                              let l:result = {}
                              for [key, value] in items(s:filter_dict(winsaveview(), s:animated_view_elements))
                                let l:result[key] = s:target_view[key] - value - s:subline_progress_view[key]
                              endfor
                              return l:result
                            endfunction
                            
    1              0.000002 function! s:compute_velocity(target_distance) abort
                              let l:result = {}
                              for [key, value] in items(a:target_distance)
                                let l:result[key] = s:compute_velocity_element(value)
                              endfor
                              return l:result
                            endfunction
                            
    1              0.000002 function! s:compute_animation_step(target_distance, step_duration) abort
                              let l:result = {}
                              for [key, value] in items(s:compute_velocity(a:target_distance))
                                let l:result[key] = value * a:step_duration
                                if abs(l:result[key]) > abs(a:target_distance[key])
                                  " clamp step size to prevent overshooting the target
                                  let l:result[key] = a:target_distance[key]
                                end
                              endfor
                              return l:result
                            endfunction
                            
    1              0.000003 function! s:filter_dict(source, persisted_keys) abort
                              let l:result = {}
                              for key in a:persisted_keys
                                let l:result[key] = a:source[key]
                              endfor
                              return result
                            endfunction
                            
                            ""
                            " Equivalent to winrestview(), but tries to avoid actually calling
                            " winrestview() and tries to restore the view using normal mode commands if
                            " possible.  This improves redraw smoothness and minimises glitches,
                            " especially on slow terminals.
    1              0.000002 function! s:winrestview_optimized(new_view) abort
                              for key in ['topline', 'lnum']
                                let l:distance = a:new_view[key] - winsaveview()[key]
                                if l:distance == 0
                                  continue
                                endif
                                if key ==# 'topline'
                                  if l:distance > 0
                                    execute 'normal! ' . l:distance . "\<C-E>"
                                  else
                                    execute 'normal! ' . -l:distance . "\<C-Y>"
                                  endif
                                elseif key ==# 'lnum'
                                  if l:distance > 0
                                    execute 'normal! ' . l:distance . 'j'
                                  else
                                    execute 'normal! ' . -l:distance . 'k'
                                  endif
                                endif
                              endfor
                              let l:view_after_optimization = s:filter_dict(winsaveview(), keys(a:new_view))
                              let l:remaining_view_changes = {}
                              for [key, value] in items(view_after_optimization)
                                if a:new_view[key] != value
                                  let l:remaining_view_changes[key] = a:new_view[key]
                                endif
                              endfor
                              if !empty(l:remaining_view_changes)
                                call winrestview(l:remaining_view_changes)
                              endif
                            endfunction
                            
                            ""
                            " Stop moving and jump to target immediately if we detect the animation is
                            " stuck. This is a workaround to partially mitigate
                            " https://github.com/psliwka/vim-smoothie/issues/40
    1              0.000003 function! s:abort_if_stuck(desired_new_position) abort
                              let l:current_position = s:filter_dict(winsaveview(), s:animated_view_elements)
                              for key in s:animated_view_elements
                                if l:current_position[key] != a:desired_new_position[key]
                                  call s:finish_moving()
                                endif
                              endfor
                            endfunction
                            
    1              0.000003 function! s:perform_animation_step(step_duration) abort
                              let l:target_distance = s:compute_target_distance()
                              let l:new_position = s:filter_dict(winsaveview(), s:animated_view_elements)
                              let l:animation_step = s:compute_animation_step(l:target_distance, a:step_duration)
                              let l:finished_moving = v:true
                              for [key, value] in items(l:animation_step)
                                if l:new_position[key] == s:target_view[key]
                                  continue
                                else
                                  let l:finished_moving = v:false
                                endif
                                let l:integer_step_size = float2nr(trunc(value+s:subline_progress_view[key]))
                                if l:integer_step_size != 0
                                  let l:new_position[key] = l:new_position[key] + l:integer_step_size
                                endif
                                let s:subline_progress_view[key] += value - l:integer_step_size
                              endfor
                              call s:winrestview_optimized(l:new_position)
                              call s:abort_if_stuck(l:new_position)
                              return l:finished_moving
                            endfunction
                            
                            ""
                            " Execute single animation frame.  Called periodically by a timer.  Accepts a
                            " throwaway parameter: the timer ID.
    1              0.000002 function! s:animation_tick(_) abort
                              let l:current_step_duration = reltimefloat(reltime(s:last_tick_time))
                              let s:last_tick_time = reltime()
                              let l:finished_moving = s:perform_animation_step(l:current_step_duration)
                              if l:finished_moving
                                call s:finish_moving()
                              endif
                            endfunction
                            
    1              0.000007 function! s:update_target(command, count) abort
                              let l:current_view = winsaveview()
                              if !empty(s:target_view)
                                call winrestview(s:target_view)
                              endif
                              execute 'normal! ' . a:count . a:command
                              let s:target_view = winsaveview()
                              call winrestview(l:current_view)
                            endfunction
                            
    1              0.000002 function! smoothie#do(command) abort
                              if v:count == 0
                                let l:count = ''
                              else
                                let l:count = v:count
                              endif
                              if g:smoothie_enabled
                                call s:update_target(a:command, l:count)
                                call s:start_moving()
                              else
                                execute 'normal! ' . l:count . a:command
                              endif
                            endfunction
                            
                            ""
                            " Old interface kept for backward compatibility with legacy configurations
    1              0.000002 function! smoothie#downwards() abort
                              call smoothie#do("\<C-D>")
                            endfunction
    1              0.000001 function! smoothie#upwards() abort
                              call smoothie#do("\<C-U>")
                            endfunction
    1              0.000001 function! smoothie#forwards() abort
                              call smoothie#do("\<C-F>")
                            endfunction
    1              0.000001 function! smoothie#backwards() abort
                              call smoothie#do("\<C-B>")
                            endfunction
                            
                            " vim: et ts=2

SCRIPT  /Users/elanmedoff/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/dialog.vim
Sourced 1 time
Total time:   0.001611
 Self time:   0.001611

count  total (s)   self (s)
    1              0.000011 scriptencoding utf-8
    1              0.000018 let s:is_vim = !has('nvim')
    1              0.000010 let s:root = expand('<sfile>:h:h:h')
    1              0.000005 let s:prompt_win_bufnr = 0
    1              0.000002 let s:list_win_bufnr = 0
    1              0.000006 let s:prompt_win_width = get(g:, 'coc_prompt_win_width', 32)
    1              0.000006 let s:frames = ['·  ', '·· ', '···', ' ··', '  ·', '   ']
    1              0.000002 let s:sign_group = 'PopUpCocDialog'
    1              0.000002 let s:detail_bufnr = 0
                            
                            " Float window aside pum
    1              0.000005 function! coc#dialog#create_pum_float(lines, config) abort
                              let winid = coc#float#get_float_by_kind('pumdetail')
                              if empty(a:lines) || !coc#pum#visible()
                                if winid
                                  call coc#float#close(winid)
                                endif
                                return
                              endif
                              let pumbounding = coc#pum#info()
                              let border = get(a:config, 'border', [])
                              let pw = pumbounding['width'] + (pumbounding['border'] ? 0 : get(pumbounding, 'scrollbar', 0))
                              let rp = &columns - pumbounding['col'] - pw
                              let showRight = pumbounding['col'] > rp ? 0 : 1
                              let maxWidth = showRight ? coc#math#min(rp - 1, a:config['maxWidth']) : coc#math#min(pumbounding['col'] - 1, a:config['maxWidth'])
                              let bh = get(border, 0 ,0) + get(border, 2, 0)
                              let maxHeight = &lines - pumbounding['row'] - &cmdheight - 1 - bh
                              if maxWidth <= 2 || maxHeight < 1
                                return v:null
                              endif
                              let width = 0
                              for line in a:lines
                                let dw = max([1, strdisplaywidth(line)])
                                let width = max([width, dw + 2])
                              endfor
                              let width = float2nr(coc#math#min(maxWidth, width))
                              let ch = coc#string#content_height(a:lines, width - 2)
                              let height = float2nr(coc#math#min(maxHeight, ch))
                              let lines = map(a:lines, {_, s -> s =~# '^─' ? repeat('─', width - 2 + (s:is_vim && ch > height ? -1 : 0)) : s})
                              let opts = {
                                    \ 'lines': lines,
                                    \ 'highlights': get(a:config, 'highlights', []),
                                    \ 'relative': 'editor',
                                    \ 'col': showRight ? pumbounding['col'] + pw : pumbounding['col'] - width,
                                    \ 'row': pumbounding['row'],
                                    \ 'height': height,
                                    \ 'width': width - 2 + (s:is_vim && ch > height ? -1 : 0),
                                    \ 'scrollinside': showRight ? 0 : 1,
                                    \ 'codes': get(a:config, 'codes', []),
                                    \ }
                              for key in ['border', 'highlight', 'borderhighlight', 'winblend', 'focusable', 'shadow', 'rounded']
                                if has_key(a:config, key)
                                  let opts[key] = a:config[key]
                                endif
                              endfor
                              call s:close_auto_hide_wins(winid)
                              let result = coc#float#create_float_win(winid, s:detail_bufnr, opts)
                              if empty(result)
                                return
                              endif
                              let s:detail_bufnr = result[1]
                              call setwinvar(result[0], 'kind', 'pumdetail')
                              if !s:is_vim
                                call coc#float#nvim_scrollbar(result[0])
                              endif
                            endfunction
                            
                            " Float window below/above cursor
    1              0.000004 function! coc#dialog#create_cursor_float(winid, bufnr, lines, config) abort
                              if coc#prompt#activated()
                                return v:null
                              endif
                              let pumAlignTop = get(a:config, 'pumAlignTop', 0)
                              let modes = get(a:config, 'modes', ['n', 'i', 'ic', 's'])
                              let mode = mode()
                              let currbuf = bufnr('%')
                              let pos = [line('.'), col('.')]
                              if index(modes, mode) == -1
                                return v:null
                              endif
                              if !s:is_vim && !has('nvim-0.5.0') && mode ==# 'i'
                                " helps to fix undo issue, don't know why.
                                call feedkeys("\<C-g>u", 'n')
                              endif
                              if mode ==# 's' && has('patch-8.2.4969') && !has('patch-8.2.4996')
                                echohl WarningMsg | echon 'Popup not created to avoid issue #10466 on vim >= 8.2.4969' | echohl None
                                return v:null
                              endif
                              let dimension = coc#dialog#get_config_cursor(a:lines, a:config)
                              if empty(dimension)
                                return v:null
                              endif
                              if coc#pum#visible() && ((pumAlignTop && dimension['row'] <0)|| (!pumAlignTop && dimension['row'] > 0))
                                return v:null
                              endif
                              let width = dimension['width']
                              let lines = map(a:lines, {_, s -> s =~# '^─' ? repeat('─', width) : s})
                              let config = extend(extend({'lines': lines, 'relative': 'cursor'}, a:config), dimension)
                              call s:close_auto_hide_wins(a:winid)
                              let res = coc#float#create_float_win(a:winid, a:bufnr, config)
                              if empty(res)
                                return v:null
                              endif
                              let alignTop = dimension['row'] < 0
                              let winid = res[0]
                              let bufnr = res[1]
                              redraw
                              if has('nvim')
                                call coc#float#nvim_scrollbar(winid)
                              endif
                              return [currbuf, pos, winid, bufnr, alignTop]
                            endfunction
                            
                            " Use terminal buffer
    1              0.000007 function! coc#dialog#_create_prompt_vim(title, default, opts) abort
                              if !has('patch-8.2.0750')
                                throw 'Input box not supported on vim < 8.2.0750'
                              endif
                              execute 'hi link CocPopupTerminal '.get(a:opts, 'highlight', 'CocFloating')
                              let node =  expand(get(g:, 'coc_node_path', 'node'))
                              let placeHolder = get(a:opts, 'placeHolder', '')
                              let opt = {
                                    \ 'term_rows': 1,
                                    \ 'hidden': 1,
                                    \ 'term_finish': 'close',
                                    \ 'norestore': 1,
                                    \ 'term_highlight': 'CocPopupTerminal'
                                    \ }
                              let bufnr = term_start([node, s:root . '/bin/prompt.js', a:default, empty(placeHolder) ? '' : placeHolder], opt)
                              call term_setapi(bufnr, 'Coc')
                              call setbufvar(bufnr, 'current', type(a:default) == v:t_string ? a:default : '')
                              let res = s:create_prompt_win(bufnr, a:title, a:default, a:opts)
                              if empty(res)
                                return
                              endif
                              let winid = res[0]
                              " call win_gotoid(winid)
                              call coc#util#do_autocmd('CocOpenFloatPrompt')
                              let pos = popup_getpos(winid)
                              " width height row col
                              let dimension = [pos['width'], pos['height'], pos['line'] - 1, pos['col'] - 1]
                              return [bufnr, winid, dimension]
                            endfunction
                            
                            " Use normal buffer on neovim
    1              0.000003 function! coc#dialog#_create_prompt_nvim(title, default, opts) abort
                              let result = s:create_prompt_win(s:prompt_win_bufnr, a:title, a:default, a:opts)
                              if empty(result)
                                return
                              endif
                              let winid = result[0]
                              let s:prompt_win_bufnr = result[1]
                              let bufnr = s:prompt_win_bufnr
                              call sign_unplace(s:sign_group, { 'buffer': s:prompt_win_bufnr })
                              call nvim_set_current_win(winid)
                              inoremap <buffer> <C-a> <Home>
                              inoremap <buffer><expr><C-e> pumvisible() ? "\<C-e>" : "\<End>"
                              exe 'imap <silent><nowait><buffer> <esc> <esc><esc>'
                              exe 'nnoremap <silent><buffer> <esc> :call coc#float#close('.winid.')<CR>'
                              exe 'inoremap <silent><expr><nowait><buffer> <cr> "\<C-r>=coc#dialog#prompt_insert()\<cr>\<esc>"'
                              if get(a:opts, 'list', 0)
                                for key in ['<C-j>', '<C-k>', '<C-n>', '<C-p>', '<up>', '<down>', '<C-f>', '<C-b>', '<C-space>']
                                  let escaped = key ==# '<C-space>' ? '\<C-@\>' : substitute(key, '\(<\|>\)', '\\\1', 'g')
                                  exe 'inoremap <nowait><buffer> '.key.' <Cmd>call coc#rpc#notify("PromptKeyPress", ['.bufnr.', "'.escaped.'"])<CR>'
                                endfor
                              endif
                              let mode = mode()
                              if mode ==# 'n'
                                call feedkeys('A', 'int')
                              elseif mode ==# 'i'
                                call feedkeys("\<end>", 'int')
                              else
                                call feedkeys("\<esc>A", 'int')
                              endif
                              let placeHolder = get(a:opts, 'placeHolder', '')
                              if empty(a:default) && !empty(placeHolder) && has('nvim-0.5.0')
                                let src_id = coc#highlight#create_namespace('input-box')
                                call nvim_buf_set_extmark(bufnr, src_id, 0, 0, {
                                      \ 'virt_text': [[placeHolder, 'CocInputBoxVirtualText']],
                                      \ 'virt_text_pos': 'overlay',
                                      \ })
                              endif
                              call coc#util#do_autocmd('CocOpenFloatPrompt')
                              if !has('nvim-0.6.0')
                                redraw
                              endif
                              let id = coc#float#get_related(winid, 'border')
                              let pos = nvim_win_get_position(id)
                              let dimension = [nvim_win_get_width(id), nvim_win_get_height(id), pos[0], pos[1]]
                              return [bufnr, winid, dimension]
                            endfunction
                            
                            " Create float window for input
    1              0.000002 function! coc#dialog#create_prompt_win(title, default, opts) abort
                              call s:close_auto_hide_wins()
                              if s:is_vim
                                return coc#dialog#_create_prompt_vim(a:title, a:default, a:opts)
                              endif
                              return  coc#dialog#_create_prompt_nvim(a:title, a:default, a:opts)
                            endfunction
                            
                            " Create list window under target window
    1              0.000003 function! coc#dialog#create_list(target, dimension, opts) abort
                              let maxHeight = get(a:opts, 'maxHeight', 30)
                              let height = get(a:opts, 'linecount', 1)
                              let height = min([maxHeight, height, &lines - &cmdheight - 1 - a:dimension['row'] + a:dimension['height']])
                              let chars = get(a:opts, 'rounded', 1) ? ['╯', '╰'] : ['┘', '└']
                              let width = a:dimension['width'] - 2
                              let config = extend(copy(a:opts), {
                                  \ 'relative': 'editor',
                                  \ 'row': a:dimension['row'] + a:dimension['height'],
                                  \ 'col': a:dimension['col'],
                                  \ 'width': width,
                                  \ 'height': height,
                                  \ 'border': [1, 1, 1, 1],
                                  \ 'scrollinside': 1,
                                  \ 'borderchars': extend(['─', '│', '─', '│', '├', '┤'], chars)
                                  \ })
                              let bufnr = 0
                              let result = coc#float#create_float_win(0, s:list_win_bufnr, config)
                              if empty(result)
                                return
                              endif
                              let winid = result[0]
                              call coc#float#add_related(winid, a:target)
                              call setwinvar(winid, 'auto_height', get(a:opts, 'autoHeight', 1))
                              call setwinvar(winid, 'core_width', width)
                              call setwinvar(winid, 'max_height', maxHeight)
                              call setwinvar(winid, 'target_winid', a:target)
                              call setwinvar(winid, 'kind', 'list')
                              call coc#dialog#check_scroll_vim(a:target)
                              return result
                            endfunction
                            
                            " Create menu picker for pick single item
    1              0.000005 function! coc#dialog#create_menu(lines, config) abort
                              call s:close_auto_hide_wins()
                              let highlight = get(a:config, 'highlight', 'CocFloating')
                              let borderhighlight = get(a:config, 'borderhighlight', [highlight])
                              let relative = get(a:config, 'relative', 'cursor')
                              let lines = a:lines
                              let content = get(a:config, 'content', '')
                              let maxWidth = get(a:config, 'maxWidth', 80)
                              let highlights = get(a:config, 'highlights', [])
                              let contentCount = 0
                              if !empty(content)
                                let contentLines = coc#string#reflow(split(content, '\r\?\n'), maxWidth)
                                let contentCount = len(contentLines)
                                let lines = extend(contentLines, lines)
                                if !empty(highlights)
                                  for item in highlights
                                    let item['lnum'] = item['lnum'] + contentCount
                                  endfor
                                endif
                              endif
                              let opts = {
                                \ 'lines': lines,
                                \ 'highlight': highlight,
                                \ 'title': get(a:config, 'title', ''),
                                \ 'borderhighlight': borderhighlight,
                                \ 'maxWidth': maxWidth,
                                \ 'maxHeight': get(a:config, 'maxHeight', 80),
                                \ 'rounded': get(a:config, 'rounded', 0),
                                \ 'border': [1, 1, 1, 1],
                                \ 'highlights': highlights,
                                \ 'relative': relative,
                                \ }
                              if relative ==# 'editor'
                                let dimension = coc#dialog#get_config_editor(lines, opts)
                              else
                                let dimension = coc#dialog#get_config_cursor(lines, opts)
                              endif
                              call extend(opts, dimension)
                              let ids = coc#float#create_float_win(0, s:prompt_win_bufnr, opts)
                              if empty(ids)
                                return
                              endif
                              let s:prompt_win_bufnr = ids[1]
                              call coc#dialog#set_cursor(ids[0], ids[1], contentCount + 1)
                              redraw
                              if has('nvim')
                                call coc#float#nvim_scrollbar(ids[0])
                              endif
                              return [ids[0], ids[1], contentCount]
                            endfunction
                            
                            " Create dialog at center of screen
    1              0.000002 function! coc#dialog#create_dialog(lines, config) abort
                              call s:close_auto_hide_wins()
                              " dialog always have borders
                              let title = get(a:config, 'title', '')
                              let buttons = get(a:config, 'buttons', [])
                              let highlight = get(a:config, 'highlight', 'CocFloating')
                              let borderhighlight = get(a:config, 'borderhighlight', [highlight])
                              let opts = {
                                \ 'title': title,
                                \ 'rounded': get(a:config, 'rounded', 0),
                                \ 'relative': 'editor',
                                \ 'border': [1,1,1,1],
                                \ 'close': get(a:config, 'close', 1),
                                \ 'highlight': highlight,
                                \ 'highlights': get(a:config, 'highlights', []),
                                \ 'buttons': buttons,
                                \ 'borderhighlight': borderhighlight,
                                \ 'getchar': get(a:config, 'getchar', 0)
                                \ }
                              call extend(opts, coc#dialog#get_config_editor(a:lines, a:config))
                              let bufnr = coc#float#create_buf(0, a:lines)
                              let res =  coc#float#create_float_win(0, bufnr, opts)
                              if empty(res)
                                return
                              endif
                              if get(a:config, 'cursorline', 0)
                                call coc#dialog#place_sign(bufnr, 1)
                              endif
                              if has('nvim')
                                redraw
                                call coc#float#nvim_scrollbar(res[0])
                              endif
                              return res
                            endfunction
                            
    1              0.000002 function! coc#dialog#prompt_confirm(title, cb) abort
                              call s:close_auto_hide_wins()
                              if s:is_vim && exists('*popup_dialog')
                                try
                                  call popup_dialog(a:title. ' (y/n)?', {
                                    \ 'highlight': 'Normal',
                                    \ 'filter': 'popup_filter_yesno',
                                    \ 'callback': {id, res -> a:cb(v:null, res)},
                                    \ 'borderchars': get(g:, 'coc_borderchars', ['─', '│', '─', '│', '╭', '╮', '╯', '╰']),
                                    \ 'borderhighlight': ['MoreMsg']
                                    \ })
                                catch /.*/
                                  call a:cb(v:exception)
                                endtry
                                return
                              endif
                              let text = ' '. a:title . ' (y/n)? '
                              let maxWidth = coc#math#min(78, &columns - 2)
                              let width = coc#math#min(maxWidth, strdisplaywidth(text))
                              let maxHeight = &lines - &cmdheight - 1
                              let height = coc#math#min(maxHeight, float2nr(ceil(str2float(string(strdisplaywidth(text)))/width)))
                              let arr =  coc#float#create_float_win(0, s:prompt_win_bufnr, {
                                    \ 'col': &columns/2 - width/2 - 1,
                                    \ 'row': maxHeight/2 - height/2 - 1,
                                    \ 'width': width,
                                    \ 'height': height,
                                    \ 'border': [1,1,1,1],
                                    \ 'focusable': v:false,
                                    \ 'relative': 'editor',
                                    \ 'highlight': 'Normal',
                                    \ 'borderhighlight': 'MoreMsg',
                                    \ 'style': 'minimal',
                                    \ 'lines': [text],
                                    \ })
                              if empty(arr)
                                call a:cb('Window create failed!')
                                return
                              endif
                              let winid = arr[0]
                              let s:prompt_win_bufnr = arr[1]
                              call sign_unplace(s:sign_group, { 'buffer': s:prompt_win_bufnr })
                              let res = 0
                              redraw
                              " same result as vim
                              while 1
                                let key = nr2char(getchar())
                                if key == "\<C-c>"
                                  let res = -1
                                  break
                                elseif key == "\<esc>" || key == 'n' || key == 'N'
                                  let res = 0
                                  break
                                elseif key == 'y' || key == 'Y'
                                  let res = 1
                                  break
                                endif
                              endw
                              call coc#float#close(winid)
                              call a:cb(v:null, res)
                            endfunction
                            
                            " works on neovim only
    1              0.000002 function! coc#dialog#get_prompt_win() abort
                              if s:prompt_win_bufnr == 0
                                return -1
                              endif
                              return get(win_findbuf(s:prompt_win_bufnr), 0, -1)
                            endfunction
                            
    1              0.000002 function! coc#dialog#get_config_editor(lines, config) abort
                              let title = get(a:config, 'title', '')
                              let maxheight = min([get(a:config, 'maxHeight', 78), &lines - &cmdheight - 6])
                              let maxwidth = min([get(a:config, 'maxWidth', 78), &columns - 2])
                              let buttons = get(a:config, 'buttons', [])
                              let minwidth = s:min_btns_width(buttons)
                              if maxheight <= 0 || maxwidth <= 0 || minwidth > maxwidth
                                throw 'Not enough spaces for float window'
                              endif
                              let ch = 0
                              let width = min([strdisplaywidth(title) + 1, maxwidth])
                              for line in a:lines
                                let dw = max([1, strdisplaywidth(line)])
                                if dw < maxwidth && dw > width
                                  let width = dw
                                elseif dw >= maxwidth
                                  let width = maxwidth
                                endif
                                let ch += float2nr(ceil(str2float(string(dw))/maxwidth))
                              endfor
                              let width = max([minwidth, width])
                              let height = coc#math#min(ch ,maxheight)
                              return {
                                  \ 'row': &lines/2 - (height + 4)/2,
                                  \ 'col': &columns/2 - (width + 2)/2,
                                  \ 'width': width,
                                  \ 'height': height,
                                  \ }
                            endfunction
                            
    1              0.000002 function! coc#dialog#prompt_insert() abort
                              let value = getline('.')
                              call coc#rpc#notify('PromptInsert', [value, bufnr('%')])
                              return ''
                            endfunction
                            
                            " Dimension of window with lines relative to cursor
                            " Width & height excludes border & padding
    1              0.000002 function! coc#dialog#get_config_cursor(lines, config) abort
                              let preferTop = get(a:config, 'preferTop', 0)
                              let title = get(a:config, 'title', '')
                              let border = get(a:config, 'border', [])
                              if empty(border) && len(title)
                                let border = [1, 1, 1, 1]
                              endif
                              let bh = get(border, 0, 0) + get(border, 2, 0)
                              let vh = &lines - &cmdheight - 1
                              if vh <= 0
                                return v:null
                              endif
                              let maxWidth = coc#math#min(get(a:config, 'maxWidth', &columns - 1), &columns - 1)
                              if maxWidth < 3
                                return v:null
                              endif
                              let maxHeight = coc#math#min(get(a:config, 'maxHeight', vh), vh)
                              let width = coc#math#min(40, strdisplaywidth(title)) + 3
                              for line in a:lines
                                let dw = max([1, strdisplaywidth(line)])
                                let width = max([width, dw + 2])
                              endfor
                              let width = coc#math#min(maxWidth, width)
                              let ch = coc#string#content_height(a:lines, width - 2)
                              let [lineIdx, colIdx] = coc#cursor#screen_pos()
                              " How much we should move left
                              let offsetX = coc#math#min(get(a:config, 'offsetX', 0), colIdx)
                              let showTop = 0
                              let hb = vh - lineIdx -1
                              if lineIdx > bh + 2 && (preferTop || (lineIdx > hb && hb < ch + bh))
                                let showTop = 1
                              endif
                              let height = coc#math#min(maxHeight, ch + bh, showTop ? lineIdx - 1 : hb)
                              if height <= bh
                                return v:null
                              endif
                              let col = - max([offsetX, colIdx - (&columns - 1 - width)])
                              let row = showTop ? - height + bh : 1
                              return {
                                    \ 'row': row,
                                    \ 'col': col,
                                    \ 'width': width - 2,
                                    \ 'height': height - bh
                                    \ }
                            endfunction
                            
    1              0.000002 function! coc#dialog#change_border_hl(winid, hlgroup) abort
                              if !hlexists(a:hlgroup)
                                return
                              endif
                              if s:is_vim
                                if coc#float#valid(a:winid)
                                  call popup_setoptions(a:winid, {'borderhighlight': repeat([a:hlgroup], 4)})
                                  redraw
                                endif
                              else
                                let winid = coc#float#get_related(a:winid, 'border')
                                if winid > 0
                                  call setwinvar(winid, '&winhl', 'Normal:'.a:hlgroup)
                                endif
                              endif
                            endfunction
                            
    1              0.000002 function! coc#dialog#change_title(winid, title) abort
                              if s:is_vim
                                if coc#float#valid(a:winid)
                                  call popup_setoptions(a:winid, {'title': a:title})
                                  redraw
                                endif
                              else
                                let winid = coc#float#get_related(a:winid, 'border')
                                if winid > 0
                                  let bufnr = winbufnr(winid)
                                  let line = getbufline(bufnr, 1)[0]
                                  let top = strcharpart(line, 0, 1)
                                        \.repeat('─', strchars(line) - 2)
                                        \.strcharpart(line, strchars(line) - 1, 1)
                                  if !empty(a:title)
                                    let top = coc#string#compose(top, 1, a:title.' ')
                                  endif
                                  call nvim_buf_set_lines(bufnr, 0, 1, v:false, [top])
                                endif
                              endif
                            endfunction
                            
    1              0.000002 function! coc#dialog#change_input_value(winid, bufnr, value) abort
                              if !coc#float#valid(a:winid)
                                return
                              endif
                              if win_getid() != a:winid
                                call win_gotoid(a:winid)
                              endif
                              if s:is_vim
                                " call timer_start(3000, { -> term_sendkeys(bufnr, "\<C-u>\<C-k>abcd")})
                                call term_sendkeys(a:bufnr, "\<C-u>\<C-k>".a:value)
                              else
                                let mode = mode()
                                if mode ==# 'i'
                                  call feedkeys("\<end>", 'int')
                                else
                                  call feedkeys("\<esc>A", 'int')
                                endif
                                " Use complete to replace text before
                                let saved_completeopt = &completeopt
                                if saved_completeopt =~ 'menuone'
                                  noa set completeopt=menu
                                endif
                                noa call complete(1, [{ 'empty': 1, 'word': a:value }])
                                if has('nvim-0.6.1')
                                  call feedkeys("\<C-x>\<C-z>", 'in')
                                else
                                  let g:coc_disable_space_report = 1
                                  call feedkeys("\<space>\<bs>", 'in')
                                endif
                                execute 'noa set completeopt='.saved_completeopt
                              endif
                            endfunction
                            
    1              0.000002 function! coc#dialog#change_loading(winid, loading) abort
                              if coc#float#valid(a:winid)
                                let winid = coc#float#get_related(a:winid, 'loading')
                                if !a:loading && winid > 0
                                  call coc#float#close(winid)
                                endif
                                if a:loading && winid == 0
                                  let bufnr = s:create_loading_buf()
                                  if s:is_vim
                                    let pos = popup_getpos(a:winid)
                                    let winid = popup_create(bufnr, {
                                        \ 'line': pos['line'] + 1,
                                        \ 'col': pos['col'] + pos['width'] - 4,
                                        \ 'maxheight': 1,
                                        \ 'maxwidth': 3,
                                        \ 'zindex': 999,
                                        \ 'highlight': get(popup_getoptions(a:winid), 'highlight', 'CocFloating')
                                        \ })
                                  else
                                    let pos = nvim_win_get_position(a:winid)
                                    let width = nvim_win_get_width(a:winid)
                                    let opts = {
                                        \ 'relative': 'editor',
                                        \ 'row': pos[0],
                                        \ 'col': pos[1] + width - 3,
                                        \ 'focusable': v:false,
                                        \ 'width': 3,
                                        \ 'height': 1,
                                        \ 'style': 'minimal',
                                        \ }
                                    if has('nvim-0.5.1')
                                      let opts['zindex'] = 900
                                    endif
                                    let winid = nvim_open_win(bufnr, v:false, opts)
                                    call setwinvar(winid, '&winhl', getwinvar(a:winid, '&winhl'))
                                  endif
                                  call setwinvar(winid, 'kind', 'loading')
                                  call setbufvar(bufnr, 'target_winid', a:winid)
                                  call setbufvar(bufnr, 'popup', winid)
                                  call coc#float#add_related(winid, a:winid)
                                endif
                              endif
                            endfunction
                            
                            " Update list with new lines and highlights
    1              0.000002 function! coc#dialog#update_list(winid, bufnr, lines, highlights) abort
                              if coc#window#tabnr(a:winid) == tabpagenr()
                                if getwinvar(a:winid, 'auto_height', 0)
                                  let row = coc#float#get_row(a:winid)
                                  let width = getwinvar(a:winid, 'core_width', 80)
                                  let height = s:get_height(a:lines, width)
                                  let height = min([getwinvar(a:winid, 'max_height', 10), height, &lines - &cmdheight - 1 - row])
                                  let curr = s:is_vim ? popup_getpos(a:winid)['core_height'] : nvim_win_get_height(a:winid)
                                  let delta = height - curr
                                  if delta != 0
                                    call coc#float#change_height(a:winid, delta)
                                  endif
                                endif
                                call coc#compat#buf_set_lines(a:bufnr, 0, -1, a:lines)
                                call coc#highlight#add_highlights(a:winid, [], a:highlights)
                                if s:is_vim
                                  let target = getwinvar(a:winid, 'target_winid', -1)
                                  if target != -1
                                    call coc#dialog#check_scroll_vim(target)
                                  endif
                                  call win_execute(a:winid, 'exe 1')
                                endif
                              endif
                            endfunction
                            
                            " Fix width of prompt window same as list window on scrollbar change
    1              0.000002 function! coc#dialog#check_scroll_vim(winid) abort
                              if s:is_vim && coc#float#valid(a:winid)
                                let winid = coc#float#get_related(a:winid, 'list')
                                if winid
                                  redraw
                                  let pos = popup_getpos(winid)
                                  let width = pos['width'] + (pos['scrollbar'] ? 1 : 0)
                                  if width != popup_getpos(a:winid)['width']
                                    call popup_move(a:winid, {
                                        \ 'minwidth': width - 2,
                                        \ 'maxwidth': width - 2,
                                        \ })
                                  endif
                                endif
                              endif
                            endfunction
                            
    1              0.000002 function! coc#dialog#set_cursor(winid, bufnr, line) abort
                              if s:is_vim
                                call coc#compat#execute(a:winid, 'exe '.max([a:line, 1]), 'silent!')
                                call popup_setoptions(a:winid, {'cursorline' : 1})
                                call popup_setoptions(a:winid, {'cursorline' : 0})
                              else
                                call nvim_win_set_cursor(a:winid, [max([a:line, 1]), 0])
                              endif
                              call coc#dialog#place_sign(a:bufnr, a:line)
                            endfunction
                            
    1              0.000002 function! coc#dialog#place_sign(bufnr, line) abort
                              call sign_unplace(s:sign_group, { 'buffer': a:bufnr })
                              if a:line > 0
                                call sign_place(6, s:sign_group, 'CocCurrentLine', a:bufnr, {'lnum': a:line})
                              endif
                            endfunction
                            
    1              0.000005 function! s:create_prompt_win(bufnr, title, default, opts) abort
                              let config = s:get_prompt_dimension(a:title, a:default, a:opts)
                              return coc#float#create_float_win(0, a:bufnr, extend(config, {
                                    \ 'style': 'minimal',
                                    \ 'border': get(a:opts, 'border', [1,1,1,1]),
                                    \ 'rounded': get(a:opts, 'rounded', 1),
                                    \ 'prompt': 1,
                                    \ 'title': a:title,
                                    \ 'lines': s:is_vim ? v:null : [a:default],
                                    \ 'highlight': get(a:opts, 'highlight', 'CocFloating'),
                                    \ 'borderhighlight': [get(a:opts, 'borderhighlight', 'CocFloating')],
                                    \ }))
                            endfunction
                            
                            " Could be center(with optional marginTop) or cursor
    1              0.000003 function! s:get_prompt_dimension(title, default, opts) abort
                              let relative = get(a:opts, 'position', 'cursor') ==# 'cursor' ? 'cursor' : 'editor'
                              let curr = win_screenpos(winnr())[1] + wincol() - 2
                              let minWidth = get(a:opts, 'minWidth', s:prompt_win_width)
                              let width = min([max([strwidth(a:default) + 2, strwidth(a:title) + 2, minWidth]), &columns - 2])
                              if get(a:opts, 'maxWidth', 0)
                                let width = min([width, a:opts['maxWidth']])
                              endif
                              if relative ==# 'cursor'
                                let [lineIdx, colIdx] = coc#cursor#screen_pos()
                                if width == &columns - 2
                                  let col = 0 - curr
                                else
                                  let col = curr + width <= &columns - 2 ? 0 : curr + width - &columns + 2
                                endif
                                let config = {
                                    \ 'row': lineIdx == 0 ? 1 : 0,
                                    \ 'col': colIdx == 0 ? 0 : col - 1,
                                    \ }
                              else
                                let marginTop = get(a:opts, 'marginTop', v:null)
                                if marginTop is v:null
                                  let row = (&lines - &cmdheight - 2) / 2
                                else
                                  let row = marginTop < 2 ? 1 : min([marginTop, &columns - &cmdheight])
                                endif
                                let config = {
                                      \ 'col': float2nr((&columns - width) / 2),
                                      \ 'row': row - s:is_vim,
                                      \ }
                              endif
                              return extend(config, {'relative': relative, 'width': width, 'height': 1})
                            endfunction
                            
    1              0.000002 function! s:min_btns_width(buttons) abort
                              if empty(a:buttons)
                                return 0
                              endif
                              let minwidth = len(a:buttons)*3 - 1
                              for txt in a:buttons
                                let minwidth = minwidth + strdisplaywidth(txt)
                              endfor
                              return minwidth
                            endfunction
                            
                            " Close windows that should auto hide
    1              0.000002 function! s:close_auto_hide_wins(...) abort
                              let winids = coc#float#get_float_win_list()
                              let except = get(a:, 1, 0)
                              for id in winids
                                if except && id == except
                                  continue
                                endif
                                if getwinvar(id, 'autohide', 0)
                                  call coc#float#close(id)
                                endif
                              endfor
                            endfunction
                            
    1              0.000002 function! s:create_loading_buf() abort
                              let bufnr = coc#float#create_buf(0)
                              call s:change_loading_buf(bufnr, 0)
                              return bufnr
                            endfunction
                            
    1              0.000002 function! s:get_height(lines, width) abort
                              let height = 0
                              for line in a:lines
                                let height += float2nr(strdisplaywidth(line) / a:width) + 1
                              endfor
                              return max([1, height])
                            endfunction
                            
    1              0.000002 function! s:change_loading_buf(bufnr, idx) abort
                              if bufloaded(a:bufnr)
                                let target = getbufvar(a:bufnr, 'target_winid', v:null)
                                if !empty(target) && !coc#float#valid(target)
                                  call coc#float#close(getbufvar(a:bufnr, 'popup'))
                                  return
                                endif
                                let line = get(s:frames, a:idx, '   ')
                                call setbufline(a:bufnr, 1, line)
                                call coc#highlight#add_highlight(a:bufnr, -1, 'CocNotificationProgress', 0, 0, -1)
                                let idx = a:idx == len(s:frames) - 1 ? 0 : a:idx + 1
                                call timer_start(100, { -> s:change_loading_buf(a:bufnr, idx)})
                              endif
                            endfunction

SCRIPT  /Users/elanmedoff/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/prompt.vim
Sourced 1 time
Total time:   0.000323
 Self time:   0.000323

count  total (s)   self (s)
    1              0.000005 scriptencoding utf-8
    1              0.000012 let s:is_vim = !has('nvim')
    1              0.000002 let s:activated = 0
    1              0.000002 let s:session_names = []
    1              0.000003 let s:saved_ve = &t_ve
    1              0.000003 let s:saved_cursor = &guicursor
    1              0.000007 let s:gui = has('gui_running') || has('nvim')
                            
    1              0.000131 let s:char_map = {
                                  \ "\<Plug>": '<plug>',
                                  \ "\<Esc>": '<esc>',
                                  \ "\<Tab>": '<tab>',
                                  \ "\<S-Tab>": '<s-tab>',
                                  \ "\<bs>": '<bs>',
                                  \ "\<right>": '<right>',
                                  \ "\<left>": '<left>',
                                  \ "\<up>": '<up>',
                                  \ "\<down>": '<down>',
                                  \ "\<home>": '<home>',
                                  \ "\<end>": '<end>',
                                  \ "\<cr>": '<cr>',
                                  \ "\<PageUp>":'<PageUp>' ,
                                  \ "\<PageDown>":'<PageDown>' ,
                                  \ "\<FocusGained>":'<FocusGained>',
                                  \ "\<FocusLost>":'<FocusLost>',
                                  \ "\<ScrollWheelUp>": '<ScrollWheelUp>',
                                  \ "\<ScrollWheelDown>": '<ScrollWheelDown>',
                                  \ "\<LeftMouse>": '<LeftMouse>',
                                  \ "\<LeftDrag>": '<LeftDrag>',
                                  \ "\<LeftRelease>": '<LeftRelease>',
                                  \ "\<2-LeftMouse>": '<2-LeftMouse>',
                                  \ "\<C-a>": '<C-a>',
                                  \ "\<C-b>": '<C-b>',
                                  \ "\<C-c>": '<C-c>',
                                  \ "\<C-d>": '<C-d>',
                                  \ "\<C-e>": '<C-e>',
                                  \ "\<C-f>": '<C-f>',
                                  \ "\<C-g>": '<C-g>',
                                  \ "\<C-h>": '<C-h>',
                                  \ "\<C-j>": '<C-j>',
                                  \ "\<C-k>": '<C-k>',
                                  \ "\<C-l>": '<C-l>',
                                  \ "\<C-n>": '<C-n>',
                                  \ "\<C-o>": '<C-o>',
                                  \ "\<C-p>": '<C-p>',
                                  \ "\<C-q>": '<C-q>',
                                  \ "\<C-r>": '<C-r>',
                                  \ "\<C-s>": '<C-s>',
                                  \ "\<C-t>": '<C-t>',
                                  \ "\<C-u>": '<C-u>',
                                  \ "\<C-v>": '<C-v>',
                                  \ "\<C-w>": '<C-w>',
                                  \ "\<C-x>": '<C-x>',
                                  \ "\<C-y>": '<C-y>',
                                  \ "\<C-z>": '<C-z>',
                                  \ "\<A-a>": '<A-a>',
                                  \ "\<A-b>": '<A-b>',
                                  \ "\<A-c>": '<A-c>',
                                  \ "\<A-d>": '<A-d>',
                                  \ "\<A-e>": '<A-e>',
                                  \ "\<A-f>": '<A-f>',
                                  \ "\<A-g>": '<A-g>',
                                  \ "\<A-h>": '<A-h>',
                                  \ "\<A-i>": '<A-i>',
                                  \ "\<A-j>": '<A-j>',
                                  \ "\<A-k>": '<A-k>',
                                  \ "\<A-l>": '<A-l>',
                                  \ "\<A-m>": '<A-m>',
                                  \ "\<A-n>": '<A-n>',
                                  \ "\<A-o>": '<A-o>',
                                  \ "\<A-p>": '<A-p>',
                                  \ "\<A-q>": '<A-q>',
                                  \ "\<A-r>": '<A-r>',
                                  \ "\<A-s>": '<A-s>',
                                  \ "\<A-t>": '<A-t>',
                                  \ "\<A-u>": '<A-u>',
                                  \ "\<A-v>": '<A-v>',
                                  \ "\<A-w>": '<A-w>',
                                  \ "\<A-x>": '<A-x>',
                                  \ "\<A-y>": '<A-y>',
                                  \ "\<A-z>": '<A-z>',
                                  \ }
                            
    1              0.000003 function! coc#prompt#getc() abort
                              let c = getchar()
                              return type(c) is 0 ? nr2char(c) : c
                            endfunction
                            
    1              0.000002 function! coc#prompt#getchar() abort
                              let input = coc#prompt#getc()
                              if 1 != &iminsert
                                return input
                              endif
                              "a language keymap is activated, so input must be resolved to the mapped values.
                              let partial_keymap = mapcheck(input, 'l')
                              while partial_keymap !=# ''
                                let dict = maparg(input, 'l', 0, 1)
                                if empty(dict) || get(dict, 'expr', 0)
                                  return input
                                endif
                                let full_keymap = get(dict, 'rhs', '')
                                if full_keymap ==# "" && len(input) >= 3 "HACK: assume there are no keymaps longer than 3.
                                  return input
                                elseif full_keymap ==# partial_keymap
                                  return full_keymap
                                endif
                                let c = coc#prompt#getc()
                                if c ==# "\<Esc>" || c ==# "\<CR>"
                                  "if the short sequence has a valid mapping, return that.
                                  if !empty(full_keymap)
                                    return full_keymap
                                  endif
                                  return input
                                endif
                                let input .= c
                                let partial_keymap = mapcheck(input, 'l')
                              endwhile
                              return input
                            endfunction
                            
    1              0.000002 function! coc#prompt#start_prompt(session) abort
                              let s:session_names = s:filter(s:session_names, a:session)
                              call add(s:session_names, a:session)
                              if s:activated | return | endif
                              if s:is_vim
                                call s:start_prompt_vim()
                              else
                                call s:start_prompt()
                              endif
                            endfunction
                            
    1              0.000003 function! s:start_prompt_vim() abort
                              call timer_start(10, {-> s:start_prompt()})
                            endfunction
                            
    1              0.000002 function! s:start_prompt()
                              if s:activated | return | endif
                              if !get(g:, 'coc_disable_transparent_cursor', 0)
                                if s:gui
                                  if has('nvim-0.5.0') && !empty(s:saved_cursor)
                                    set guicursor+=a:ver1-CocCursorTransparent/lCursor
                                  endif
                                elseif s:is_vim
                                  set t_ve=
                                endif
                              endif
                              let s:activated = 1
                              try
                                while s:activated
                                  let ch = coc#prompt#getchar()
                                  if ch ==# "\<FocusLost>" || ch ==# "\<FocusGained>" || ch ==# "\<CursorHold>"
                                    continue
                                  else
                                    let curr = s:current_session()
                                    let mapped = get(s:char_map, ch, ch)
                                    if !empty(curr)
                                      call coc#rpc#notify('InputChar', [curr, mapped, getcharmod()])
                                    endif
                                    if mapped == '<esc>'
                                      let s:session_names = []
                                      call s:reset()
                                      break
                                    endif
                                  endif
                                endwhile
                              catch /^Vim:Interrupt$/
                                let s:activated = 0
                                call coc#rpc#notify('InputChar', [s:current_session(), '<esc>', 0])
                                let s:session_names = []
                                call s:reset()
                                return
                              endtry
                              let s:activated = 0
                            endfunction
                            
    1              0.000002 function! coc#prompt#stop_prompt(session)
                              let s:session_names = s:filter(s:session_names, a:session)
                              if len(s:session_names)
                                return
                              endif
                              if s:activated
                                let s:activated = 0
                                call s:reset()
                                call feedkeys("\<esc>", 'int')
                              endif
                            endfunction
                            
    1              0.000002 function! coc#prompt#activated() abort
                              return s:activated
                            endfunction
                            
    1              0.000002 function! s:reset() abort
                              if !get(g:, 'coc_disable_transparent_cursor',0)
                                " neovim has bug with revert empty &guicursor
                                if s:gui && !empty(s:saved_cursor)
                                  if has('nvim-0.5.0')
                                    set guicursor+=a:ver1-Cursor/lCursor
                                    let &guicursor = s:saved_cursor
                                  endif
                                elseif s:is_vim
                                  let &t_ve = s:saved_ve
                                endif
                              endif
                              echo ""
                            endfunction
                            
    1              0.000002 function! s:current_session() abort
                              if empty(s:session_names)
                                return v:null
                              endif
                              return s:session_names[len(s:session_names) - 1]
                            endfunction
                            
    1              0.000002 function! s:filter(list, id) abort
                              return filter(copy(a:list), 'v:val !=# a:id')
                            endfunction

SCRIPT  /Users/elanmedoff/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/math.vim
Sourced 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
                            
                            " support for float values
    1              0.000006 function! coc#math#min(first, ...) abort
                              let val = a:first
                              for i in range(0, len(a:000) - 1)
                                if a:000[i] < val
                                  let val = a:000[i]
                                endif
                              endfor
                              return val
                            endfunction

SCRIPT  /Users/elanmedoff/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/pum.vim
Sourced 1 time
Total time:   0.001405
 Self time:   0.001365

count  total (s)   self (s)
    1              0.000008 scriptencoding utf-8
    1              0.000013 let s:is_vim = !has('nvim')
    1              0.000003 let s:pum_bufnr = 0
    1              0.000002 let s:pum_winid = -1
    1              0.000002 let s:pum_index = -1
    1              0.000002 let s:pum_size = 0
                            " word of complete item inserted
    1              0.000002 let s:inserted = 0
    1              0.000002 let s:virtual_text = 0
    1   0.000056   0.000016 let s:virtual_text_ns = coc#highlight#create_namespace('pum-virtual')
    1              0.000010 let s:ignore = s:is_vim || has('nvim-0.5.0') ? "\<Ignore>" : "\<space>\<bs>"
    1              0.000005 let s:hide_pum = has('nvim-0.6.1') || has('patch-8.2.3389')
    1              0.000005 let s:virtual_text_support = has('nvim-0.5.0') || has('patch-9.0.0067')
                            " bufnr, &indentkeys
    1              0.000002 let s:saved_indenetkeys = []
    1              0.000002 let s:saved_textwidth = []
    1              0.000002 let s:prop_id = 0
    1              0.000002 let s:reversed = 0
    1              0.000002 let s:check_hl_group = 0
    1              0.000002 let s:start_col = -1
                            
    1              0.000002 if s:is_vim && s:virtual_text_support
                              if empty(prop_type_get('CocPumVirtualText'))
                                call prop_type_add('CocPumVirtualText', {'highlight': 'CocPumVirtualText'})
                              endif
    1              0.000001 endif
                            
    1              0.000003 function! coc#pum#visible() abort
                              if s:pum_winid == -1
                                return 0
                              endif
                              " getwinvar check current tab only.
                              return getwinvar(s:pum_winid, 'float', 0) == 1
                            endfunction
                            
    1              0.000002 function! coc#pum#winid() abort
                              return s:pum_winid
                            endfunction
                            
    1              0.000002 function! coc#pum#close_detail() abort
                              let winid = coc#float#get_float_by_kind('pumdetail')
                              if winid
                                call coc#float#close(winid, 1)
                              endif
                            endfunction
                            
    1              0.000001 function! coc#pum#close(...) abort
                              if coc#pum#visible()
                                let kind = get(a:, 1, '')
                                if kind ==# 'cancel'
                                  let input = getwinvar(s:pum_winid, 'input', '')
                                  let s:pum_index = -1
                                  call s:insert_word(input, 1)
                                  call s:on_pum_change(0)
                                  doautocmd <nomodeline> TextChangedI
                                elseif kind ==# 'confirm'
                                  let words = getwinvar(s:pum_winid, 'words', [])
                                  if s:pum_index >= 0
                                    let word = get(words, s:pum_index, '')
                                    call s:insert_word(word, 1)
                                    " have to restore here, so that TextChangedI can trigger indent.
                                    call s:restore_indentkeys()
                                  endif
                                  doautocmd <nomodeline> TextChangedI
                                endif
                                call s:close_pum()
                                if !get(a:, 2, 0)
                                  call coc#rpc#notify('CompleteStop', [kind])
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000002 function! coc#pum#select_confirm() abort
                              if coc#pum#visible()
                                if s:pum_index < 0
                                  let s:pum_index = 0
                                  call s:on_pum_change(0)
                                endif
                                call coc#pum#close('confirm')
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! coc#pum#_close() abort
                              if coc#pum#visible()
                                call s:close_pum()
                              endif
                            endfunction
                            
    1              0.000001 function! coc#pum#_one_more() abort
                              if coc#pum#visible()
                                let parts = getwinvar(s:pum_winid, 'parts', [])
                                let start = strlen(parts[0])
                                let input = strpart(getline('.'), start, col('.') - 1 - start)
                                let words = getwinvar(s:pum_winid, 'words', [])
                                let word = get(words, s:pum_index == -1 ? 0 : s:pum_index, '')
                                if !empty(word) && strcharpart(word, 0, strchars(input)) ==# input
                                  let ch = strcharpart(word, strchars(input), 1)
                                  if !empty(ch)
                                    call feedkeys(ch, "int")
                                  endif
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! coc#pum#_insert() abort
                              if coc#pum#visible()
                                if s:pum_index >= 0
                                  let words = getwinvar(s:pum_winid, 'words', [])
                                  let word = get(words, s:pum_index, '')
                                  call s:insert_word(word, 1)
                                  call s:restore_indentkeys()
                                endif
                                doautocmd <nomodeline> TextChangedI
                                call s:close_pum()
                                call coc#rpc#notify('CompleteStop', [''])
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! coc#pum#insert() abort
                              return "\<C-r>=coc#pum#_insert()\<CR>"
                            endfunction
                            
                            " Add one more character from the matched complete item(or first one),
                            " the word should starts with input, the same as vim's CTRL-L behavior.
    1              0.000001 function! coc#pum#one_more() abort
                              return "\<C-r>=coc#pum#_one_more()\<CR>"
                            endfunction
                            
    1              0.000002 function! coc#pum#next(insert) abort
                              return "\<C-r>=coc#pum#_navigate(1,".a:insert.")\<CR>"
                            endfunction
                            
    1              0.000002 function! coc#pum#prev(insert) abort
                              return "\<C-r>=coc#pum#_navigate(0,".a:insert.")\<CR>"
                            endfunction
                            
    1              0.000001 function! coc#pum#stop() abort
                              return "\<C-r>=coc#pum#close()\<CR>"
                            endfunction
                            
    1              0.000001 function! coc#pum#cancel() abort
                              return "\<C-r>=coc#pum#close('cancel')\<CR>"
                            endfunction
                            
    1              0.000338 function! coc#pum#confirm() abort
                              return "\<C-r>=coc#pum#close('confirm')\<CR>"
                            endfunction
                            
    1              0.000003 function! coc#pum#select(index, insert, confirm) abort
                              if coc#pum#visible()
                                if a:index == -1
                                  call coc#pum#close('cancel')
                                  return ''
                                endif
                                if a:index < 0 || a:index >= s:pum_size
                                  throw 'index out of range ' . a:index
                                endif
                                call s:select_by_index(a:index, a:insert)
                                if a:confirm
                                  call coc#pum#close('confirm')
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! coc#pum#info() abort
                              let bufnr = winbufnr(s:pum_winid)
                              let words = getwinvar(s:pum_winid, 'words', [])
                              let word = s:pum_index < 0 ? '' : get(words, s:pum_index, '')
                              let base = {
                                    \ 'word': word,
                                    \ 'index': s:pum_index,
                                    \ 'size': s:pum_size,
                                    \ 'startcol': s:start_col,
                                    \ 'inserted': s:pum_index >=0 && s:inserted ? v:true : v:false,
                                    \ 'reversed': s:reversed ? v:true : v:false,
                                    \ }
                              if s:is_vim
                                let pos = popup_getpos(s:pum_winid)
                                let border = has_key(popup_getoptions(s:pum_winid), 'border')
                                let add = pos['scrollbar'] && border ? 1 : 0
                                return extend(base, {
                                      \ 'scrollbar': pos['scrollbar'],
                                      \ 'row': pos['line'] - 1,
                                      \ 'col': pos['col'] - 1,
                                      \ 'width': pos['width'] + add,
                                      \ 'height': pos['height'],
                                      \ 'border': border,
                                      \ })
                              else
                                let scrollbar = coc#float#get_related(s:pum_winid, 'scrollbar')
                                let winid = coc#float#get_related(s:pum_winid, 'border', s:pum_winid)
                                let pos = nvim_win_get_position(winid)
                                return extend(base, {
                                      \ 'scrollbar': scrollbar && nvim_win_is_valid(scrollbar) ? 1 : 0,
                                      \ 'row': pos[0],
                                      \ 'col': pos[1],
                                      \ 'width': nvim_win_get_width(winid),
                                      \ 'height': nvim_win_get_height(winid),
                                      \ 'border': winid != s:pum_winid,
                                      \ })
                              endif
                            endfunction
                            
    1              0.000002 function! coc#pum#scroll(forward) abort
                              if coc#pum#visible()
                                let height = s:get_height(s:pum_winid)
                                if s:pum_size > height
                                  call timer_start(1, { -> s:scroll_pum(a:forward, height, s:pum_size)})
                                endif
                              endif
                              " Required on old version vim/neovim.
                              return s:ignore
                            endfunction
                            
    1              0.000004 function! s:get_height(winid) abort
                              if has('nvim')
                                return nvim_win_get_height(a:winid)
                              endif
                              return get(popup_getpos(a:winid), 'core_height', 0)
                            endfunction
                            
    1              0.000002 function! s:scroll_pum(forward, height, size) abort
                              let topline = s:get_topline(s:pum_winid)
                              if !a:forward && topline == 1
                                if s:pum_index >= 0
                                  call s:select_line(s:pum_winid, 1)
                                  call s:on_pum_change(1)
                                endif
                                return
                              endif
                              if a:forward && topline + a:height - 1 >= a:size
                                if s:pum_index >= 0
                                  call s:select_line(s:pum_winid, a:size)
                                  call s:on_pum_change(1)
                                endif
                                return
                              endif
                              call coc#float#scroll_win(s:pum_winid, a:forward, a:height)
                              if s:pum_index >= 0
                                let lnum = s:pum_index + 1
                                let topline = s:get_topline(s:pum_winid)
                                if lnum >= topline && lnum <= topline + a:height - 1
                                  return
                                endif
                                call s:select_line(s:pum_winid, topline)
                                call s:on_pum_change(1)
                              endif
                            endfunction
                            
    1              0.000002 function! s:get_topline(winid) abort
                              if has('nvim')
                                let info = getwininfo(a:winid)[0]
                                return info['topline']
                              else
                                let pos = popup_getpos(a:winid)
                                return pos['firstline']
                              endif
                            endfunction
                            
    1              0.000002 function! coc#pum#_navigate(next, insert) abort
                              if coc#pum#visible()
                                call s:save_indentkeys()
                                let index = s:get_index(a:next)
                                call s:select_by_index(index, a:insert)
                                call coc#rpc#notify('PumNavigate', [])
                              endif
                              return ''
                            endfunction
                            
    1              0.000002 function! s:select_by_index(index, insert) abort
                              let lnum = a:index == -1 ? 0 : s:index_to_lnum(a:index)
                              call s:set_cursor(s:pum_winid, lnum)
                              if !s:is_vim
                                call coc#float#nvim_scrollbar(s:pum_winid)
                              endif
                              if a:insert
                                let s:inserted = 1
                                if a:index < 0
                                  let input = getwinvar(s:pum_winid, 'input', '')
                                  call s:insert_word(input, 0)
                                  call coc#pum#close_detail()
                                else
                                  let words = getwinvar(s:pum_winid, 'words', [])
                                  let word = get(words, a:index, '')
                                  call s:insert_word(word, 0)
                                endif
                                " The current line is wrong when use feedkeys.
                                if !s:is_vim
                                  doautocmd <nomodeline> TextChangedP
                                endif
                              endif
                              call s:on_pum_change(1)
                            endfunction
                            
    1              0.000003 function! s:get_index(next) abort
                              if a:next
                                let index = s:pum_index + 1 == s:pum_size ? -1 : s:pum_index + 1
                              else
                                let index = s:pum_index == -1 ? s:pum_size - 1 : s:pum_index - 1
                              endif
                              return index
                            endfunction
                            
    1              0.000002 function! s:insert_word(word, finish) abort
                              if s:start_col != -1 && mode() ==# 'i'
                                " avoid auto wrap using 'textwidth'
                                if !a:finish && &textwidth > 0
                                  let textwidth = &textwidth
                                  noa setl textwidth=0
                                  call timer_start(0, { -> execute('noa setl textwidth='.textwidth)})
                                endif
                                " should not be used on finish to have correct line.
                                if s:is_vim && !a:finish
                                  call coc#pum#repalce(s:start_col + 1, a:word, 1)
                                else
                                  let saved_completeopt = &completeopt
                                  noa set completeopt=menu
                                  noa call complete(s:start_col + 1, [{ 'empty': v:true, 'word': a:word }])
                                  " exit complete state
                                  if s:hide_pum
                                    call feedkeys("\<C-x>\<C-z>", 'in')
                                  else
                                    let g:coc_disable_space_report = 1
                                    call feedkeys("\<space>\<bs>", 'in')
                                  endif
                                  execute 'noa set completeopt='.saved_completeopt
                                endif
                              endif
                            endfunction
                            
                            " Replace from col to cursor col with new characters
    1              0.000003 function! coc#pum#repalce(col, insert, ...) abort
                              let insert = a:insert
                              let curr = getline('.')
                              let removed = strpart(curr, a:col - 1, col('.') - a:col)
                              let n = strchars(removed)
                              let start = coc#string#common_start(insert, removed)
                              let event = get(a:, 1, 0)
                              if start > 0
                                let n = n - start
                                let insert = strcharpart(a:insert, start)
                                if empty(insert) && n == 0 && !event
                                  let n = 1
                                  let insert = coc#string#last_character(a:insert)
                                endif
                              endif
                              let keys = repeat("\<bs>", n).insert
                              if len(keys)
                                if event
                                  let previous =strpart(curr, 0, a:col - 1)
                                  call coc#rpc#notify('PumInsert', [previous.a:insert])
                                  let g:coc_feeding_keys = 1
                                endif
                                call feedkeys(keys, 'int')
                              endif
                            endfunction
                            
                            " create or update pum with lines, CompleteOption and config.
                            " return winid & dimension
    1              0.000002 function! coc#pum#create(lines, opt, config) abort
                              if mode() !=# 'i' || a:opt['line'] != line('.')
                                return
                              endif
                              let len = col('.') - a:opt['col'] - 1
                              if len < 0
                                return
                              endif
                              let input = len == 0 ? '' : strpart(getline('.'), a:opt['col'], len)
                              if input !=# a:opt['input']
                                return
                              endif
                              let config = s:get_pum_dimension(a:lines, a:opt['col'], a:config)
                              if empty(config)
                                return
                              endif
                              let s:reversed = get(a:config, 'reverse', 0) && config['row'] < 0
                              let s:virtual_text = s:virtual_text_support && a:opt['virtualText']
                              let s:pum_size = len(a:lines)
                              let s:pum_index = a:opt['index']
                              let lnum = s:index_to_lnum(s:pum_index)
                              call extend(config, {
                                    \ 'lines': s:reversed ? reverse(copy(a:lines)) : a:lines,
                                    \ 'relative': 'cursor',
                                    \ 'nopad': 1,
                                    \ 'cursorline': 1,
                                    \ 'index': lnum - 1,
                                    \ 'focusable': v:false
                                    \ })
                              call extend(config, coc#dict#pick(a:config, ['highlight', 'rounded', 'highlights', 'winblend', 'shadow', 'border', 'borderhighlight']))
                              if s:reversed
                                for item in config['highlights']
                                  let item['lnum'] = s:pum_size - item['lnum'] - 1
                                endfor
                              endif
                              if empty(get(config, 'winblend', 0)) && exists('&pumblend')
                                let config['winblend'] = &pumblend
                              endif
                              let result =  coc#float#create_float_win(s:pum_winid, s:pum_bufnr, config)
                              if empty(result)
                                return
                              endif
                              let s:inserted = 0
                              let s:pum_winid = result[0]
                              let s:pum_bufnr = result[1]
                              let s:start_col = a:opt['startcol']
                              call setwinvar(s:pum_winid, 'above', config['row'] < 0)
                              let firstline = s:get_firstline(lnum, s:pum_size, config['height'])
                              if s:is_vim
                                call popup_setoptions(s:pum_winid, { 'firstline': firstline })
                              else
                                call coc#compat#execute(s:pum_winid, 'call winrestview({"lnum":'.lnum.',"topline":'.firstline.'})')
                              endif
                              call coc#dialog#place_sign(s:pum_bufnr, s:pum_index == -1 ? 0 : lnum)
                              " content before col and content after cursor
                              let linetext = getline('.')
                              let parts = [strpart(linetext, 0, s:start_col), strpart(linetext, col('.') - 1)]
                              let input = strpart(getline('.'), s:start_col, col('.') - 1 - s:start_col)
                              call setwinvar(s:pum_winid, 'input', input)
                              call setwinvar(s:pum_winid, 'parts', parts)
                              call setwinvar(s:pum_winid, 'words', a:opt['words'])
                              call setwinvar(s:pum_winid, 'kind', 'pum')
                              if !s:is_vim
                                if s:pum_size > config['height']
                                  redraw
                                  call coc#float#nvim_scrollbar(s:pum_winid)
                                else
                                  call coc#float#close_related(s:pum_winid, 'scrollbar')
                                endif
                              endif
                              call s:on_pum_change(0)
                            endfunction
                            
    1              0.000004 function! s:save_indentkeys() abort
                              let bufnr = bufnr('%')
                              if !empty(&indentexpr) && get(s:saved_indenetkeys, 0, 0) != bufnr
                                let s:saved_indenetkeys = [bufnr, &indentkeys]
                                execute 'setl indentkeys='
                              endif
                            endfunction
                            
    1              0.000002 function! s:get_firstline(lnum, total, height) abort
                              if a:lnum <= a:height
                                return 1
                              endif
                              return min([a:total - a:height + 1, a:lnum  - (a:height*2/3)])
                            endfunction
                            
    1              0.000001 function! s:on_pum_change(move) abort
                              if s:virtual_text
                                if s:inserted
                                  call s:clear_virtual_text()
                                else
                                  call s:insert_virtual_text()
                                endif
                              endif
                              let ev = extend(coc#pum#info(), {'move': a:move ? v:true : v:false})
                              call coc#rpc#notify('CocAutocmd', ['MenuPopupChanged', ev, win_screenpos(winnr())[0] + winline() - 2])
                            endfunction
                            
    1              0.000001 function! s:index_to_lnum(index) abort
                              if s:reversed
                                if a:index <= 0
                                  return s:pum_size
                                endif
                                return s:pum_size - a:index
                              endif
                              return max([1, a:index + 1])
                            endfunction
                            
    1              0.000002 function! s:get_pum_dimension(lines, col, config) abort
                              let linecount = len(a:lines)
                              let [lineIdx, colIdx] = coc#cursor#screen_pos()
                              let bh = empty(get(a:config, 'border', [])) ? 0 : 2
                              let columns = &columns
                              let pumwidth = max([15, exists('&pumwidth') ? &pumwidth : 0])
                              let width = min([columns, max([pumwidth, a:config['width']])])
                              let vh = &lines - &cmdheight - 1 - !empty(&tabline)
                              if vh <= 0
                                return v:null
                              endif
                              let pumheight = empty(&pumheight) ? vh : &pumheight
                              let showTop = getwinvar(s:pum_winid, 'above', v:null)
                              if type(showTop) != v:t_number
                                if vh - lineIdx - bh - 1 < min([pumheight, linecount]) && vh - lineIdx < min([10, vh/2])
                                  let showTop = 1
                                else
                                  let showTop = 0
                                endif
                              endif
                              let height = showTop ? min([lineIdx - bh - !empty(&tabline), linecount, pumheight]) : min([vh - lineIdx - bh - 1, linecount, pumheight])
                              if height <= 0
                                return v:null
                              endif
                              " should use strdiplaywidth here
                              let text = strpart(getline('.'), a:col, col('.') - 1 - a:col)
                              let col = - strdisplaywidth(text, a:col) - 1
                              let row = showTop ? - height : 1
                              let delta = colIdx + col
                              if width > pumwidth && delta + width > columns
                                let width = max([columns - delta, pumwidth])
                              endif
                              if delta < 0
                                let col = col - delta
                              elseif delta + width > columns
                                let col = max([-colIdx, col - (delta + width - columns)])
                              endif
                              return {
                                    \ 'row': row,
                                    \ 'col': col,
                                    \ 'width': width,
                                    \ 'height': height
                                    \ }
                            endfunction
                            
                            " can't use coc#dialog#set_cursor on vim8, don't know why
    1              0.000001 function! s:set_cursor(winid, line) abort
                              if s:is_vim
                                let pos = popup_getpos(a:winid)
                                let core_height = pos['core_height']
                                let lastline = pos['firstline'] + core_height - 1
                                if a:line > lastline
                                  call popup_setoptions(a:winid, {
                                        \ 'firstline': pos['firstline'] + a:line - lastline,
                                        \ })
                                elseif a:line < pos['firstline']
                                  if s:reversed
                                    call popup_setoptions(a:winid, {
                                          \ 'firstline': a:line == 0 ? s:pum_size - core_height + 1 : a:line - core_height + 1,
                                          \ })
                                  else
                                    call popup_setoptions(a:winid, {
                                          \ 'firstline': max([1, a:line]),
                                          \ })
                                  endif
                                endif
                              endif
                              call s:select_line(a:winid, a:line)
                            endfunction
                            
    1              0.000005 function! s:select_line(winid, line) abort
                              let s:pum_index = s:reversed ? (a:line == 0 ? -1 : s:pum_size - a:line) : a:line - 1
                              let lnum = s:reversed ? (a:line == 0 ? s:pum_size : a:line) : max([1, a:line])
                              if s:is_vim
                                call coc#compat#execute(a:winid, 'exe '.lnum)
                              else
                                call nvim_win_set_cursor(a:winid, [lnum, 0])
                              endif
                              call coc#dialog#place_sign(s:pum_bufnr, a:line == 0 ? 0 : lnum)
                            endfunction
                            
    1              0.000002 function! s:insert_virtual_text() abort
                              let bufnr = bufnr('%')
                              if !s:virtual_text || s:pum_index < 0
                                call s:clear_virtual_text()
                              else
                                " Check if could create
                                let insert = ''
                                let line = line('.') - 1
                                let words = getwinvar(s:pum_winid, 'words', [])
                                let word = get(words, s:pum_index, '')
                                let input = strpart(getline('.'), s:start_col, col('.') - 1 - s:start_col)
                                if strlen(word) > strlen(input) && strcharpart(word, 0, strchars(input)) ==# input
                                  let insert = strcharpart(word, strchars(input))
                                endif
                                if s:is_vim
                                  if s:prop_id != 0
                                    call prop_remove({'id': s:prop_id}, line + 1, line + 1)
                                  endif
                                  if !empty(insert)
                                    let s:prop_id = prop_add(line + 1, col('.'), {
                                        \ 'text': insert,
                                        \ 'type': 'CocPumVirtualText'
                                        \ })
                                  endif
                                else
                                  call nvim_buf_clear_namespace(bufnr, s:virtual_text_ns, line, line + 1)
                                  if !empty(insert)
                                    let opts = {
                                        \ 'hl_mode': 'combine',
                                        \ 'virt_text': [[insert, 'CocPumVirtualText']],
                                        \ 'virt_text_pos': 'overlay',
                                        \ 'virt_text_win_col': virtcol('.') - 1,
                                        \ }
                                    call nvim_buf_set_extmark(bufnr, s:virtual_text_ns, line, col('.') - 1, opts)
                                  endif
                                endif
                              endif
                            endfunction
                            
    1              0.000002 function! s:clear_virtual_text() abort
                              if s:virtual_text_support
                                if s:is_vim
                                  if s:prop_id != 0
                                    call prop_remove({'id': s:prop_id})
                                  endif
                                else
                                  call nvim_buf_clear_namespace(bufnr('%'), s:virtual_text_ns, 0, -1)
                                endif
                              endif
                            endfunction
                            
    1              0.000002 function! s:close_pum() abort
                              call s:clear_virtual_text()
                              call coc#float#close(s:pum_winid, 1)
                              let s:pum_winid = 0
                              let s:pum_size = 0
                              let winid = coc#float#get_float_by_kind('pumdetail')
                              if winid
                                call coc#float#close(winid, 1)
                              endif
                              call s:restore_indentkeys()
                            endfunction
                            
    1              0.000002 function! s:restore_indentkeys() abort
                              if get(s:saved_indenetkeys, 0, 0) == bufnr('%')
                                call setbufvar(s:saved_indenetkeys[0], '&indentkeys', get(s:saved_indenetkeys, 1, ''))
                                let s:saved_indenetkeys = []
                              endif
                            endfunction

SCRIPT  /Users/elanmedoff/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/dict.vim
Sourced 1 time
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000003 scriptencoding utf-8
                            
    1              0.000003 function! coc#dict#equal(one, two) abort
                              for key in keys(a:one)
                                if a:one[key] != a:two[key]
                                  return 0
                                endif
                              endfor
                              return 1
                            endfunction
                            
                            " Return new dict with keys removed
    1              0.000001 function! coc#dict#omit(dict, keys) abort
                              let res = {}
                              for key in keys(a:dict)
                                if index(a:keys, key) == -1
                                  let res[key] = a:dict[key]
                                endif
                              endfor
                              return res
                            endfunction
                            
                            " Return new dict with keys only
    1              0.000001 function! coc#dict#pick(dict, keys) abort
                              let res = {}
                              for key in keys(a:dict)
                                if index(a:keys, key) != -1
                                  let res[key] = a:dict[key]
                                endif
                              endfor
                              return res
                            endfunction

SCRIPT  /Users/elanmedoff/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/compat.vim
Sourced 1 time
Total time:   0.000134
 Self time:   0.000134

count  total (s)   self (s)
    1              0.000003 scriptencoding utf-8
    1              0.000005 let s:is_vim = !has('nvim')
                            
                            " first window id for bufnr
                            " builtin bufwinid returns window of current tab only
    1              0.000002 function! coc#compat#buf_win_id(bufnr) abort
                              let info = filter(getwininfo(), 'v:val["bufnr"] =='.a:bufnr)
                              if empty(info)
                                return -1
                              endif
                              return info[0]['winid']
                            endfunction
                            
    1              0.000002 function! coc#compat#buf_set_lines(bufnr, start, end, replacement) abort
                              if s:is_vim
                                call coc#api#exec('buf_set_lines', [a:bufnr, a:start, a:end, 0, a:replacement])
                              else
                                call nvim_buf_set_lines(a:bufnr, a:start, a:end, 0, a:replacement)
                              endif
                            endfunction
                            
    1              0.000001 function! coc#compat#buf_line_count(bufnr) abort
                              if exists('*nvim_buf_line_count')
                                return nvim_buf_line_count(a:bufnr)
                              endif
                              if bufnr('%') == a:bufnr
                                return line('$')
                              endif
                              if exists('*getbufinfo')
                                let info = getbufinfo(a:bufnr)
                                if empty(info)
                                  return 0
                                endif
                                " vim 8.1 has getbufinfo but no linecount
                                if has_key(info[0], 'linecount')
                                  return info[0]['linecount']
                                endif
                              endif
                              if exists('*getbufline')
                                let lines = getbufline(a:bufnr, 1, '$')
                                return len(lines)
                              endif
                              let curr = bufnr('%')
                              execute 'noa buffer '.a:bufnr
                              let n = line('$')
                              execute 'noa buffer '.curr
                              return n
                            endfunction
                            
    1              0.000001 function! coc#compat#prepend_lines(bufnr, replacement) abort
                              if exists('*appendbufline')
                                call appendbufline(a:bufnr, 0, a:replacement)
                              elseif !s:is_vim
                                call nvim_buf_set_lines(a:bufnr, 0, 0, 0, a:replacement)
                              else
                                throw 'appendbufline() required for prepend lines.'
                              endif
                            endfunction
                            
    1              0.000001 function! coc#compat#win_is_valid(winid) abort
                              if exists('*nvim_win_is_valid')
                                return nvim_win_is_valid(a:winid)
                              endif
                              return !empty(getwininfo(a:winid))
                            endfunction
                            
                            " clear matches by window id, not throw on none exists window.
                            " may not work on vim < 8.1.1084 & neovim < 0.4.0
    1              0.000001 function! coc#compat#clear_matches(winid) abort
                              if !coc#compat#win_is_valid(a:winid)
                                return
                              endif
                              let curr = win_getid()
                              if curr == a:winid
                                call clearmatches()
                                return
                              endif
                              if s:is_vim
                                if has('patch-8.1.1084')
                                  call clearmatches(a:winid)
                                endif
                              else
                                if exists('*nvim_set_current_win')
                                  noa call nvim_set_current_win(a:winid)
                                  call clearmatches()
                                  noa call nvim_set_current_win(curr)
                                endif
                              endif
                            endfunction
                            
    1              0.000002 function! coc#compat#matchaddpos(group, pos, priority, winid) abort
                              let curr = win_getid()
                              if curr == a:winid
                                call matchaddpos(a:group, a:pos, a:priority, -1)
                              else
                                if s:is_vim
                                  if has('patch-8.1.0218')
                                    call matchaddpos(a:group, a:pos, a:priority, -1, {'window': a:winid})
                                  endif
                                else
                                  call matchaddpos(a:group, a:pos, a:priority, -1, {'window': a:winid})
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! coc#compat#buf_del_var(bufnr, name) abort
                              if !bufloaded(a:bufnr)
                                return
                              endif
                              if exists('*nvim_buf_del_var')
                                silent! call nvim_buf_del_var(a:bufnr, a:name)
                              else
                                if a:bufnr == bufnr('%')
                                  execute 'unlet! b:'.a:name
                                elseif exists('*win_execute')
                                  let winid = coc#compat#buf_win_id(a:bufnr)
                                  if winid != -1
                                    call win_execute(winid, 'unlet! b:'.a:name)
                                  endif
                                endif
                              endif
                            endfunction
                            
                            " hlGroup, pos, priority
    1              0.000001 function! coc#compat#matchaddgroups(winid, groups) abort
                              for group in a:groups
                                call matchaddpos(group['hlGroup'], [group['pos']], group['priority'], -1, {'window': a:winid})
                              endfor
                            endfunction
                            
    1              0.000001 function! coc#compat#del_var(name) abort
                              if exists('*nvim_del_var')
                                silent! call nvim_del_var(a:name)
                              else
                                execute 'unlet! '.a:name
                              endif
                            endfunction
                            
                            " remove keymap for specific buffer
    1              0.000001 function! coc#compat#buf_del_keymap(bufnr, mode, lhs) abort
                              if !bufloaded(a:bufnr)
                                return
                              endif
                              if exists('*nvim_buf_del_keymap')
                                try
                                  call nvim_buf_del_keymap(a:bufnr, a:mode, a:lhs)
                                catch /^Vim\%((\a\+)\)\=:E5555/
                                  " ignore keymap doesn't exist
                                endtry
                                return
                              endif
                              try
                                call coc#api#exec('buf_del_keymap', [a:bufnr, a:mode, a:lhs])
                              catch /E31/
                                " ignore keymap doesn't exist
                              endtry
                            endfunction
                            
    1              0.000002 function! coc#compat#buf_add_keymap(bufnr, mode, lhs, rhs, opts) abort
                              if !bufloaded(a:bufnr)
                                return
                              endif
                              if exists('*nvim_buf_set_keymap')
                                call nvim_buf_set_keymap(a:bufnr, a:mode, a:lhs, a:rhs, a:opts)
                              else
                                call coc#api#exec('buf_set_keymap', [a:bufnr, a:mode, a:lhs, a:rhs, a:opts])
                              endif
                            endfunction
                            
                            " execute command or list of commands in window
    1              0.000001 function! coc#compat#execute(winid, command, ...) abort
                              if exists('*win_execute')
                                if type(a:command) == v:t_string
                                  keepalt call win_execute(a:winid, a:command, get(a:, 1, ''))
                                elseif type(a:command) == v:t_list
                                  keepalt call win_execute(a:winid, join(a:command, "\n"), get(a:, 1, ''))
                                endif
                              elseif has('nvim')
                                if !nvim_win_is_valid(a:winid)
                                  return
                                endif
                                let curr = nvim_get_current_win()
                                noa keepalt call nvim_set_current_win(a:winid)
                                if type(a:command) == v:t_string
                                  exe get(a:, 1, '').' '.a:command
                                elseif type(a:command) == v:t_list
                                  for cmd in a:command
                                    exe get(a:, 1, '').' '.cmd
                                  endfor
                                endif
                                noa keepalt call nvim_set_current_win(curr)
                              else
                                throw 'win_execute does not exist, please upgrade vim.'
                              endif
                            endfunc
                            
    1              0.000001 function! coc#compat#trim(str)
                              if exists('*trim')
                                return trim(a:str)
                              endif
                              " TODO trim from beginning
                              return substitute(a:str, '\s\+$', '', '')
                            endfunction

SCRIPT  /Users/elanmedoff/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/notify.vim
Sourced 1 time
Total time:   0.000898
 Self time:   0.000898

count  total (s)   self (s)
    1              0.000008 scriptencoding utf-8
    1              0.000013 let s:is_vim = !has('nvim')
    1              0.000008 let s:utf = has('nvim') || &encoding =~# '^utf'
    1              0.000012 let s:error_icon = get(g:, 'coc_notify_error_icon', s:utf ? "\uf057" : 'E')
    1              0.000008 let s:warning_icon = get(g:, 'coc_notify_warning_icon', s:utf ? "\u26a0" : 'W')
    1              0.000007 let s:info_icon = get(g:, 'coc_notify_info_icon', s:utf ? "\uf06a" : 'I')
    1              0.000008 let s:interval = get(g:, 'coc_notify_interval', s:is_vim ? 50 : 20)
    1              0.000004 let s:phl = 'CocNotificationProgress'
    1              0.000004 let s:progress_char = '─'
    1              0.000006 let s:duration = 300.0
    1              0.000004 let s:winids = []
                            
                            " Valid notify winids on current tab
    1              0.000005 function! coc#notify#win_list() abort
                              call filter(s:winids, 'coc#float#valid(v:val)')
                              return filter(copy(s:winids), '!empty(getwinvar(v:val,"float"))')
                            endfunction
                            
    1              0.000004 function! coc#notify#close_all() abort
                              for winid in coc#notify#win_list()
                                call coc#notify#close(winid)
                              endfor
                            endfunction
                            
                            " Do action for winid or first notify window with actions.
    1              0.000003 function! coc#notify#do_action(...) abort
                              let winids = a:0 > 0 ? a:000 : coc#notify#win_list()
                              for winid in winids
                                if coc#float#valid(winid) && getwinvar(winid, 'closing', 0) != 1
                                  let actions = getwinvar(winid, 'actions', [])
                                  if !empty(actions)
                                    let items = map(copy(actions), '(v:key + 1).". ".v:val')
                                    let msg = join(getbufline(winbufnr(winid), 1, '$'), ' ')
                                    call coc#ui#quickpick(msg, items, {err, res -> s:on_action(err, res, winid) })
                                    break
                                  endif
                                endif
                              endfor
                            endfunction
                            
                            " Copy notification contents
    1              0.000003 function! coc#notify#copy() abort
                              let lines = []
                              for winid in coc#notify#win_list()
                                let key = getwinvar(winid, 'key', v:null)
                                if type(key) == v:t_string
                                  call extend(lines, json_decode(key)['lines'])
                                endif
                              endfor
                              if empty(lines)
                                echohl WarningMsg | echon 'No content to copy' | echohl None
                                return
                              endif
                              call setreg('*', join(lines, "\n"))
                            endfunction
                            
                            " Show source name in window
    1              0.000003 function! coc#notify#show_sources() abort
                              if !exists('*getbufline') || !exists('*appendbufline')
                                throw "getbufline and appendbufline functions required, please upgrade your vim."
                              endif
                              let winids = filter(coc#notify#win_list(), 'coc#window#get_var(v:val,"closing") != 1')
                              for winid in winids
                                let key = getwinvar(winid, 'key', v:null)
                                if type(key) == v:t_string
                                  let bufnr = winbufnr(winid)
                                  let obj = json_decode(key)
                                  let sourcename = get(obj, 'source', '')
                                  let lnum = get(obj, 'kind', '') ==# 'progress' ? 1 : 0
                                  let content = get(getbufline(bufnr, lnum + 1), 0, '')
                                  if empty(sourcename) || content ==# sourcename
                                    continue
                                  endif
                                  call appendbufline(bufnr, lnum, sourcename)
                                  call coc#highlight#add_highlight(bufnr, -1, 'Title', lnum, 0, -1)
                                  call coc#float#scroll_win(winid, 0, 1)
                                endif
                              endfor
                              redra
                            endfunction
                            
    1              0.000004 function! coc#notify#close_by_source(source) abort
                              let winids = filter(coc#notify#win_list(), 'coc#window#get_var(v:val,"closing") != 1')
                              for winid in winids
                                let key = getwinvar(winid, 'key', v:null)
                                if type(key) == v:t_string
                                  let obj = json_decode(key)
                                  if get(obj, 'source', '') ==# a:source
                                    call coc#notify#close(winid)
                                  endif
                                endif
                              endfor
                            endfunction
                            
                            " Cancel auto hide
    1              0.000003 function! coc#notify#keep() abort
                              for winid in coc#notify#win_list()
                                call s:cancel(winid, 'close_timer')
                              endfor
                            endfunction
                            
                            " borderhighlight - border highlight [string]
                            " maxWidth - max content width, default 60 [number]
                            " minWidth - minimal width [number]
                            " maxHeight - max content height, default 10 [number]
                            " highlight - default highlight [string]
                            " winblend - winblend [number]
                            " timeout - auto close timeout, default 5000 [number]
                            " title - title text
                            " marginRight - margin right, default 10 [number]
                            " focusable - focusable [number]
                            " source -  source name [string]
                            " kind - kind for create icon [string]
                            " actions - action names [string[]]
                            " close - close button [boolean]
    1              0.000004 function! coc#notify#create(lines, config) abort
                              let actions = get(a:config, 'actions', [])
                              let key = json_encode(extend({'lines': a:lines}, a:config))
                              let winid = s:find_win(key)
                              let kind = get(a:config, 'kind', '')
                              let row = 0
                              if winid != -1
                                let row = getwinvar(winid, 'top', 0)
                                call filter(s:winids, 'v:val != '.winid)
                                call coc#float#close(winid, 1)
                                let winid = v:null
                              endif
                              let opts = coc#dict#pick(a:config, ['highlight', 'borderhighlight', 'focusable', 'shadow', 'close'])
                              let border = has_key(opts, 'borderhighlight') ? [1, 1, 1, 1] : []
                              let icon = s:get_icon(kind, get(a:config, 'highlight', 'CocFloating'))
                              let margin = get(a:config, 'marginRight', 10)
                              let maxWidth = min([&columns - margin - 2,  get(a:config, 'maxWidth', 80)])
                              if maxWidth <= 0
                                throw 'No enough spaces for notification'
                              endif
                              let lines = map(copy(a:lines), 'tr(v:val, "\t", " ")')
                              if has_key(a:config, 'title')
                                if !empty(border)
                                  let opts['title'] = a:config['title']
                                else
                                  let lines = [a:config['title']] + lines
                                endif
                              endif
                              let width = max(map(copy(lines), 'strwidth(v:val)')) + (empty(icon) ? 1 : 3)
                              if width > maxWidth
                                let lines = coc#string#reflow(lines, maxWidth)
                                let width = max(map(copy(lines), 'strwidth(v:val)')) + (empty(icon) ? 1 : 3)
                              endif
                              let highlights = []
                              if !empty(icon)
                                let ic = icon['text']
                                if empty(lines)
                                  call add(lines, ic)
                                else
                                  let lines[0] = ic.' '.lines[0]
                                endif
                                call add(highlights, {'lnum': 0, 'hlGroup': icon['hl'], 'colStart': 0, 'colEnd': strlen(ic)})
                              endif
                              let actionText = join(actions, ' ')
                              call map(lines, 'v:key == 0 ? v:val : repeat(" ", '.(empty(icon) ? 0 : 2).').v:val')
                              let minWidth = get(a:config, 'minWidth', kind ==# 'progress' ? 30 : 10)
                              let width = max(extend(map(lines + [get(opts, 'title', '').'   '], 'strwidth(v:val)'), [minWidth, strwidth(actionText) + 1]))
                              let width = min([maxWidth, width])
                              let height = min([get(a:config, 'maxHeight', 3), len(lines)])
                              if kind ==# 'progress'
                                let lines = [repeat(s:progress_char, width)] + lines
                                let height = height + 1
                              endif
                              if !empty(actions)
                                let before = max([width - strwidth(actionText), 0])
                                let lines = lines + [repeat(' ', before).actionText]
                                let height = height + 1
                                call s:add_action_highlights(before, height - 1, highlights, actions)
                              endif
                              if row == 0
                                let wintop = coc#notify#get_top()
                                let row = wintop - height - (empty(border) ? 0 : 2) - 1
                                if !s:is_vim && !empty(border)
                                  let row = row + 1
                                endif
                              endif
                              let col = &columns - margin - width
                              if s:is_vim && !empty(border)
                                let col = col - 2
                              endif
                              let winblend = 60
                              " Avoid animate for transparent background.
                              if get(a:config, 'winblend', 30) == 0 && empty(synIDattr(synIDtrans(hlID(get(opts, 'highlight', 'CocFloating'))), 'bg', 'gui'))
                                let winblend = 0
                              endif
                              call extend(opts, {
                                  \ 'relative': 'editor',
                                  \ 'width': width,
                                  \ 'height': height,
                                  \ 'col': col,
                                  \ 'row': row + 1,
                                  \ 'lines': lines,
                                  \ 'rounded': 1,
                                  \ 'highlights': highlights,
                                  \ 'winblend': winblend,
                                  \ 'border': border,
                                  \ })
                              let result = coc#float#create_float_win(0, 0, opts)
                              if empty(result)
                                throw 'Unable to create notify window'
                              endif
                              let winid = result[0]
                              let bufnr = result[1]
                              call setwinvar(winid, 'right', 1)
                              call setwinvar(winid, 'kind', 'notification')
                              call setwinvar(winid, 'top', row)
                              call setwinvar(winid, 'key', key)
                              call setwinvar(winid, 'actions', actions)
                              call setwinvar(winid, 'source', get(a:config, 'source', ''))
                              call setwinvar(winid, 'borders', !empty(border))
                              call coc#float#nvim_scrollbar(winid)
                              call add(s:winids, winid)
                              let from = {'row': opts['row'], 'winblend': opts['winblend']}
                              let to = {'row': row, 'winblend': get(a:config, 'winblend', 30)}
                              call timer_start(s:interval, { -> s:animate(winid, from, to, 0)})
                              if kind ==# 'progress'
                                call timer_start(s:interval, { -> s:progress(winid, width, 0, -1)})
                              endif
                              if !s:is_vim
                                call coc#compat#buf_add_keymap(bufnr, 'n', '<LeftRelease>', ':call coc#notify#nvim_click('.winid.')<CR>', {
                                    \ 'silent': v:true,
                                    \ 'nowait': v:true
                                    \ })
                              endif
                              " Enable auto close
                              if empty(actions) && kind !=# 'progress'
                                let timer = timer_start(get(a:config, 'timeout', 10000), { -> coc#notify#close(winid)})
                                call setwinvar(winid, 'close_timer', timer)
                              endif
                              return [winid, bufnr]
                            endfunction
                            
    1              0.000004 function! coc#notify#nvim_click(winid) abort
                              if getwinvar(a:winid, 'closing', 0)
                                return
                              endif
                              call s:cancel(a:winid, 'close_timer')
                              let actions = getwinvar(a:winid, 'actions', [])
                              if !empty(actions)
                                let character = strpart(getline('.'), col('.') - 1, 1)
                                if character =~# '^\k'
                                  let word = expand('<cword>')
                                  let idx = index(actions, word)
                                  if idx != -1
                                    call coc#rpc#notify('FloatBtnClick', [winbufnr(a:winid), idx])
                                    call coc#notify#close(a:winid)
                                  endif
                                endif
                              endif
                            endfunction
                            
    1              0.000003 function! coc#notify#on_close(winid) abort
                              if index(s:winids, a:winid) >= 0
                                call filter(s:winids, 'v:val != '.a:winid)
                                call coc#notify#reflow()
                              endif
                            endfunction
                            
    1              0.000003 function! coc#notify#get_top() abort
                              let mintop = min(map(coc#notify#win_list(), 'coc#notify#get_win_top(v:val)'))
                              if mintop != 0
                                return mintop
                              endif
                              return &lines - &cmdheight - (&laststatus == 0 ? 0 : 1 )
                            endfunction
                            
    1              0.000003 function! coc#notify#get_win_top(winid) abort
                              let row = getwinvar(a:winid, 'top', 0)
                              if row == 0
                                return row
                              endif
                              return row - (s:is_vim ? 0 : getwinvar(a:winid, 'borders', 0))
                            endfunction
                            
                            " Close with timer
    1              0.000003 function! coc#notify#close(winid) abort
                              if !coc#float#valid(a:winid) || coc#window#get_var(a:winid, 'closing', 0) == 1
                                return
                              endif
                              if !coc#window#visible(a:winid)
                                call coc#float#close(a:winid, 1)
                                return
                              endif
                              let row = coc#window#get_var(a:winid, 'top')
                              if type(row) != v:t_number
                                call coc#float#close(a:winid)
                                return
                              endif
                              call coc#window#set_var(a:winid, 'closing', 1)
                              call s:cancel(a:winid)
                              let winblend = coc#window#get_var(a:winid, 'winblend', 0)
                              let curr = s:is_vim ? {'row': row} : {'winblend': winblend}
                              let dest = s:is_vim ? {'row': row + 1} : {'winblend': winblend == 0 ? 0 : 60}
                              call s:animate(a:winid, curr, dest, 0, 1)
                            endfunction
                            
    1              0.000008 function! s:add_action_highlights(before, lnum, highlights, actions) abort
                              let colStart = a:before
                              for text in a:actions
                                let w = strwidth(text)
                                call add(a:highlights, {
                                    \ 'lnum': a:lnum,
                                    \ 'hlGroup': 'CocNotificationButton',
                                    \ 'colStart': colStart,
                                    \ 'colEnd': colStart + w
                                    \ })
                                let colStart = colStart + w + 1
                              endfor
                            endfunction
                            
    1              0.000004 function! s:on_action(err, idx, winid) abort
                              if !empty(a:err)
                                throw a:err
                              endif
                              if a:idx > 0
                                call coc#rpc#notify('FloatBtnClick', [winbufnr(a:winid), a:idx - 1])
                                call coc#notify#close(a:winid)
                              endif
                            endfunction
                            
    1              0.000003 function! s:cancel(winid, ...) abort
                              let name = get(a:, 1, 'timer')
                              let timer = coc#window#get_var(a:winid, name)
                              if !empty(timer)
                                call timer_stop(timer)
                                call coc#window#set_var(a:winid, name, v:null)
                              endif
                            endfunction
                            
    1              0.000005 function! s:progress(winid, total, curr, index) abort
                              if !coc#float#valid(a:winid)
                                return
                              endif
                              if coc#window#visible(a:winid)
                                let total = a:total
                                let idx = float2nr(a:curr/5.0)%total
                                let option = coc#float#get_options(a:winid)
                                let width = option['width']
                                if idx != a:index
                                  " update percent & message
                                  let bufnr = winbufnr(a:winid)
                                  let percent = coc#window#get_var(a:winid, 'percent')
                                  let lines = []
                                  if !empty(percent)
                                    let line = repeat(s:progress_char, width - 4).printf('%4s', percent)
                                    let total = width - 4
                                    call add(lines, line)
                                  else
                                    call add(lines, repeat(s:progress_char, width))
                                  endif
                                  let message = coc#window#get_var(a:winid, 'message')
                                  if !empty(message)
                                    let lines = lines + coc#string#reflow(split(message, '\v\r?\n'), width)
                                  endif
                                  if has('nvim')
                                    call nvim_buf_set_lines(bufnr, 0, -1, v:false, lines)
                                  else
                                    noa call setbufline(bufnr, 1, lines)
                                    noa call deletebufline(bufnr, len(lines) + 1, '$')
                                  endif
                                  let height = option['height']
                                  let delta = len(lines) - height
                                  if delta > 0 && height < 3
                                    call coc#float#change_height(a:winid, min([delta, 3 - height]))
                                    let tabnr = coc#window#tabnr(a:winid)
                                    call coc#notify#reflow(tabnr)
                                    if len(lines) > 3
                                      call coc#float#nvim_scrollbar(a:winid)
                                    endif
                                  endif
                                  let bytes = strlen(s:progress_char)
                                  call coc#highlight#clear_highlight(bufnr, -1, 0, 1)
                                  let colStart = bytes * idx
                                  if idx + 4 <= total
                                    let colEnd = bytes * (idx + 4)
                                    call coc#highlight#add_highlight(bufnr, -1, s:phl, 0, colStart, colEnd)
                                  else
                                    let colEnd = bytes * total
                                    call coc#highlight#add_highlight(bufnr, -1, s:phl, 0, colStart, colEnd)
                                    call coc#highlight#add_highlight(bufnr, -1, s:phl, 0, 0, bytes * (idx + 4 - total))
                                  endif
                                endif
                                call timer_start(s:interval, { -> s:progress(a:winid, total, a:curr + 1, idx)})
                              else
                                " Not block CursorHold event
                                call timer_start(&updatetime + 100, { -> s:progress(a:winid, a:total, a:curr, a:index)})
                              endif
                            endfunction
                            
                            " Optional row & winblend
    1              0.000004 function! s:config_win(winid, props) abort
                              let change_row = has_key(a:props, 'row')
                              if s:is_vim
                                if change_row
                                  call popup_move(a:winid, {'line': a:props['row'] + 1})
                                endif
                              else
                                if change_row
                                  let [row, column] = nvim_win_get_position(a:winid)
                                  call nvim_win_set_config(a:winid, {
                                      \ 'row': a:props['row'],
                                      \ 'col': column,
                                      \ 'relative': 'editor',
                                      \ })
                                  call s:nvim_move_related(a:winid, a:props['row'])
                                endif
                                call coc#float#nvim_set_winblend(a:winid, get(a:props, 'winblend', v:null))
                                call coc#float#nvim_refresh_scrollbar(a:winid)
                              endif
                            endfunction
                            
    1              0.000004 function! s:nvim_move_related(winid, row) abort
                              let winids = coc#window#get_var(a:winid, 'related')
                              if empty(winids)
                                return
                              endif
                              for winid in winids
                                if nvim_win_is_valid(winid)
                                  let [row, column] = nvim_win_get_position(winid)
                                  let delta = coc#window#get_var(winid, 'delta', 0)
                                  call nvim_win_set_config(winid, {
                                      \ 'row': a:row + delta,
                                      \ 'col': column,
                                      \ 'relative': 'editor',
                                      \ })
                                endif
                              endfor
                            endfunction
                            
    1              0.000005 function! s:animate(winid, from, to, prev, ...) abort
                              if !coc#float#valid(a:winid)
                                return
                              endif
                              let curr = a:prev + s:interval
                              let percent = coc#math#min(curr / s:duration, 1)
                              let props = s:get_props(a:from, a:to, percent)
                              call s:config_win(a:winid, props)
                              let close = get(a:, 1, 0)
                              if percent < 1
                                call timer_start(s:interval, { -> s:animate(a:winid, a:from, a:to, curr, close)})
                              elseif close
                                call filter(s:winids, 'v:val != '.a:winid)
                                let tabnr = coc#window#tabnr(a:winid)
                                if tabnr != -1
                                  call coc#float#close(a:winid, 1)
                                  call coc#notify#reflow(tabnr)
                                endif
                              endif
                            endfunction
                            
    1              0.000003 function! coc#notify#reflow(...) abort
                              let tabnr = get(a:, 1, tabpagenr())
                              let winids = filter(copy(s:winids), 'coc#window#tabnr(v:val) == '.tabnr.' && coc#window#get_var(v:val,"closing") != 1')
                              if empty(winids)
                                return
                              endif
                              let animate = tabnr == tabpagenr()
                              let wins = map(copy(winids), {_, val -> {
                                    \ 'winid': val,
                                    \ 'row': coc#window#get_var(val,'top',0),
                                    \ 'top': coc#window#get_var(val,'top',0) - (s:is_vim ? 0 : coc#window#get_var(val, 'borders', 0)),
                                    \ 'height': coc#float#get_height(val),
                                    \ }})
                              call sort(wins, {a, b -> b['top'] - a['top']})
                              let bottom = &lines - &cmdheight - (&laststatus == 0 ? 0 : 1 )
                              let moved = 0
                              for item in wins
                                let winid = item['winid']
                                let delta = bottom - (item['top'] + item['height'] + 1)
                                if delta != 0
                                  call s:cancel(winid)
                                  let dest = item['row'] + delta
                                  call coc#window#set_var(winid, 'top', dest)
                                  if animate
                                    call s:move_win_timer(winid, {'row': item['row']}, {'row': dest}, 0)
                                  else
                                    call s:config_win(winid, {'row': dest})
                                  endif
                                  let moved = moved + delta
                                endif
                                let bottom = item['top'] + delta
                              endfor
                            endfunction
                            
    1              0.000009 function! s:move_win_timer(winid, from, to, curr) abort
                              if !coc#float#valid(a:winid)
                                return
                              endif
                              if coc#window#get_var(a:winid, 'closing', 0) == 1
                                return
                              endif
                              let percent = coc#math#min(a:curr / s:duration, 1)
                              let next = a:curr + s:interval
                              if a:curr > 0
                                call s:config_win(a:winid, s:get_props(a:from, a:to, percent))
                              endif
                              if percent < 1
                                let timer = timer_start(s:interval, { -> s:move_win_timer(a:winid, a:from, a:to, next)})
                                call coc#window#set_var(a:winid, 'timer', timer)
                              endif
                            endfunction
                            
    1              0.000003 function! s:find_win(key) abort
                              for winid in coc#notify#win_list()
                                if getwinvar(winid, 'key', '') ==# a:key
                                  return winid
                                endif
                              endfor
                              return -1
                            endfunction
                            
    1              0.000008 function! s:get_icon(kind, bg) abort
                              if a:kind ==# 'info'
                                return {'text': s:info_icon, 'hl': coc#highlight#compose_hlgroup('CocInfoSign', a:bg)}
                              endif
                              if a:kind ==# 'warning'
                                return {'text': s:warning_icon, 'hl': coc#highlight#compose_hlgroup('CocWarningSign', a:bg)}
                              endif
                              if a:kind ==# 'error'
                                return {'text': s:error_icon, 'hl': coc#highlight#compose_hlgroup('CocErrorSign', a:bg)}
                              endif
                              return v:null
                            endfunction
                            
                            " percent should be float
    1              0.000004 function! s:get_props(from, to, percent) abort
                              let obj = {}
                              for key in keys(a:from)
                                let changed = a:to[key] - a:from[key]
                                if !s:is_vim && key ==# 'row'
                                  " Could be float
                                  let obj[key] = a:from[key] + changed * a:percent
                                else
                                  let obj[key] = a:from[key] + float2nr(round(changed * a:percent))
                                endif
                              endfor
                              return obj
                            endfunction

SCRIPT  /usr/local/Cellar/neovim/HEAD-92760a7/share/nvim/runtime/ftplugin/typescriptreact.vim
Sourced 1 time
Total time:   0.001748
 Self time:   0.001558

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	TypeScript React
                            " Maintainer:	Doug Kearns <dougkearns@gmail.com>
                            " Last Change:	2020 Aug 09
                            
    1              0.000037 let s:match_words = ""
    1              0.000004 let s:undo_ftplugin = ""
                            
    1   0.000959   0.000769 runtime! ftplugin/typescript.vim
                            
    1              0.000007 let s:cpo_save = &cpo
    1              0.000009 set cpo-=C
                            
    1              0.000017 if exists("b:match_words")
                                let s:match_words = b:match_words
    1              0.000001 endif
    1              0.000005 if exists("b:undo_ftplugin")
    1              0.000005     let s:undo_ftplugin = b:undo_ftplugin
    1              0.000002 endif
                            
                            " Matchit configuration
    1              0.000005 if exists("loaded_matchit")
    1              0.000004     let b:match_ignorecase = 0
    1              0.000015     let b:match_words = s:match_words .
                            		\	'<:>,' .
                            		\	'<\@<=\([^ \t>/]\+\)\%(\s\+[^>]*\%([^/]>\|$\)\|>\|$\):<\@<=/\1>,' .
                            		\	'<\@<=\%([^ \t>/]\+\)\%(\s\+[^/>]*\|$\):/>'
    1              0.000001 endif
                            
    1              0.000006 let b:undo_ftplugin = "unlet! b:match_words b:match_ignorecase | " . s:undo_ftplugin
                            
    1              0.000013 let &cpo = s:cpo_save
    1              0.000039 unlet s:cpo_save

SCRIPT  /usr/local/Cellar/neovim/HEAD-92760a7/share/nvim/runtime/syntax/typescriptreact.vim
Sourced 1 time
Total time:   0.011996
 Self time:   0.002358

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     TypeScript with React (JSX)
                            " Maintainer:   Bram Moolenaar
                            " Last Change:	2019 Nov 30
                            " Based On:     Herrington Darkholme's yats.vim
                            " Changes:      See https:github.com/HerringtonDarkholme/yats.vim
                            " Credits:      See yats.vim on github
                            
    1              0.000034 if !exists("main_syntax")
    1              0.000010   if exists("b:current_syntax")
                                finish
    1              0.000003   endif
    1              0.000012   let main_syntax = 'typescriptreact'
    1              0.000003 endif
                            
    1              0.000018 let s:cpo_save = &cpo
    1              0.000024 set cpo&vim
                            
    1              0.000104 syntax region tsxTag
                                  \ start=+<\([^/!?<>="':]\+\)\@=+
                                  \ skip=+</[^ /!?<>"']\+>+
                                  \ end=+/\@<!>+
                                  \ end=+\(/>\)\@=+
                                  \ contained
                                  \ contains=tsxTagName,tsxIntrinsicTagName,tsxAttrib,tsxEscJs,
                                            \tsxCloseString,@tsxComment
                            
    1              0.000011 syntax match tsxTag /<>/ contained
                            
                            
                            " <tag></tag>
                            " s~~~~~~~~~e
                            " and self close tag
                            " <tag/>
                            " s~~~~e
                            " A big start regexp borrowed from https://git.io/vDyxc
    1              0.000083 syntax region tsxRegion
                                  \ start=+<\_s*\z([a-zA-Z1-9\$_-]\+\(\.\k\+\)*\)+
                                  \ skip=+<!--\_.\{-}-->+
                                  \ end=+</\_s*\z1>+
                                  \ matchgroup=tsxCloseString end=+/>+
                                  \ fold
                                  \ contains=tsxRegion,tsxCloseString,tsxCloseTag,tsxTag,tsxCommentInvalid,tsxFragment,tsxEscJs,@Spell
                                  \ keepend
                                  \ extend
                            
                            " <>   </>
                            " s~~~~~~e
                            " A big start regexp borrowed from https://git.io/vDyxc
    1              0.000068 syntax region tsxFragment
                                  \ start=+\(\((\|{\|}\|\[\|,\|&&\|||\|?\|:\|=\|=>\|\Wreturn\|^return\|\Wdefault\|^\|>\)\_s*\)\@<=<>+
                                  \ skip=+<!--\_.\{-}-->+
                                  \ end=+</>+
                                  \ fold
                                  \ contains=tsxRegion,tsxCloseString,tsxCloseTag,tsxTag,tsxCommentInvalid,tsxFragment,tsxEscJs,@Spell
                                  \ keepend
                                  \ extend
                            
                            " </tag>
                            " ~~~~~~
    1              0.000022 syntax match tsxCloseTag
                                  \ +</\_s*[^/!?<>"']\+>+
                                  \ contained
                                  \ contains=tsxTagName,tsxIntrinsicTagName
                            
    1              0.000007 syntax match tsxCloseTag +</>+ contained
                            
    1              0.000008 syntax match tsxCloseString
                                  \ +/>+
                                  \ contained
                            
                            " <!-- -->
                            " ~~~~~~~~
    1              0.000009 syntax match tsxCommentInvalid /<!--\_.\{-}-->/ display
                            
    1              0.000017 syntax region tsxBlockComment
                                \ contained
                                \ start="/\*"
                                \ end="\*/"
                            
    1              0.000012 syntax match tsxLineComment
                                \ "//.*$"
                                \ contained
                                \ display
                            
    1              0.000012 syntax cluster tsxComment contains=tsxBlockComment,tsxLineComment
                            
    1              0.000014 syntax match tsxEntity "&[^; \t]*;" contains=tsxEntityPunct
    1              0.000009 syntax match tsxEntityPunct contained "[&.;]"
                            
                            " <tag key={this.props.key}>
                            "  ~~~
    1              0.000022 syntax match tsxTagName
                                \ +[</]\_s*[^/!?<>"'* ]\++hs=s+1
                                \ contained
                                \ nextgroup=tsxAttrib
                                \ skipwhite
                                \ display
    1              0.000019 syntax match tsxIntrinsicTagName
                                \ +[</]\_s*[a-z1-9-]\++hs=s+1
                                \ contained
                                \ nextgroup=tsxAttrib
                                \ skipwhite
                                \ display
                            
                            " <tag key={this.props.key}>
                            "      ~~~
    1              0.000018 syntax match tsxAttrib
                                \ +[a-zA-Z_][-0-9a-zA-Z_]*+
                                \ nextgroup=tsxEqual skipwhite
                                \ contained
                                \ display
                            
                            " <tag id="sample">
                            "        ~
    1              0.000014 syntax match tsxEqual +=+ display contained
                              \ nextgroup=tsxString skipwhite
                            
                            " <tag id="sample">
                            "         s~~~~~~e
    1              0.000015 syntax region tsxString contained start=+"+ end=+"+ contains=tsxEntity,@Spell display
                            
                            " <tag key={this.props.key}>
                            "          s~~~~~~~~~~~~~~e
    1              0.000024 syntax region tsxEscJs
                                \ contained
                                \ contains=@typescriptValue,@tsxComment
                                \ matchgroup=typescriptBraces
                                \ start=+{+
                                \ end=+}+
                                \ extend
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""
                            " Source the part common with typescriptreact.vim
    1   0.010103   0.000466 source <sfile>:h/shared/typescriptcommon.vim
                            
                            
    1              0.000007 syntax cluster typescriptExpression add=tsxRegion,tsxFragment
                            
    1              0.000003 hi def link tsxTag htmlTag
    1              0.000002 hi def link tsxTagName Function
    1              0.000003 hi def link tsxIntrinsicTagName htmlTagName
    1              0.000002 hi def link tsxString String
    1              0.000003 hi def link tsxNameSpace Function
    1              0.000002 hi def link tsxCommentInvalid Error
    1              0.000002 hi def link tsxBlockComment Comment
    1              0.000002 hi def link tsxLineComment Comment
    1              0.000002 hi def link tsxAttrib Type
    1              0.000002 hi def link tsxEscJs tsxEscapeJs
    1              0.000002 hi def link tsxCloseTag htmlTag
    1              0.000002 hi def link tsxCloseString Identifier
                            
    1              0.000005 let b:current_syntax = "typescriptreact"
    1              0.000004 if main_syntax == 'typescriptreact'
    1              0.000003   unlet main_syntax
    1              0.000001 endif
                            
    1              0.000012 let &cpo = s:cpo_save
    1              0.000005 unlet s:cpo_save

FUNCTION  <SNR>58_add_highlights()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:1406
Called 2 times
Total time:   0.015960
 Self time:   0.000141

count  total (s)   self (s)
    2              0.000009   let codes = get(a:config, 'codes', [])
    2              0.000009   let highlights = get(a:config, 'highlights', [])
    2              0.000009   if empty(codes) && empty(highlights) && a:create
                                return
    2              0.000001   endif
    2              0.000009   let bgGroup = get(a:config, 'highlight', 'CocFloating')
    4              0.000009   for obj in codes
    2              0.000009     let hlGroup = get(obj, 'hlGroup', v:null)
    2              0.000006     if !empty(hlGroup)
                                  let obj['hlGroup'] = coc#highlight#compose_hlgroup(hlGroup, bgGroup)
    2              0.000002     endif
    4              0.000005   endfor
    2   0.015843   0.000024   call coc#highlight#add_highlights(a:winid, codes, highlights)

FUNCTION  coc#highlight#clear_match_group()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/highlight.vim:609
Called 28 times
Total time:   0.004054
 Self time:   0.004054

count  total (s)   self (s)
   28              0.000566   let winid = a:winid == 0 ? win_getid() : a:winid
   28              0.000544   if empty(getwininfo(winid))
                                " not valid
    1              0.000002     return
   27              0.000045   endif
   27              0.000092   if s:clear_match_by_window
   27              0.000702     let arr = filter(getmatches(winid), 'v:val["group"] =~# "'.a:match.'"')
   43              0.000135     for item in arr
   16              0.000106       call matchdelete(item['id'], winid)
   43              0.000090     endfor
                              else
                                let curr = win_getid()
                                let switch = exists('*nvim_set_current_win') && curr != winid
                                if switch
                                  noa call nvim_set_current_win(a:winid)
                                endif
                                if win_getid() == winid
                                  let arr = filter(getmatches(), 'v:val["group"] =~# "'.a:match.'"')
                                  for item in arr
                                    call matchdelete(item['id'])
                                  endfor
                                endif
                                if switch
                                  noa call nvim_set_current_win(curr)
                                endif
   27              0.000020   endif

FUNCTION  <SNR>70_start_moving()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-smoothie/autoload/smoothie.vim:66
Called 2 times
Total time:   0.000091
 Self time:   0.000055

count  total (s)   self (s)
    2   0.000053   0.000016   call s:ensure_subline_progress_view_initialized()
    2              0.000005   if !exists('s:timer_id')
    2              0.000024     let s:timer_id = timer_start(g:smoothie_update_interval, function('s:animation_tick'), {'repeat': -1})
    2              0.000006     let s:last_tick_time = reltime()
    2              0.000001   endif

FUNCTION  <SNR>58_close_win()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:1140
Called 2 times
Total time:   0.005599
 Self time:   0.000154

count  total (s)   self (s)
    2              0.000007   if a:winid <= 0
                                return
    2              0.000002   endif
                              " vim not throw for none exists winid
    2              0.000004   if s:is_vim
                                call popup_close(a:winid)
    2              0.000002   else
    2              0.000010     if nvim_win_is_valid(a:winid)
    2              0.000011       let prefix = a:noautocmd ? 'noa ': ''
    2   0.005540   0.000095       exe prefix.'call nvim_win_close('.a:winid.', 1)'
    2              0.000002     endif
    2              0.000001   endif

FUNCTION  <SNR>70_handle_leave_event()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-smoothie/autoload/smoothie.vim:101
Called 17 times
Total time:   0.000236
 Self time:   0.000236

count  total (s)   self (s)
   17              0.000092   if !empty(s:target_view)
                                call s:finish_moving()
   17              0.000018   endif

FUNCTION  <SNR>11_Remove_Matches()
    Defined: /usr/local/Cellar/neovim/HEAD-92760a7/share/nvim/runtime/plugin/matchparen.vim:197
Called 111 times
Total time:   0.001960
 Self time:   0.001960

count  total (s)   self (s)
  111              0.000865   if exists('w:paren_hl_on') && w:paren_hl_on
    6              0.000033     silent! call matchdelete(3)
    6              0.000021     let w:paren_hl_on = 0
  111              0.000151   endif

FUNCTION  coc#float#content_height()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:696
Called 2 times
Total time:   0.000236
 Self time:   0.000069

count  total (s)   self (s)
    2              0.000005   if !bufloaded(a:bufnr)
                                return 0
    2              0.000001   endif
    2              0.000002   if !a:wrap
                                return coc#compat#buf_line_count(a:bufnr)
    2              0.000001   endif
    2              0.000030   let lines = has('nvim') ? nvim_buf_get_lines(a:bufnr, 0, -1, 0) : getbufline(a:bufnr, 1, '$')
    2   0.000186   0.000019   return coc#string#content_height(lines, a:width)

FUNCTION  coc#client#get_channel()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/client.vim:168
Called 215 times
Total time:   0.002190
 Self time:   0.002190

count  total (s)   self (s)
  215              0.000509   if s:is_vim
                                return a:client['channel']
  215              0.000174   endif
  215              0.000661   return a:client['chan_id']

FUNCTION  coc#float#nvim_set_winblend()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:1022
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000006   if a:winblend is v:null
    2              0.000003     return
                              endif
                              call coc#window#set_var(a:winid, '&winblend', a:winblend)
                              for winid in coc#window#get_var(a:winid, 'related', [])
                                call coc#window#set_var(winid, '&winblend', a:winblend)
                              endfor

FUNCTION  <SNR>70_winrestview_optimized()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-smoothie/autoload/smoothie.vim:165
Called 31 times
Total time:   0.005763
 Self time:   0.005199

count  total (s)   self (s)
   93              0.000236   for key in ['topline', 'lnum']
   62              0.000328     let l:distance = a:new_view[key] - winsaveview()[key]
   62              0.000077     if l:distance == 0
   37              0.000080       continue
   25              0.000012     endif
   25              0.000034     if key ==# 'topline'
    3              0.000003       if l:distance > 0
    3              0.000177         execute 'normal! ' . l:distance . "\<C-E>"
                                  else
                                    execute 'normal! ' . -l:distance . "\<C-Y>"
    3              0.000006       endif
   22              0.000030     elseif key ==# 'lnum'
   22              0.000024       if l:distance > 0
   22              0.001719         execute 'normal! ' . l:distance . 'j'
                                  else
                                    execute 'normal! ' . -l:distance . 'k'
   22              0.000015       endif
   25              0.000013     endif
   56              0.000064   endfor
   31   0.001082   0.000519   let l:view_after_optimization = s:filter_dict(winsaveview(), keys(a:new_view))
   31              0.000059   let l:remaining_view_changes = {}
   93              0.000208   for [key, value] in items(view_after_optimization)
   62              0.000115     if a:new_view[key] != value
                                  let l:remaining_view_changes[key] = a:new_view[key]
   62              0.000036     endif
   93              0.000050   endfor
   31              0.000085   if !empty(l:remaining_view_changes)
                                call winrestview(l:remaining_view_changes)
   31              0.000019   endif

FUNCTION  coc#util#editor_infos()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/util.vim:420
Called 43 times
Total time:   0.020097
 Self time:   0.014844

count  total (s)   self (s)
   43              0.000298   let result = []
  151              0.001366   for info in getwininfo()
  108   0.006333   0.001705     if !coc#window#is_float(info['winid'])
   81              0.000360       let bufnr = info['bufnr']
   81              0.000753       let buftype = getbufvar(bufnr, '&buftype')
   81              0.000400       if buftype !=# '' && buftype !=# 'acwrite'
   43              0.000167         continue
   38              0.000052       endif
   38              0.000210       let bufname = bufname(bufnr)
   38   0.006688   0.006063       call add(result, { 'winid': info['winid'], 'bufnr': bufnr, 'tabid': coc#util#tabnr_id(info['tabnr']), 'fullpath': empty(bufname) ? '' : fnamemodify(bufname, ':p'), })
   65              0.000104     endif
  108              0.000510   endfor
   43              0.000123   return result

FUNCTION  coc#rpc#ready()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/rpc.vim:79
Called 217 times
Total time:   0.003040
 Self time:   0.003040

count  total (s)   self (s)
  217              0.001717   if empty(s:client) || s:client['running'] == 0
                                return 0
  217              0.000185   endif
  217              0.000390   return 1

FUNCTION  coc#notify#on_close()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/notify.vim:257
Called 3 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    3              0.000021   if index(s:winids, a:winid) >= 0
                                call filter(s:winids, 'v:val != '.a:winid)
                                call coc#notify#reflow()
    3              0.000004   endif

FUNCTION  <SNR>26_Autocmd()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/plugin/coc.vim:277
Called 170 times
Total time:   0.028650
 Self time:   0.003350

count  total (s)   self (s)
  170              0.001017   if !get(g:, 'coc_workspace_initialized', 0)
                                return
  170              0.000142   endif
  170   0.026983   0.001683   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  <SNR>28_visible_ranges()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/util.vim:629
Called 5 times
Total time:   0.003346
 Self time:   0.003346

count  total (s)   self (s)
    5              0.000039   let info = getwininfo(a:winid)[0]
    5              0.000009   let res = []
    5              0.000029   if !has_key(info, 'topline') || !has_key(info, 'botline')
                                return res
    5              0.000004   endif
    5              0.000008   let begin = 0
    5              0.000013   let curr = info['topline']
    5              0.000010   let max = info['botline']
    5              0.000014   if win_getid() != a:winid
                                return [[curr, max]]
    5              0.000003   endif
  163              0.000184   while curr <= max
  158              0.000356     let closedend = foldclosedend(curr)
  158              0.000179     if closedend == -1
  158              0.000286       let begin = begin == 0 ? curr : begin
  158              0.000176       if curr == max
    5              0.000024         call add(res, [begin, curr])
  158              0.000139       endif
  158              0.000230       let curr = curr + 1
                                else
                                  if begin != 0
                                    call add(res, [begin, curr - 1])
                                    let begin = closedend + 1
                                  endif
                                  let curr = closedend + 1
  158              0.000078     endif
  163              0.000098   endwhile
    5              0.000008   return res

FUNCTION  <SNR>47_ShouldForwardNavigationBackToTmux()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-tmux-navigator/plugin/tmux_navigator.vim:96
Called 3 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    3              0.000013   if g:tmux_navigator_disable_when_zoomed && s:TmuxVimPaneIsZoomed()
                                return 0
    3              0.000002   endif
    3              0.000008   return a:tmux_last_pane || a:at_tab_page_edge

FUNCTION  <SNR>26_AsyncRequest()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/plugin/coc.vim:142
Called 45 times
Total time:   0.014957
 Self time:   0.003771

count  total (s)   self (s)
   45              0.001078   let Cb = empty(a:args)? v:null : a:args[len(a:args) - 1]
   45              0.000390   if type(Cb) == 2
                                if !coc#rpc#ready()
                                  call Cb('service not started', v:null)
                                else
                                  call coc#rpc#request_async(a:name, a:args[0:-2], Cb)
                                endif
                                return ''
   45              0.000063   endif
   45   0.011890   0.000704   call coc#rpc#notify(a:name, a:args)
   45              0.000075   return ''

FUNCTION  coc#util#get_bufoptions()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/util.vim:467
Called 3 times
Total time:   0.000769
 Self time:   0.000480

count  total (s)   self (s)
    3              0.000049   if !bufloaded(a:bufnr) | return v:null | endif
    3              0.000017   let bufname = bufname(a:bufnr)
    3              0.000014   let buftype = getbufvar(a:bufnr, '&buftype')
    3   0.000073   0.000020   let size = coc#util#bufsize(a:bufnr)
    3              0.000006   let lines = v:null
    3              0.000026   if getbufvar(a:bufnr, 'coc_enabled', 1) && (buftype == '' || buftype == 'acwrite' || getbufvar(a:bufnr, 'coc_force_attach', 0)) && size != -2 && size < a:max
    2              0.000182     let lines = getbufline(a:bufnr, 1, '$')
    3              0.000003   endif
    3   0.000384   0.000148   return { 'bufnr': a:bufnr, 'size': size, 'lines': lines, 'winid': bufwinid(a:bufnr), 'bufname': bufname, 'buftype': buftype, 'previewwindow': v:false, 'eol': getbufvar(a:bufnr, '&eol'), 'variables': coc#util#variables(a:bufnr), 'filetype': getbufvar(a:bufnr, '&filetype'), 'lisp': getbufvar(a:bufnr, '&lisp'), 'iskeyword': getbufvar(a:bufnr, '&iskeyword'), 'changedtick': getbufvar(a:bufnr, 'changedtick'), 'fullpath': empty(bufname) ? '' : fnamemodify(bufname, ':p'),}

FUNCTION  coc#compat#execute()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/compat.vim:171
Called 4 times
Total time:   0.014732
 Self time:   0.001967

count  total (s)   self (s)
    4              0.000014   if exists('*win_execute')
    4              0.000016     if type(a:command) == v:t_string
    2              0.000535       keepalt call win_execute(a:winid, a:command, get(a:, 1, ''))
    2              0.000019     elseif type(a:command) == v:t_list
    2   0.013915   0.001149       keepalt call win_execute(a:winid, join(a:command, "\n"), get(a:, 1, ''))
    4              0.000004     endif
                              elseif has('nvim')
                                if !nvim_win_is_valid(a:winid)
                                  return
                                endif
                                let curr = nvim_get_current_win()
                                noa keepalt call nvim_set_current_win(a:winid)
                                if type(a:command) == v:t_string
                                  exe get(a:, 1, '').' '.a:command
                                elseif type(a:command) == v:t_list
                                  for cmd in a:command
                                    exe get(a:, 1, '').' '.cmd
                                  endfor
                                endif
                                noa keepalt call nvim_set_current_win(curr)
                              else
                                throw 'win_execute does not exist, please upgrade vim.'
    4              0.000003   endif

FUNCTION  coc#float#nvim_border_win()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:259
Called 2 times
Total time:   0.002130
 Self time:   0.000622

count  total (s)   self (s)
    2   0.000252   0.000020   let winid = coc#float#get_related(a:winid, 'border')
    2              0.000012   let row = a:border[0] ? a:config['row'] - 1 : a:config['row']
    2              0.000007   let col = a:border[3] ? a:config['col'] - 1 : a:config['col']
    2              0.000009   let width = a:config['width'] + a:border[1] + a:border[3]
    2              0.000013   let height = a:config['height'] + a:border[0] + a:border[2] + (a:hasbtn ? 2 : 0)
    2   0.000195   0.000033   let lines = coc#float#create_border_lines(a:border, a:borderchars, a:title, a:config['width'], a:config['height'], a:hasbtn)
    2              0.000008   let bufnr = winid ? winbufnr(winid) : 0
    2   0.000994   0.000023   let bufnr = coc#float#create_buf(bufnr, lines)
    2              0.000027   let opt = { 'relative': a:config['relative'], 'width': width, 'height': height, 'row': row, 'col': col, 'focusable': v:false, 'style': 'minimal', }
    2              0.000008   if has_key(a:config, 'zindex')
    2              0.000008     let opt['zindex'] = a:config['zindex']
    2              0.000001   endif
    2              0.000012   if has('nvim-0.5.0') && a:shadow && !a:hasbtn && a:border[2]
                                let opt['border'] = 'shadow'
    2              0.000001   endif
    2              0.000002   if winid
                                call nvim_win_set_config(winid, opt)
                                call setwinvar(winid, '&winhl', 'Normal:'.a:hlgroup)
    2              0.000001   else
    2              0.000354     noa let winid = nvim_open_win(bufnr, 0, opt)
    2              0.000013     call setwinvar(winid, 'delta', -1)
    2              0.000008     let winhl = 'Normal:'.a:hlgroup
    2   0.000178   0.000035     call s:nvim_add_related(winid, a:winid, 'border', winhl, a:related)
    2              0.000002   endif

FUNCTION  coc#string#character_index()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/string.vim:8
Called 45 times
Total time:   0.004550
 Self time:   0.004550

count  total (s)   self (s)
   45              0.000214   if a:byteIdx <= 0
   17              0.000036     return 0
   28              0.000049   endif
   28              0.000106   let i = 0
  240              0.001797   for char in split(strpart(a:line, 0, a:byteIdx), '\zs')
  212              0.001275     let i += char2nr(char) > 65535 ? 2 : 1
  240              0.000480   endfor
   28              0.000087   return i

FUNCTION  coc#dict#pick()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/dict.vim:24
Called 2 times
Total time:   0.000364
 Self time:   0.000364

count  total (s)   self (s)
    2              0.000005   let res = {}
   42              0.000062   for key in keys(a:dict)
   40              0.000115     if index(a:keys, key) != -1
   10              0.000035       let res[key] = a:dict[key]
   40              0.000024     endif
   42              0.000049   endfor
    2              0.000003   return res

FUNCTION  coc#float#nvim_win_enter()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:885
Called 10 times
Total time:   0.000206
 Self time:   0.000206

count  total (s)   self (s)
   10              0.000066   let kind = getwinvar(a:winid, 'kind', '')
   10              0.000039   if kind == 'buttons' || kind == 'close'
                                if empty(maparg('<LeftRelease>', 'n'))
                                  nnoremap <buffer><silent> <LeftRelease> :call coc#float#nvim_float_click()<CR>
                                endif
   10              0.000008   endif

FUNCTION  <SNR>70_perform_animation_step()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-smoothie/autoload/smoothie.vim:210
Called 31 times
Total time:   0.021936
 Self time:   0.004811

count  total (s)   self (s)
   31   0.004388   0.001702   let l:target_distance = s:compute_target_distance()
   31   0.001612   0.000362   let l:new_position = s:filter_dict(winsaveview(), s:animated_view_elements)
   31   0.004823   0.000330   let l:animation_step = s:compute_animation_step(l:target_distance, a:step_duration)
   31              0.000068   let l:finished_moving = v:true
   93              0.000184   for [key, value] in items(l:animation_step)
   62              0.000161     if l:new_position[key] == s:target_view[key]
   26              0.000018       continue
   36              0.000019     else
   36              0.000064       let l:finished_moving = v:false
   36              0.000019     endif
   36              0.000196     let l:integer_step_size = float2nr(trunc(value+s:subline_progress_view[key]))
   36              0.000054     if l:integer_step_size != 0
   25              0.000086       let l:new_position[key] = l:new_position[key] + l:integer_step_size
   36              0.000017     endif
   36              0.000145     let s:subline_progress_view[key] += value - l:integer_step_size
   67              0.000055   endfor
   31   0.006119   0.000357   call s:winrestview_optimized(l:new_position)
   31   0.003196   0.000263   call s:abort_if_stuck(l:new_position)
   31              0.000047   return l:finished_moving

FUNCTION  coc#util#do_autocmd()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/util.vim:340
Called 32 times
Total time:   0.000754
 Self time:   0.000754

count  total (s)   self (s)
   32              0.000560   if exists('#User#'.a:name)
                                exe 'doautocmd <nomodeline> User '.a:name
   32              0.000039   endif

FUNCTION  coc#float#on_close()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:714
Called 3 times
Total time:   0.000585
 Self time:   0.000118

count  total (s)   self (s)
    3   0.000512   0.000044   let winids = coc#float#get_float_win_list()
    5              0.000011   for winid in winids
    2              0.000011     let target = getwinvar(winid, 'target_winid', -1)
    2              0.000005     if target == a:winid
                                  call coc#float#close(winid)
    2              0.000001     endif
    5              0.000006   endfor

FUNCTION  <SNR>70_terminal_supports_fast_redraw()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-smoothie/autoload/smoothie.vim:7
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
                              " Currently only Kitty is known not to cause any flickering when calling
                              " `:mode`.
    1              0.000005   return $TERM ==# 'xterm-kitty'

FUNCTION  coc#window#is_float()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/window.vim:95
Called 113 times
Total time:   0.004812
 Self time:   0.004812

count  total (s)   self (s)
  113              0.000316   if s:is_vim
                                try
                                  return !empty(popup_getpos(a:winid))
                                catch /^Vim\%((\a\+)\)\=:E993/
                                  return 0
                                endtry
  113              0.000165   else
  113              0.001273     let config = nvim_win_get_config(a:winid)
  113              0.001150     return !empty(config) && !empty(get(config, 'relative', ''))
                              endif

FUNCTION  CocActionAsync()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/plugin/coc.vim:107
Called 45 times
Total time:   0.016184
 Self time:   0.001226

count  total (s)   self (s)
   45   0.016093   0.001136   return s:AsyncRequest(a:name, a:000)

FUNCTION  coc#cursor#position()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/cursor.vim:16
Called 45 times
Total time:   0.006597
 Self time:   0.002047

count  total (s)   self (s)
   45              0.000650   let line = getline('.')
   45   0.005831   0.001282   return [line('.') - 1, coc#string#character_index(line, col('.') - 1)]

FUNCTION  <SNR>70_filter_dict()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-smoothie/autoload/smoothie.vim:152
Called 124 times
Total time:   0.004375
 Self time:   0.004375

count  total (s)   self (s)
  124              0.000287   let l:result = {}
  372              0.000578   for key in a:persisted_keys
  248              0.000821     let l:result[key] = a:source[key]
  372              0.001514   endfor
  124              0.000188   return result

FUNCTION  coc#dialog#create_cursor_float()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/dialog.vim:69
Called 2 times
Total time:   0.034776
 Self time:   0.009071

count  total (s)   self (s)
    2   0.000645   0.000300   if coc#prompt#activated()
                                return v:null
    2              0.000002   endif
    2              0.000015   let pumAlignTop = get(a:config, 'pumAlignTop', 0)
    2              0.000014   let modes = get(a:config, 'modes', ['n', 'i', 'ic', 's'])
    2              0.000008   let mode = mode()
    2              0.000010   let currbuf = bufnr('%')
    2              0.000013   let pos = [line('.'), col('.')]
    2              0.000010   if index(modes, mode) == -1
                                return v:null
    2              0.000002   endif
    2              0.000017   if !s:is_vim && !has('nvim-0.5.0') && mode ==# 'i'
                                " helps to fix undo issue, don't know why.
                                call feedkeys("\<C-g>u", 'n')
    2              0.000002   endif
    2              0.000011   if mode ==# 's' && has('patch-8.2.4969') && !has('patch-8.2.4996')
                                echohl WarningMsg | echon 'Popup not created to avoid issue #10466 on vim >= 8.2.4969' | echohl None
                                return v:null
    2              0.000002   endif
    2   0.001334   0.000032   let dimension = coc#dialog#get_config_cursor(a:lines, a:config)
    2              0.000006   if empty(dimension)
                                return v:null
    2              0.000001   endif
    2   0.001837   0.000353   if coc#pum#visible() && ((pumAlignTop && dimension['row'] <0)|| (!pumAlignTop && dimension['row'] > 0))
                                return v:null
    2              0.000002   endif
    2              0.000010   let width = dimension['width']
    2   0.000097   0.000076   let lines = map(a:lines, {_, s -> s =~# '^─' ? repeat('─', width) : s})
    2              0.000054   let config = extend(extend({'lines': lines, 'relative': 'cursor'}, a:config), dimension)
    2   0.000328   0.000028   call s:close_auto_hide_wins(a:winid)
    2   0.021486   0.000034   let res = coc#float#create_float_win(a:winid, a:bufnr, config)
    2              0.000005   if empty(res)
                                return v:null
    2              0.000001   endif
    2              0.000008   let alignTop = dimension['row'] < 0
    2              0.000005   let winid = res[0]
    2              0.000003   let bufnr = res[1]
    2              0.007845   redraw
    2              0.000025   if has('nvim')
    2   0.000904   0.000103     call coc#float#nvim_scrollbar(winid)
    2              0.000001   endif
    2              0.000008   return [currbuf, pos, winid, bufnr, alignTop]

FUNCTION  <SNR>58_set_float_defaults()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:1329
Called 2 times
Total time:   0.000579
 Self time:   0.000515

count  total (s)   self (s)
    2              0.000004   if !s:is_vim
    2              0.000010     let hlgroup = get(a:config, 'highlight', 'CocFloating')
    2              0.000036     call setwinvar(a:winid, '&winhl', 'Normal:'.hlgroup.',FoldColumn:'.hlgroup)
    2              0.000012     call setwinvar(a:winid, 'border', get(a:config, 'border', []))
    2              0.000011     call setwinvar(a:winid, 'scrollinside', get(a:config, 'scrollinside', 0))
    2   0.000078   0.000033     call setwinvar(a:winid, '&foldcolumn', s:nvim_get_foldcolumn(a:config))
    2              0.000013     call setwinvar(a:winid, '&signcolumn', 'no')
    2              0.000015     call setwinvar(a:winid, '&cursorcolumn', 0)
                              else
                                call setwinvar(a:winid, '&foldcolumn', 0)
    2              0.000001   endif
    2              0.000008   if exists('&statuscolumn')
    2              0.000011     call setwinvar(a:winid, '&statuscolumn', '')
    2              0.000002   endif
    2              0.000006   if !s:is_vim || !has("patch-8.2.3100")
    2              0.000010     call setwinvar(a:winid, '&number', 0)
    2              0.000010     call setwinvar(a:winid, '&relativenumber', 0)
    2              0.000010     call setwinvar(a:winid, '&cursorline', 0)
    2              0.000001   endif
    2              0.000010   call setwinvar(a:winid, '&foldenable', 0)
    2              0.000010   call setwinvar(a:winid, '&colorcolumn', '')
    2              0.000011   call setwinvar(a:winid, '&spell', 0)
    2              0.000010   call setwinvar(a:winid, '&linebreak', 1)
    2              0.000013   call setwinvar(a:winid, '&conceallevel', 0)
    2              0.000009   call setwinvar(a:winid, '&list', 0)
    2              0.000014   call setwinvar(a:winid, '&wrap', !get(a:config, 'cursorline', 0))
    2              0.000009   if s:is_vim || has('nvim-0.5.0')
    2              0.000012     call setwinvar(a:winid, '&scrolloff', 0)
    2              0.000001   endif
    2              0.000009   if has('nvim-0.6.0') || has("patch-8.1.2281")
    2              0.000012     call setwinvar(a:winid, '&showbreak', 'NONE')
    2              0.000001   endif
    2              0.000007   if exists('*win_execute')
    2   0.000159   0.000141     call win_execute(a:winid, 'setl fillchars+=eob:\ ')
    2              0.000002   endif
    2              0.000009   if get(a:config, 'autohide', 0)
    2              0.000008     call setwinvar(a:winid, 'autohide', 1)
    2              0.000001   endif
    2              0.000006   call setwinvar(a:winid, 'float', 1)

FUNCTION  coc#window#visible_range()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/window.vim:191
Called 19 times
Total time:   0.001353
 Self time:   0.001353

count  total (s)   self (s)
   19              0.000475   let winid = bufwinid(a:bufnr)
   19              0.000105   if winid == -1
                                return v:null
   19              0.000057   endif
   19              0.000402   let info = getwininfo(winid)[0]
   19              0.000164   return [info['topline'], info['botline']]

FUNCTION  <SNR>70_animation_tick()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-smoothie/autoload/smoothie.vim:235
Called 31 times
Total time:   0.023831
 Self time:   0.001852

count  total (s)   self (s)
   31              0.000848   let l:current_step_duration = reltimefloat(reltime(s:last_tick_time))
   31              0.000141   let s:last_tick_time = reltime()
   31   0.022526   0.000590   let l:finished_moving = s:perform_animation_step(l:current_step_duration)
   31              0.000039   if l:finished_moving
    2   0.000056   0.000014     call s:finish_moving()
   31              0.000016   endif

FUNCTION  coc#util#semantic_hlgroups()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/util.vim:24
Called 2 times
Total time:   0.012388
 Self time:   0.012388

count  total (s)   self (s)
    2              0.003295   let res = split(execute('hi'), "\n")
    2              0.008759   let filtered = filter(res, "v:val =~# '^CocSem' && v:val !~# ' cleared$'")
    2              0.000328   return map(filtered, "matchstr(v:val,'\\v^CocSem\\w+')")

FUNCTION  <SNR>58_convert_config_nvim()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:1040
Called 2 times
Total time:   0.000812
 Self time:   0.000374

count  total (s)   self (s)
    2              0.000010   let valids = ['relative', 'win', 'anchor', 'width', 'height', 'bufpos', 'col', 'row', 'focusable']
    2   0.000571   0.000169   let result = coc#dict#pick(a:config, valids)
    2              0.000009   let border = get(a:config, 'border', [])
    2   0.000058   0.000022   if !s:empty_border(border)
    2              0.000010     if result['relative'] ==# 'cursor' && result['row'] < 0
                                  " move top when has bottom border
                                  if get(border, 2, 0)
                                    let result['row'] = result['row'] - 1
                                  endif
    2              0.000002     else
                                  " move down when has top border
    2              0.000011       if get(border, 0, 0) && !get(a:config, 'prompt', 0)
    2              0.000008         let result['row'] = result['row'] + 1
    2              0.000002       endif
    2              0.000001     endif
                                " move right when has left border
    2              0.000005     if get(border, 3, 0)
    2              0.000005       let result['col'] = result['col'] + 1
    2              0.000001     endif
    2              0.000014     let result['width'] = float2nr(result['width'] + 1 - get(border,3, 0))
                              else
                                let result['width'] = float2nr(result['width'] + (get(a:config, 'nopad', 0) ? 0 : 1))
    2              0.000001   endif
    2              0.000015   if has('nvim-0.5.0') && get(a:config, 'shadow', 0) && a:create
                                if empty(get(a:config, 'buttons', v:null)) && empty(get(border, 2, 0))
                                  let result['border'] = 'shadow'
                                endif
    2              0.000001   endif
    2              0.000007   if has('nvim-0.5.1')
    2              0.000009     let result['zindex'] = get(a:config, 'zindex', 50)
    2              0.000001   endif
    2              0.000008   let result['height'] = float2nr(result['height'])
    2              0.000003   return result

FUNCTION  coc#float#nvim_create_related()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:225
Called 2 times
Total time:   0.002603
 Self time:   0.000381

count  total (s)   self (s)
    2              0.000012   let related = getwinvar(a:winid, 'related', [])
    2              0.000007   let exists = !empty(related)
    2              0.000008   let border = get(a:opts, 'border', [])
    2   0.000053   0.000023   let borderhighlight = s:get_borderhighlight(a:opts)
    2              0.000008   let buttons = get(a:opts, 'buttons', [])
    2              0.000017   let pad = !get(a:opts, 'nopad', 0) && (empty(border) || get(border, 1, 0) == 0)
    2              0.000007   let shadow = get(a:opts, 'shadow', 0)
    2              0.000005   if get(a:opts, 'close', 0)
                                call coc#float#nvim_close_btn(a:config, a:winid, border, borderhighlight, related)
    2              0.000003   elseif exists
                                call coc#float#close_related(a:winid, 'close')
    2              0.000002   endif
    2              0.000005   if !empty(buttons)
                                call coc#float#nvim_buttons(a:config, a:winid, buttons, get(a:opts, 'getchar', 0), get(border, 2, 0), pad, borderhighlight, shadow, related)
    2              0.000002   elseif exists
                                call coc#float#close_related(a:winid, 'buttons')
    2              0.000001   endif
    2   0.000047   0.000016   if !s:empty_border(border)
    2   0.000049   0.000018     let borderchars = s:get_borderchars(a:opts)
    2   0.002273   0.000143     call coc#float#nvim_border_win(a:config, borderchars, a:winid, border, get(a:opts, 'title', ''), !empty(buttons), borderhighlight, shadow, related)
                              elseif exists
                                call coc#float#close_related(a:winid, 'border')
    2              0.000001   endif
                              " Check right border
    2              0.000003   if pad
                                call coc#float#nvim_right_pad(a:config, a:winid, shadow, related)
    2              0.000003   elseif exists
                                call coc#float#close_related(a:winid, 'pad')
    2              0.000001   endif
    2              0.000023   call setwinvar(a:winid, 'related', filter(related, 'nvim_win_is_valid(v:val)'))

FUNCTION  <SNR>26_HandleWinScrolled()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/plugin/coc.vim:309
Called 7 times
Total time:   0.001041
 Self time:   0.000116

count  total (s)   self (s)
    7              0.000031   if getwinvar(a:winid, 'float', 0)
                                call coc#float#nvim_scrollbar(a:winid)
    7              0.000005   endif
    7   0.000978   0.000053   call s:Autocmd('WinScrolled', a:winid)

FUNCTION  <SNR>58_nvim_add_related()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:1371
Called 2 times
Total time:   0.000143
 Self time:   0.000143

count  total (s)   self (s)
    2              0.000005   if a:winid <= 0
                                return
    2              0.000002   endif
                              " minimal not work
    2              0.000010   if !has('nvim-0.4.3')
                                call setwinvar(a:winid, '&colorcolumn', '')
                                call setwinvar(a:winid, '&number', 0)
                                call setwinvar(a:winid, '&relativenumber', 0)
                                call setwinvar(a:winid, '&foldcolumn', 0)
                                call setwinvar(a:winid, '&signcolumn', 0)
                                call setwinvar(a:winid, '&list', 0)
    2              0.000001   endif
    2              0.000008   if exists('&statuscolumn')
    2              0.000017     call setwinvar(a:winid, '&statuscolumn', '')
    2              0.000002   endif
    2              0.000015   let winhl = empty(a:winhl) ? coc#window#get_var(a:target, '&winhl', '') : a:winhl
    2              0.000017   call setwinvar(a:winid, '&winhl', winhl)
    2              0.000009   call setwinvar(a:winid, 'target_winid', a:target)
    2              0.000007   call setwinvar(a:winid, 'kind', a:kind)
    2              0.000007   call add(a:related, a:winid)

FUNCTION  <SNR>32_dopopd()
    Defined: ~/.local/share/nvim/site/pack/packer/start/fzf/plugin/fzf.vim:623
Called 10 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
   10              0.000042   if !exists('w:fzf_pushd')
   10              0.000012     return
                              endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
                              if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
                                execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
                              endif
                              unlet! w:fzf_pushd

FUNCTION  coc#prompt#activated()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/prompt.vim:188
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000007   return s:activated

FUNCTION  coc#float#create_buf()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:930
Called 4 times
Total time:   0.001633
 Self time:   0.001487

count  total (s)   self (s)
    4              0.000017   if a:bufnr > 0 && bufloaded(a:bufnr)
    1              0.000003     let bufnr = a:bufnr
    3              0.000002   else
    3              0.000004     if s:is_vim
                                  noa let bufnr = bufadd('')
                                  noa call bufload(bufnr)
                                  call setbufvar(bufnr, '&buflisted', 0)
                                  call setbufvar(bufnr, '&modeline', 0)
                                  call setbufvar(bufnr, '&buftype', 'nofile')
                                  call setbufvar(bufnr, '&swapfile', 0)
    3              0.000002     else
    3              0.000492       noa let bufnr = nvim_create_buf(v:false, v:true)
    3              0.000006     endif
    3              0.000018     let bufhidden = get(a:, 2, 'wipe')
    3   0.000154   0.000102     call setbufvar(bufnr, '&bufhidden', bufhidden)
    3   0.000103   0.000090     call setbufvar(bufnr, '&undolevels', -1)
                                " neovim's bug
    3   0.000164   0.000084     call setbufvar(bufnr, '&modifiable', 1)
    4              0.000007   endif
    4              0.000027   let lines = get(a:, 1, v:null)
    4              0.000016   if type(lines) == v:t_list
    4              0.000014     if has('nvim')
    4              0.000328       call nvim_buf_set_lines(bufnr, 0, -1, v:false, lines)
                                else
                                  silent noa call setbufline(bufnr, 1, lines)
                                  silent noa call deletebufline(bufnr, len(lines) + 1, '$')
    4              0.000004     endif
    4              0.000003   endif
    4              0.000007   return bufnr

FUNCTION  <SNR>70_finish_moving()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-smoothie/autoload/smoothie.vim:85
Called 2 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    2              0.000009   call winrestview(s:target_view)
    2              0.000003   if g:smoothie_redraw_at_finish
                                mode
    2              0.000001   endif
    2              0.000005   let s:target_view = {}
    2              0.000003   let s:subline_progress_view = {}
    2              0.000005   if exists('s:timer_id')
    2              0.000008     call timer_stop(s:timer_id)
    2              0.000003     unlet s:timer_id
    2              0.000001   endif

FUNCTION  <SNR>58_get_borderchars()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:1429
Called 2 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    2              0.000008   let borderchars = get(a:config, 'borderchars', [])
    2              0.000005   if !empty(borderchars)
                                return borderchars
    2              0.000001   endif
    2              0.000010   return get(a:config, 'rounded', 0) ? s:rounded_borderchars : s:borderchars

FUNCTION  coc#math#min()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/math.vim:3
Called 12 times
Total time:   0.000295
 Self time:   0.000295

count  total (s)   self (s)
   12              0.000029   let val = a:first
   26              0.000080   for i in range(0, len(a:000) - 1)
   14              0.000037     if a:000[i] < val
    6              0.000016       let val = a:000[i]
   14              0.000011     endif
   26              0.000024   endfor
   12              0.000016   return val

FUNCTION  coc#float#nvim_scrollbar()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:436
Called 2 times
Total time:   0.000801
 Self time:   0.000259

count  total (s)   self (s)
    2              0.000017   if s:is_vim
                                return
    2              0.000002   endif
    2              0.000023   let winids = nvim_tabpage_list_wins(nvim_get_current_tabpage())
    2              0.000010   if index(winids, a:winid) == -1
                                return
    2              0.000001   endif
    2              0.000019   let config = nvim_win_get_config(a:winid)
    2              0.000020   let [row, column] = nvim_win_get_position(a:winid)
    2              0.000004   let relative = 'editor'
    2              0.000004   if row == 0 && column == 0
                                " fix bad value when ext_multigrid is enabled. https://github.com/neovim/neovim/issues/11935
                                let [row, column] = [config.row, config.col]
                                let relative = config.relative
    2              0.000001   endif
    2              0.000006   let width = nvim_win_get_width(a:winid)
    2              0.000006   let height = nvim_win_get_height(a:winid)
    2              0.000006   let bufnr = winbufnr(a:winid)
    2              0.000015   let cw = getwinvar(a:winid, '&foldcolumn', 0) ? width - 1 : width
    2   0.000259   0.000023   let ch = coc#float#content_height(bufnr, cw, getwinvar(a:winid, '&wrap'))
    2   0.000194   0.000015   let closewin = coc#float#get_related(a:winid, 'close')
    2              0.000008   let border = getwinvar(a:winid, 'border', [])
    2              0.000009   let scrollinside = getwinvar(a:winid, 'scrollinside', 0) && get(border, 1, 0)
    2              0.000007   let winblend = getwinvar(a:winid, '&winblend', 0)
    2              0.000007   let move_down = closewin && !get(border, 0, 0)
    2   0.000139   0.000011   let id = coc#float#get_related(a:winid, 'scrollbar')
    2              0.000004   if ch <= height || height <= 1
                                " no scrollbar, remove exists
    2              0.000002     if id
                                  call s:close_win(id, 1)
    2              0.000001     endif
    2              0.000002     return
                              endif
                              if move_down
                                let height = height - 1
                              endif
                              call coc#float#close_related(a:winid, 'pad')
                              let sbuf = id ? winbufnr(id) : 0
                              let sbuf = coc#float#create_buf(sbuf, repeat([' '], height))
                              let opts = { 'row': move_down ? row + 1 : row, 'col': column + width - scrollinside, 'relative': relative, 'width': 1, 'height': height, 'focusable': v:false, 'style': 'minimal', }
                              if has_key(config, 'zindex')
                                let opts['zindex'] = config['zindex'] + 2
                              endif
                              if has('nvim-0.5.0') && s:has_shadow(config)
                                let opts['border'] = 'shadow'
                              endif
                              if id
                                call nvim_win_set_config(id, opts)
                              else
                                noa let id = nvim_open_win(sbuf, 0 , opts)
                                if id == 0
                                  return
                                endif
                                if winblend
                                  call setwinvar(id, '&winblend', winblend)
                                endif
                                call setwinvar(id, 'kind', 'scrollbar')
                                call setwinvar(id, 'target_winid', a:winid)
                                call coc#float#add_related(id, a:winid)
                              endif
                              if !scrollinside
                                call coc#float#nvim_scroll_adjust(a:winid)
                              endif
                              let thumb_height = max([1, float2nr(floor(height * (height + 0.0)/ch))])
                              let wininfo = getwininfo(a:winid)[0]
                              let start = 0
                              if wininfo['topline'] != 1
                                " needed for correct getwininfo
                                let firstline = wininfo['topline']
                                let lastline = s:nvim_get_botline(firstline, height, cw, bufnr)
                                let linecount = nvim_buf_line_count(winbufnr(a:winid))
                                if lastline >= linecount
                                  let start = height - thumb_height
                                else
                                  let start = max([1, float2nr(round((height - thumb_height + 0.0)*(firstline - 1.0)/(ch - height)))])
                                endif
                              endif
                              " add highlights
                              call nvim_buf_clear_namespace(sbuf, -1, 0, -1)
                              for idx in range(0, height - 1)
                                if idx >= start && idx < start + thumb_height
                                  call nvim_buf_add_highlight(sbuf, -1, 'CocFloatThumb', idx, 0, 1)
                                else
                                  call nvim_buf_add_highlight(sbuf, -1, 'CocFloatSbar', idx, 0, 1)
                                endif
                              endfor

FUNCTION  coc#highlight#clear_highlight()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/highlight.vim:326
Called 5 times
Total time:   0.000410
 Self time:   0.000370

count  total (s)   self (s)
    5              0.000075   let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
    5              0.000039   if !bufloaded(bufnr)
                                return
    5              0.000007   endif
    5   0.000140   0.000100   let src_id = coc#highlight#create_namespace(a:key)
    5              0.000027   if has('nvim')
    5              0.000051     call nvim_buf_clear_namespace(a:bufnr, src_id, a:start_line, a:end_line)
                              else
                                call coc#api#exec('buf_clear_namespace', [a:bufnr, src_id, a:start_line, a:end_line])
    5              0.000004   endif

FUNCTION  coc#util#variables()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/util.vim:223
Called 3 times
Total time:   0.000236
 Self time:   0.000236

count  total (s)   self (s)
    3              0.000022   let info = getbufinfo(a:bufnr)
    3              0.000056   let variables = empty(info) ? {} : copy(info[0]['variables'])
   21              0.000041   for key in keys(variables)
   18              0.000051     if key !~# '\v^coc'
   18              0.000027       unlet variables[key]
   18              0.000008     endif
   21              0.000011   endfor
    3              0.000004   return variables

FUNCTION  coc#float#close()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:564
Called 2 times
Total time:   0.006720
 Self time:   0.000139

count  total (s)   self (s)
    2              0.000051   let noautocmd = get(a:, 1, 0)
    2   0.001030   0.000048   call coc#float#close_related(a:winid)
    2   0.005630   0.000032   call s:close_win(a:winid, noautocmd)
    2              0.000002   return 1

FUNCTION  coc#util#bufsize()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/util.vim:497
Called 3 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    3              0.000010   if bufnr('%') == a:bufnr
    2              0.000011     return line2byte(line("$") + 1)
    1              0.000001   endif
    1              0.000003   let bufname = bufname(a:bufnr)
    1              0.000006   if !getbufvar(a:bufnr, '&modified') && filereadable(bufname)
                                return getfsize(bufname)
    1              0.000001   endif
    1              0.000009   return strlen(join(getbufline(a:bufnr, 1, '$'), '\n'))

FUNCTION  <SNR>70_compute_animation_step()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-smoothie/autoload/smoothie.vim:140
Called 31 times
Total time:   0.004493
 Self time:   0.001400

count  total (s)   self (s)
   31              0.000046   let l:result = {}
   93   0.003544   0.000451   for [key, value] in items(s:compute_velocity(a:target_distance))
   62              0.000146     let l:result[key] = value * a:step_duration
   62              0.000237     if abs(l:result[key]) > abs(a:target_distance[key])
                                  " clamp step size to prevent overshooting the target
   29              0.000072       let l:result[key] = a:target_distance[key]
   62              0.000045     end
   93              0.000052   endfor
   31              0.000031   return l:result

FUNCTION  <SNR>58_get_borderhighlight()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:1445
Called 2 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    2              0.000008   let hlgroup = get(a:config, 'highlight',  'CocFloating')
    2              0.000010   let borderhighlight = get(a:config, 'borderhighlight', v:null)
    2              0.000005   if empty(borderhighlight)
    2              0.000004     return hlgroup
                              endif
                              let highlight = type(borderhighlight) == 3 ? borderhighlight[0] : borderhighlight
                              return coc#highlight#compose_hlgroup(highlight, hlgroup)

FUNCTION  coc#highlight#add_highlights()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/highlight.vim:352
Called 2 times
Total time:   0.015819
 Self time:   0.000409

count  total (s)   self (s)
    2              0.000010   if get(g:, 'coc_node_env', '') ==# 'test'
                                call setwinvar(a:winid, 'highlights', a:highlights)
    2              0.000001   endif
                              " clear highlights
    2   0.001007   0.000189   call coc#compat#execute(a:winid, 'syntax clear')
    2              0.000009   let bufnr = winbufnr(a:winid)
    2   0.000134   0.000021   call coc#highlight#clear_highlight(bufnr, -1, 0, -1)
    2              0.000005   if !empty(a:codes)
    2   0.014599   0.000121     call coc#highlight#highlight_lines(a:winid, a:codes)
    2              0.000001   endif
    2              0.000008   if !empty(a:highlights)
                                for item in a:highlights
                                  let hlGroup = item['hlGroup']
                                  let opts = hlGroup =~# 'Search$' ? {'priority': 999, 'combine': 1} : {}
                                  call coc#highlight#add_highlight(bufnr, -1, hlGroup, item['lnum'], item['colStart'], item['colEnd'])
                                endfor
    2              0.000001   endif

FUNCTION  coc#highlight#match_ranges()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/highlight.vim:554
Called 2 times
Total time:   0.001927
 Self time:   0.000812

count  total (s)   self (s)
    2              0.000025   let winid = a:winid == 0 ? win_getid() : a:winid
    2              0.000015   let bufnr = a:bufnr == 0 ? winbufnr(winid) : a:bufnr
    2              0.000041   if empty(getwininfo(winid)) || (a:bufnr != 0 && winbufnr(a:winid) != a:bufnr)
                                " not valid
                                return []
    2              0.000002   endif
    2              0.000007   if !s:clear_match_by_window
                                let curr = win_getid()
                                noa call win_gotoid(winid)
    2              0.000002   endif
    2              0.000005   let ids = []
    4              0.000011   for range in a:ranges
    2              0.000004     let pos = []
    2              0.000009     let start = range['start']
    2              0.000005     let end = range['end']
    4              0.000020     for lnum in range(start['line'] + 1, end['line'] + 1)
    2              0.000014       let arr = getbufline(bufnr, lnum)
    2              0.000012       let line = empty(arr) ? '' : arr[0]
    2              0.000006       if empty(line)
                                    continue
    2              0.000002       endif
    2   0.000520   0.000043       let colStart = lnum == start['line'] + 1 ? coc#string#byte_index(line, start['character']) + 1 : 1
    2   0.000678   0.000040       let colEnd = lnum == end['line'] + 1 ? coc#string#byte_index(line, end['character']) + 1 : strlen(line) + 1
    2              0.000005       if colStart == colEnd
                                    continue
    2              0.000001       endif
    2              0.000017       call add(pos, [lnum, colStart, colEnd - colStart])
    4              0.000004     endfor
    2              0.000006     if !empty(pos)
    2              0.000018       let opts = s:clear_match_by_window ? {'window': a:winid} : {}
    2              0.000004       let i = 1
    2              0.000009       let l = []
    4              0.000007       for p in pos
    2              0.000007         call add(l, p)
    2              0.000005         if i % 8 == 0
                                      let id = matchaddpos(a:hlGroup, l, a:priority, -1, opts)
                                      call add(ids, id)
                                      let l = []
    2              0.000002         endif
    2              0.000016         let i += 1
    4              0.000004       endfor
    2              0.000006       if !empty(l)
    2              0.000022         let id = matchaddpos(a:hlGroup, l, a:priority, -1, opts)
    2              0.000006         call add(ids, id)
    2              0.000002       endif
    2              0.000001     endif
    4              0.000008   endfor
    2              0.000005   if !s:clear_match_by_window
                                noa call win_gotoid(curr)
    2              0.000002   endif
    2              0.000003   return ids

FUNCTION  coc#float#valid()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:37
Called 8 times
Total time:   0.000235
 Self time:   0.000235

count  total (s)   self (s)
    8              0.000018   if a:winid <= 0
                                return 0
    8              0.000007   endif
    8              0.000013   if !s:is_vim
    8              0.000038     if !nvim_win_is_valid(a:winid)
                                  return 0
    8              0.000006     endif
    8              0.000113     return !empty(nvim_win_get_config(a:winid)['relative'])
                              endif
                              try
                                return !empty(popup_getpos(a:winid))
                              catch /^Vim\%((\a\+)\)\=:E993/
                                " not a popup window
                                return 0
                              endtry

FUNCTION  coc#task#running()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/task.vim:168
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000005   if !has_key(s:running_task, a:id) == 1
    1              0.000002     return v:false
                              endif
                              let job = s:running_task[a:id]
                              if s:is_vim
                                let status = job_status(job)
                                return status ==# 'run'
                              endif
                              let [code] = jobwait([job], 10)
                              return code == -1

FUNCTION  <SNR>70_update_target()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-smoothie/autoload/smoothie.vim:244
Called 2 times
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)
    2              0.000015   let l:current_view = winsaveview()
    2              0.000005   if !empty(s:target_view)
                                call winrestview(s:target_view)
    2              0.000001   endif
    2              0.000086   execute 'normal! ' . a:count . a:command
    2              0.000008   let s:target_view = winsaveview()
    2              0.000008   call winrestview(l:current_view)

FUNCTION  coc#float#check_related()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:751
Called 43 times
Total time:   0.012623
 Self time:   0.003791

count  total (s)   self (s)
   43              0.000233   let invalids = []
   43   0.009849   0.001017   let ids = coc#float#get_float_win_list(1)
   70              0.000211   for id in ids
   27              0.000222     let target = getwinvar(id, 'target_winid', 0)
   27              0.000122     if target && index(ids, target) == -1
                                  call add(invalids, id)
   27              0.000025     endif
   70              0.000121   endfor
   43              0.000185   if s:is_vim && !s:popup_list_api
                                let s:popup_list = filter(ids, "index(invalids, v:val) == -1")
   43              0.000059   endif
   43              0.000162   for id in invalids
                                call coc#float#close(id)
   43              0.000066   endfor

FUNCTION  <SNR>70_compute_velocity()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-smoothie/autoload/smoothie.vim:132
Called 31 times
Total time:   0.003093
 Self time:   0.002107

count  total (s)   self (s)
   31              0.000048   let l:result = {}
   93              0.000231   for [key, value] in items(a:target_distance)
   62   0.001546   0.000560     let l:result[key] = s:compute_velocity_element(value)
   93              0.001114   endfor
   31              0.000033   return l:result

FUNCTION  <SNR>58_nvim_get_foldcolumn()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:1394
Called 2 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    2              0.000008   let nopad = get(a:config, 'nopad', 0)
    2              0.000003   if nopad
                                return 0
    2              0.000002   endif
    2              0.000008   let border = get(a:config, 'border', v:null)
    2              0.000015   if border is 1 || (type(border) == v:t_list && get(border, 3, 0) == 1)
    2              0.000003     return 0
                              endif
                              return 1

FUNCTION  smoothie#do()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-smoothie/autoload/smoothie.vim:254
Called 2 times
Total time:   0.000295
 Self time:   0.000074

count  total (s)   self (s)
    2              0.000011   if v:count == 0
    2              0.000007     let l:count = ''
                              else
                                let l:count = v:count
    2              0.000001   endif
    2              0.000003   if g:smoothie_enabled
    2   0.000153   0.000024     call s:update_target(a:command, l:count)
    2   0.000103   0.000012     call s:start_moving()
                              else
                                execute 'normal! ' . l:count . a:command
    2              0.000001   endif

FUNCTION  coc#highlight#create_namespace()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/highlight.vim:686
Called 7 times
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
    7              0.000031   if type(a:key) == 0
    5              0.000010     return a:key
    2              0.000002   endif
    2              0.000008   if has_key(s:namespace_map, a:key)
                                return s:namespace_map[a:key]
    2              0.000001   endif
    2              0.000006   if has('nvim')
    2              0.000024     let s:namespace_map[a:key] = nvim_create_namespace('coc-'.a:key)
                              else
                                let s:namespace_map[a:key] = s:ns_id
                                let s:ns_id = s:ns_id + 1
    2              0.000001   endif
    2              0.000005   return s:namespace_map[a:key]

FUNCTION  <SNR>29_notify()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/client.vim:212
Called 215 times
Total time:   0.026890
 Self time:   0.024701

count  total (s)   self (s)
  215   0.005285   0.003095   let channel = coc#client#get_channel(self)
  215              0.000702   if empty(channel)
                                return ''
  215              0.000157   endif
  215              0.000335   try
  215              0.000331     if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
  215              0.000249     else
  215              0.007424       call call('rpcnotify', [channel, a:method] + a:args)
  215              0.000285     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
  215              0.000394   endtry

FUNCTION  <SNR>29_on_error()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/client.vim:376
Called 8 times
Total time:   0.000382
 Self time:   0.000382

count  total (s)   self (s)
    8              0.000025   echohl ErrorMsg
    8              0.000162   echo join(a:msgs, "\n")
    8              0.000013   echohl None
    8              0.000044   let client = get(s:clients, a:name, v:null)
    8              0.000020   if !empty(client)
    8              0.000031     let errors = get(client, 'stderr', [])
    8              0.000030     call extend(errors, a:msgs)
    8              0.000024     let client['stderr'] = errors
    8              0.000006   endif

FUNCTION  coc#float#close_related()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:725
Called 2 times
Total time:   0.000982
 Self time:   0.000585

count  total (s)   self (s)
    2   0.000186   0.000074   if !coc#float#valid(a:winid)
                                return
    2              0.000002   endif
    2   0.000196   0.000033   let timer = coc#window#get_var(a:winid, 'timer', 0)
    2              0.000004   if timer
                                call timer_stop(timer)
    2              0.000002   endif
    2              0.000012   let kind = get(a:, 1, '')
    2   0.000095   0.000029   let winids = coc#window#get_var(a:winid, 'related', [])
    4              0.000014   for id in winids
    2   0.000090   0.000035     let curr = coc#window#get_var(id, 'kind', '')
    2              0.000012     if empty(kind) || curr ==# kind
    2              0.000007       if curr == 'list'
                                    call coc#float#close(id, 1)
    2              0.000004       elseif s:is_vim
                                    " vim doesn't throw
                                    noa call popup_close(id)
    2              0.000003       else
    2              0.000189         silent! noa call nvim_win_close(id, 1)
    2              0.000006       endif
    2              0.000002     endif
    4              0.000009   endfor

FUNCTION  <SNR>29_on_stderr()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/client.vim:112
Called 8 times
Total time:   0.001258
 Self time:   0.000876

count  total (s)   self (s)
    8              0.000164   if get(g:, 'coc_vim_leaving', 0) | return | endif
    8              0.000135   let data = filter(copy(a:msgs), '!empty(v:val)')
    8              0.000036   if empty(data) | return | endif
    8              0.000044   let client = a:name ==# 'coc' ? '[coc.nvim]' : '['.a:name.']'
    8              0.000096   let data[0] = client.': '.data[0]
    8              0.000155   if a:name ==# 'coc' && len(filter(copy(data), 'v:val =~# "SyntaxError: "'))
                                call coc#client#check_version()
                                return
    8              0.000007   endif
    8              0.000043   if get(g:, 'coc_disable_uncaught_error', 0) | return | endif
    8   0.000492   0.000110   call s:on_error(a:name, data)

FUNCTION  <SNR>70_ensure_subline_progress_view_initialized()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-smoothie/autoload/smoothie.vim:74
Called 2 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    2              0.000004   if empty(s:subline_progress_view)
    6              0.000009     for key in s:animated_view_elements
    4              0.000012       let s:subline_progress_view[key] = 0.0
    6              0.000005     endfor
    2              0.000001   endif

FUNCTION  <SNR>70_editor_supports_fast_redraw()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-smoothie/autoload/smoothie.vim:1
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
                              " Currently enabled only for Neovim, because it causes screen flickering on
                              " regular Vim.
    1              0.000006   return has('nvim')

FUNCTION  <SNR>47_VimNavigate()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-tmux-navigator/plugin/tmux_navigator.vim:10
Called 3 times
Total time:   0.006592
 Self time:   0.000329

count  total (s)   self (s)
    3              0.000006   try
    3   0.006568   0.000305     execute 'wincmd ' . a:direction
                              catch
                                echohl ErrorMsg | echo 'E11: Invalid in command-line window; <CR> executes, CTRL-C quits: wincmd k' | echohl None
    3              0.000002   endtry

FUNCTION  coc#float#create_float_win()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:121
Called 2 times
Total time:   0.021452
 Self time:   0.000803

count  total (s)   self (s)
    2              0.000011   let lines = get(a:config, 'lines', v:null)
    2              0.000005   let bufnr = a:bufnr
    2              0.000003   try
    2   0.000688   0.000026     let bufnr = coc#float#create_buf(a:bufnr, lines, 'hide')
                              catch /E523:/
                                " happens when using getchar() #3921
                                return []
    2              0.000002   endtry
    2              0.000014   let lnum = max([1, get(a:config, 'index', 0) + 1])
    2              0.000007   let zindex = get(a:config, 'zindex', 50)
                              " use exists
    2              0.000006   if a:winid && coc#float#valid(a:winid)
                                if s:is_vim
                                  let [line, col] = s:popup_position(a:config)
                                  let opts = { 'firstline': 1, 'line': line, 'col': col, 'minwidth': a:config['width'], 'minheight': a:config['height'], 'maxwidth': a:config['width'], 'maxheight': a:config['height'], 'title': get(a:config, 'title', ''), 'highlight': get(a:config, 'highlight', 'CocFloating'), 'borderhighlight':  [s:get_borderhighlight(a:config)], }
                                  if !s:empty_border(get(a:config, 'border', []))
                                    let opts['border'] = a:config['border']
                                  endif
                                  call popup_setoptions(a:winid, opts)
                                  call win_execute(a:winid, 'exe '.lnum)
                                  call coc#float#vim_buttons(a:winid, a:config)
                                  call s:add_highlights(a:winid, a:config, 0)
                                  return [a:winid, winbufnr(a:winid)]
                                else
                                  let config = s:convert_config_nvim(a:config, 0)
                                  let hlgroup = get(a:config, 'highlight', 'CocFloating')
                                  let current = getwinvar(a:winid, '&winhl', '')
                                  let winhl = coc#util#merge_winhl(current, [['Normal', hlgroup], ['FoldColumn', hlgroup]])
                                  if winhl !=# current
                                    call setwinvar(a:winid, '&winhl', winhl)
                                  endif
                                  call nvim_win_set_buf(a:winid, bufnr)
                                  call nvim_win_set_config(a:winid, config)
                                  call nvim_win_set_cursor(a:winid, [lnum, 0])
                                  call coc#float#nvim_create_related(a:winid, config, a:config)
                                  call s:add_highlights(a:winid, a:config, 0)
                                  return [a:winid, bufnr]
                                endif
    2              0.000001   endif
    2              0.000003   let winid = 0
    2              0.000002   if s:is_vim
                                let [line, col] = s:popup_position(a:config)
                                let title = get(a:config, 'title', '')
                                let buttons = get(a:config, 'buttons', [])
                                let hlgroup = get(a:config, 'highlight',  'CocFloating')
                                let nopad = get(a:config, 'nopad', 0)
                                let border = s:empty_border(get(a:config, 'border', [])) ? [0, 0, 0, 0] : a:config['border']
                                let opts = { 'title': title, 'line': line, 'col': col, 'fixed': 1, 'padding': [0, !nopad && !border[1], 0, !nopad && !border[3]], 'borderchars': s:get_borderchars(a:config), 'highlight': hlgroup, 'minwidth': a:config['width'], 'minheight': a:config['height'], 'maxwidth': a:config['width'], 'maxheight': a:config['height'], 'close': get(a:config, 'close', 0) ? 'button' : 'none', 'border': border, 'zindex': zindex, 'callback': { -> coc#float#on_close(winid)}, 'borderhighlight': [s:get_borderhighlight(a:config)], 'scrollbarhighlight': 'CocFloatSbar', 'thumbhighlight': 'CocFloatThumb', }
                                let winid = popup_create(bufnr, opts)
                                if !s:popup_list_api
                                  call add(s:popup_list, winid)
                                endif
                                call s:set_float_defaults(winid, a:config)
                                call win_execute(winid, 'exe '.lnum)
                                call coc#float#vim_buttons(winid, a:config)
    2              0.000002   else
    2   0.000837   0.000026     let config = s:convert_config_nvim(a:config, 1)
    2              0.000253     noa let winid = nvim_open_win(bufnr, 0, config)
    2              0.000005     if winid is 0
                                  return []
    2              0.000002     endif
                                " cursorline highlight not work on old neovim
    2   0.000607   0.000027     call s:set_float_defaults(winid, a:config)
    2              0.000022     call nvim_win_set_cursor(winid, [lnum, 0])
    2   0.002629   0.000025     call coc#float#nvim_create_related(winid, config, a:config)
    2   0.000037   0.000026     call coc#float#nvim_set_winblend(winid, get(a:config, 'winblend', v:null))
    2              0.000001   endif
    2   0.015984   0.000023   call s:add_highlights(winid, a:config, 1)
    2              0.000007   let g:coc_last_float_win = winid
    2   0.000043   0.000022   call coc#util#do_autocmd('CocOpenFloat')
    2              0.000006   return [winid, bufnr]

FUNCTION  <SNR>47_TmuxAwareNavigate()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-tmux-navigator/plugin/tmux_navigator.vim:103
Called 3 times
Total time:   0.006897
 Self time:   0.000276

count  total (s)   self (s)
    3              0.000021   let nr = winnr()
    3              0.000018   let tmux_last_pane = (a:direction == 'p' && s:tmux_is_last_pane)
    3              0.000007   if !tmux_last_pane
    3   0.006617   0.000025     call s:VimNavigate(a:direction)
    3              0.000002   endif
    3              0.000013   let at_tab_page_edge = (nr == winnr())
                              " Forward the switch panes command to tmux if:
                              " a) we're toggling between the last tmux pane;
                              " b) we tried switching windows in vim but it didn't have effect.
    3   0.000061   0.000032   if s:ShouldForwardNavigationBackToTmux(tmux_last_pane, at_tab_page_edge)
                                if g:tmux_navigator_save_on_switch == 1
                                  try
                                    update " save the active buffer. See :help update
                                  catch /^Vim\%((\a\+)\)\=:E32/ " catches the no file name error
                                  endtry
                                elseif g:tmux_navigator_save_on_switch == 2
                                  try
                                    wall " save all the buffers. See :help wall
                                  catch /^Vim\%((\a\+)\)\=:E141/ " catches the no file name error
                                  endtry
                                endif
                                let args = 'select-pane -t ' . shellescape($TMUX_PANE) . ' -' . tr(a:direction, 'phjkl', 'lLDUR')
                                if g:tmux_navigator_preserve_zoom == 1
                                  let l:args .= ' -Z'
                                endif
                                if g:tmux_navigator_no_wrap == 1
                                  let args = 'if -F "#{pane_at_' . s:pane_position_from_direction[a:direction] . '}" "" "' . args . '"'
                                endif
                                silent call s:TmuxCommand(args)
                                if s:NeedsVitalityRedraw()
                                  redraw!
                                endif
                                let s:tmux_is_last_pane = 1
    3              0.000002   else
    3              0.000015     let s:tmux_is_last_pane = 0
    3              0.000002   endif

FUNCTION  coc#dialog#get_config_cursor()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/dialog.vim:430
Called 2 times
Total time:   0.001302
 Self time:   0.000683

count  total (s)   self (s)
    2              0.000010   let preferTop = get(a:config, 'preferTop', 0)
    2              0.000008   let title = get(a:config, 'title', '')
    2              0.000009   let border = get(a:config, 'border', [])
    2              0.000009   if empty(border) && len(title)
                                let border = [1, 1, 1, 1]
    2              0.000002   endif
    2              0.000013   let bh = get(border, 0, 0) + get(border, 2, 0)
    2              0.000010   let vh = &lines - &cmdheight - 1
    2              0.000004   if vh <= 0
                                return v:null
    2              0.000001   endif
    2   0.000365   0.000264   let maxWidth = coc#math#min(get(a:config, 'maxWidth', &columns - 1), &columns - 1)
    2              0.000004   if maxWidth < 3
                                return v:null
    2              0.000001   endif
    2   0.000069   0.000026   let maxHeight = coc#math#min(get(a:config, 'maxHeight', vh), vh)
    2   0.000068   0.000023   let width = coc#math#min(40, strdisplaywidth(title)) + 3
    4              0.000008   for line in a:lines
    2              0.000020     let dw = max([1, strdisplaywidth(line)])
    2              0.000009     let width = max([width, dw + 2])
    4              0.000004   endfor
    2   0.000060   0.000017   let width = coc#math#min(maxWidth, width)
    2   0.000273   0.000025   let ch = coc#string#content_height(a:lines, width - 2)
    2   0.000060   0.000024   let [lineIdx, colIdx] = coc#cursor#screen_pos()
                              " How much we should move left
    2   0.000093   0.000048   let offsetX = coc#math#min(get(a:config, 'offsetX', 0), colIdx)
    2              0.000005   let showTop = 0
    2              0.000006   let hb = vh - lineIdx -1
    2              0.000013   if lineIdx > bh + 2 && (preferTop || (lineIdx > hb && hb < ch + bh))
                                let showTop = 1
    2              0.000002   endif
    2   0.000080   0.000023   let height = coc#math#min(maxHeight, ch + bh, showTop ? lineIdx - 1 : hb)
    2              0.000004   if height <= bh
                                return v:null
    2              0.000001   endif
    2              0.000014   let col = - max([offsetX, colIdx - (&columns - 1 - width)])
    2              0.000006   let row = showTop ? - height + bh : 1
    2              0.000018   return { 'row': row, 'col': col, 'width': width - 2, 'height': height - bh }

FUNCTION  coc#float#create_border_lines()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:533
Called 2 times
Total time:   0.000162
 Self time:   0.000162

count  total (s)   self (s)
    2              0.000006   let borderchars = a:borderchars
    2              0.000003   let list = []
    2              0.000004   if a:border[0]
    2              0.000026     let top = (a:border[3] ?  borderchars[4]: '').repeat(borderchars[0], a:width).(a:border[1] ? borderchars[5] : '')
    2              0.000006     if !empty(a:title)
                                  let top = coc#string#compose(top, 1, a:title.' ')
    2              0.000001     endif
    2              0.000008     call add(list, top)
    2              0.000002   endif
    2              0.000020   let mid = (a:border[3] ?  borderchars[3]: '').repeat(' ', a:width).(a:border[1] ? borderchars[1] : '')
    2              0.000017   call extend(list, repeat([mid], a:height + (a:hasbtn ? 2 : 0)))
    2              0.000003   if a:hasbtn
                                let list[len(list) - 2] = (a:border[3] ?  s:borderjoinchars[3]: '').repeat(' ', a:width).(a:border[1] ? s:borderjoinchars[1] : '')
    2              0.000001   endif
    2              0.000004   if a:border[2]
    2              0.000019     let bot = (a:border[3] ?  borderchars[7]: '').repeat(borderchars[2], a:width).(a:border[1] ? borderchars[6] : '')
    2              0.000006     call add(list, bot)
    2              0.000001   endif
    2              0.000003   return list

FUNCTION  coc#rpc#notify()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/rpc.vim:187
Called 215 times
Total time:   0.036485
 Self time:   0.006631

count  total (s)   self (s)
  215   0.005037   0.002073   if !coc#rpc#ready()
                                return ''
  215              0.000164   endif
  215   0.030244   0.003353   call s:client['notify'](a:method, a:args)
  215              0.000372   return ''

FUNCTION  coc#cursor#screen_pos()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/cursor.vim:4
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000007   let nr = winnr()
    2              0.000012   let [row, col] = win_screenpos(nr)
    2              0.000015   return [row + winline() - 2, col + wincol() - 2]

FUNCTION  coc#float#get_related()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:906
Called 6 times
Total time:   0.000537
 Self time:   0.000181

count  total (s)   self (s)
    6   0.000158   0.000035   if coc#float#valid(a:winid)
   10   0.000240   0.000055     for winid in coc#window#get_var(a:winid, 'related', [])
    4   0.000072   0.000023       if coc#window#get_var(winid, 'kind', '') ==# a:kind
                                    return winid
    4              0.000002       endif
   10              0.000008     endfor
    6              0.000004   endif
    6              0.000017   return get(a:, 1, 0)

FUNCTION  coc#util#get_loaded_bufs()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/util.vim:416
Called 43 times
Total time:   0.002788
 Self time:   0.002788

count  total (s)   self (s)
   43              0.002665   return map(getbufinfo({'bufloaded': 1}),'v:val["bufnr"]')

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /usr/local/Cellar/neovim/HEAD-92760a7/share/nvim/runtime/ftplugin.vim:14
Called 4 times
Total time:   0.020324
 Self time:   0.018335

count  total (s)   self (s)
    4              0.000026     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    4              0.000004     endif
                            
    4              0.000022     let s = expand("<amatch>")
    4              0.000009     if s != ""
    4              0.000039       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    4              0.000003       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    8              0.000037       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
    4   0.020073   0.018084         exe printf('runtime! ftplugin/%s.vim ftplugin/%s.lua ftplugin/%s_*.vim ftplugin/%s_*.lua ftplugin/%s/*.vim ftplugin/%s/*.lua', name, name, name, name, name, name)
    8              0.000021       endfor
    4              0.000004     endif

FUNCTION  <SNR>26_HandleWinClosed()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/plugin/coc.vim:316
Called 3 times
Total time:   0.002656
 Self time:   0.000563

count  total (s)   self (s)
    3   0.000666   0.000081   call coc#float#on_close(a:winid)
    3   0.001413   0.000447   call coc#notify#on_close(a:winid)
    3   0.000572   0.000031   call s:Autocmd('WinClosed', a:winid)

FUNCTION  <SNR>7_SynSet()
    Defined: /usr/local/Cellar/neovim/HEAD-92760a7/share/nvim/runtime/syntax/synload.vim:26
Called 4 times
Total time:   0.024221
 Self time:   0.008745

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    4              0.000012   syn clear
    4              0.000009   if exists("b:current_syntax")
                                unlet b:current_syntax
    4              0.000003   endif
                            
    4              0.000014   0verbose let s = expand("<amatch>")
    4              0.000006   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    4              0.000004   elseif s == "OFF"
                                let s = ""
    4              0.000002   endif
                            
    4              0.000003   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
    8              0.000029     for name in split(s, '\.')
    4              0.000007       if !empty(name)
    4   0.021609   0.006133         exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    4              0.002398         exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"
    4              0.000004       endif
    8              0.000009     endfor
    4              0.000003   endif

FUNCTION  coc#util#tabnr_id()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/util.vim:412
Called 43 times
Total time:   0.000685
 Self time:   0.000685

count  total (s)   self (s)
   43              0.000635   return s:is_vim ? coc#api#get_tabid(a:tabnr) : nvim_list_tabpages()[a:tabnr - 1]

FUNCTION  <SNR>70_compute_target_distance()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-smoothie/autoload/smoothie.vim:124
Called 31 times
Total time:   0.002686
 Self time:   0.001813

count  total (s)   self (s)
   31              0.000355   let l:result = {}
   93   0.001737   0.000864   for [key, value] in items(s:filter_dict(winsaveview(), s:animated_view_elements))
   62              0.000330     let l:result[key] = s:target_view[key] - value - s:subline_progress_view[key]
   93              0.000059   endfor
   31              0.000043   return l:result

FUNCTION  <SNR>71_close_auto_hide_wins()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/dialog.vim:715
Called 2 times
Total time:   0.000300
 Self time:   0.000067

count  total (s)   self (s)
    2   0.000259   0.000026   let winids = coc#float#get_float_win_list()
    2              0.000009   let except = get(a:, 1, 0)
    2              0.000005   for id in winids
                                if except && id == except
                                  continue
                                endif
                                if getwinvar(id, 'autohide', 0)
                                  call coc#float#close(id)
                                endif
    2              0.000003   endfor

FUNCTION  coc#string#content_height()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/string.vim:97
Called 4 times
Total time:   0.000415
 Self time:   0.000415

count  total (s)   self (s)
    4              0.000008   let len = 0
    4              0.000096   let pattern = empty(&breakat) ? '.\zs' : '['.substitute(&breakat, '\([\[\]\-]\)', '\\\1', 'g').']\zs'
    8              0.000015   for line in a:lines
    4              0.000016     if strwidth(line) <= a:width
    4              0.000010       let len += 1
                                else
                                  let currlen = 0
                                  for part in split(line, pattern)
                                    let wl = strwidth(part)
                                    if currlen == 0 && wl > 0
                                      let len += 1
                                    endif
                                    let delta = currlen + wl - a:width
                                    if delta >= 0
                                      let len = len + (delta > 0)
                                      let currlen = delta == 0 ? 0 : wl
                                      if wl >= a:width
                                        let currlen = wl%a:width
                                        let len += float2nr(ceil(wl/(a:width + 0.0))) - (currlen == 0)
                                      endif
                                    else
                                      let currlen = currlen + wl
                                    endif
                                  endfor
    4              0.000002     endif
    8              0.000011   endfor
    4              0.000006   return len

FUNCTION  <SNR>58_empty_border()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:1422
Called 4 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    4              0.000051   if empty(a:border) || empty(filter(copy(a:border), 'v:val != 0'))
                                return 1
    4              0.000003   endif
    4              0.000005   return 0

FUNCTION  coc#float#get_float_win_list()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/float.vim:572
Called 48 times
Total time:   0.009533
 Self time:   0.009533

count  total (s)   self (s)
   48              0.000191   let res = []
   48              0.000421   let list_all = get(a:, 1, 0)
   48              0.000137   if s:is_vim
                                if s:popup_list_api
                                  return filter(popup_list(), 'popup_getpos(v:val)["visible"]'.(list_all ? '' : '&& getwinvar(v:val, "float", 0)'))
                                endif
                                return filter(s:popup_list, 's:popup_visible(v:val)')
   48              0.000070   else
   48              0.000181     let res = []
  171              0.000865     for i in range(1, winnr('$'))
  123              0.000683       let id = win_getid(i)
  123              0.001740       let config = nvim_win_get_config(id)
  123              0.001170       if empty(config) || empty(config['relative'])
   92              0.000309         continue
   31              0.000034       endif
                                  " ignore border & button window & others
   31              0.000166       if list_all == 0 && !getwinvar(id, 'float', 0)
    2              0.000002         continue
   29              0.000021       endif
   29              0.000164       call add(res, id)
   77              0.000237     endfor
   48              0.000170     return res
                              endif
                              return []

FUNCTION  <lambda>1()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/client.vim:77
Called 8 times
Total time:   0.001474
 Self time:   0.000216

count  total (s)   self (s)
                            return s:on_stderr(self.name, msgs)

FUNCTION  <SNR>2_LoadIndent()
    Defined: /usr/local/Cellar/neovim/HEAD-92760a7/share/nvim/runtime/indent.vim:13
Called 4 times
Total time:   0.003610
 Self time:   0.003159

count  total (s)   self (s)
    4              0.000021     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    4              0.000003     endif
    4              0.000022     let s = expand("<amatch>")
    4              0.000017     if s != ""
    4              0.000010       if exists("b:did_indent")
                            	unlet b:did_indent
    4              0.000003       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    8              0.000035       for name in split(s, '\.')
    4   0.001839   0.001388         exe 'runtime! indent/' . name . '.vim'
    4              0.001594         exe 'runtime! indent/' . name . '.lua'
    8              0.000013       endfor
    4              0.000003     endif

FUNCTION  coc#util#get_editoroption()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/util.vim:386
Called 5 times
Total time:   0.004170
 Self time:   0.000579

count  total (s)   self (s)
    5              0.000123   let info = get(getwininfo(a:winid), 0, v:null)
    5   0.000256   0.000071   if empty(info) || coc#window#is_float(a:winid)
                                return v:null
    5              0.000005   endif
    5              0.000021   let bufnr = info['bufnr']
    5              0.000032   let buftype = getbufvar(bufnr, '&buftype')
                              " avoid window for other purpose.
    5              0.000017   if buftype !=# '' && buftype !=# 'acwrite'
                                return v:null
    5              0.000003   endif
    5              0.000022   let tabSize = getbufvar(bufnr, '&shiftwidth')
    5              0.000010   if tabSize == 0
                                let tabSize = getbufvar(bufnr, '&tabstop')
    5              0.000003   endif
    5   0.003623   0.000217   return { 'bufnr': bufnr, 'winid': a:winid, 'tabpageid': coc#util#tabnr_id(info['tabnr']), 'winnr': winnr(), 'visibleRanges': s:visible_ranges(a:winid), 'tabSize': tabSize, 'insertSpaces': getbufvar(bufnr, '&expandtab') ? v:true : v:false }

FUNCTION  coc#pum#visible()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/pum.vim:28
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000010   if s:pum_winid == -1
    2              0.000004     return 0
                              endif
                              " getwinvar check current tab only.
                              return getwinvar(s:pum_winid, 'float', 0) == 1

FUNCTION  <SNR>11_Highlight_Matching_Pair()
    Defined: /usr/local/Cellar/neovim/HEAD-92760a7/share/nvim/runtime/plugin/matchparen.vim:39
Called 92 times
Total time:   0.016397
 Self time:   0.014285

count  total (s)   self (s)
                              " Remove any previous match.
   92   0.002611   0.001062   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   92              0.000716   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   92              0.000059   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   92              0.000431   let c_lnum = line('.')
   92              0.000316   let c_col = col('.')
   92              0.000153   let before = 0
                            
   92              0.000395   let text = getline(c_lnum)
   92              0.002079   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   92              0.000278   if empty(matches)
                                let [c_before, c] = ['', '']
   92              0.000087   else
   92              0.000583     let [c_before, c] = matches[1:2]
   92              0.000081   endif
   92              0.001606   let plist = split(&matchpairs, '.\zs[:,]')
   92              0.000401   let i = index(plist, c)
   92              0.000153   if i < 0
                                " not found, in Insert mode try character before the cursor
   86              0.000494     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
   86              0.000063     endif
   86              0.000108     if i < 0
                                  " not found, nothing to do
   86              0.000128       return
                                endif
    6              0.000003   endif
                            
                              " Figure out the arguments for searchpairpos().
    6              0.000010   if i % 2 == 0
    3              0.000008     let s_flags = 'nW'
    3              0.000013     let c2 = plist[i + 1]
    3              0.000001   else
    3              0.000004     let s_flags = 'nbW'
    3              0.000004     let c2 = c
    3              0.000006     let c = plist[i - 1]
    6              0.000004   endif
    6              0.000010   if c == '['
                                let c = '\['
                                let c2 = '\]'
    6              0.000003   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    6              0.000008   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
    6              0.000003   endif
                            
    6              0.000040   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
    6              0.000004   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
    6              0.000033     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
    6              0.000006     try
    6   0.000828   0.000617       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
    6              0.000007     endtry
    6              0.000004   endif
                            
                              " Limit the search to lines visible in the window.
    6              0.000024   let stoplinebottom = line('w$')
    6              0.000020   let stoplinetop = line('w0')
    6              0.000010   if i % 2 == 0
    3              0.000011     let stopline = stoplinebottom
    3              0.000002   else
    3              0.000006     let stopline = stoplinetop
    6              0.000004   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    6              0.000024   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    6              0.000004   else
    6              0.000038     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    6              0.000004   endif
    6              0.000005   try
    6   0.001695   0.001342     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    6              0.000006   endtry
                            
    6              0.000010   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
    6              0.000004   endif
                            
                              " If a match is found setup match highlighting.
    6              0.000026   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    6              0.000022     if exists('*matchaddpos')
    6              0.000062       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
    6              0.000004     endif
    6              0.000014     let w:paren_hl_on = 1
    6              0.000004   endif

FUNCTION  coc#string#byte_index()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/string.vim:35
Called 4 times
Total time:   0.001115
 Self time:   0.001115

count  total (s)   self (s)
    4              0.000011   if a:character <= 0
                                return 0
    4              0.000003   endif
                              " code unit index
    4              0.000008   let i = 0
    4              0.000007   let len = 0
   68              0.000346   for char in split(a:line, '\zs')
   68              0.000214     let i += char2nr(char) > 65535 ? 2 : 1
   68              0.000176     let len += strlen(char)
   68              0.000105     if i >= a:character
    4              0.000004       break
   64              0.000037     endif
   68              0.000102   endfor
    4              0.000008   return len

FUNCTION  <SNR>70_abort_if_stuck()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-smoothie/autoload/smoothie.vim:201
Called 31 times
Total time:   0.002933
 Self time:   0.001246

count  total (s)   self (s)
   31   0.002213   0.000525   let l:current_position = s:filter_dict(winsaveview(), s:animated_view_elements)
   93              0.000131   for key in s:animated_view_elements
   62              0.000184     if l:current_position[key] != a:desired_new_position[key]
                                  call s:finish_moving()
   62              0.000033     endif
   93              0.000052   endfor

FUNCTION  coc#window#get_var()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/window.vim:58
Called 16 times
Total time:   0.000517
 Self time:   0.000517

count  total (s)   self (s)
   16              0.000026   if !s:is_vim
   16              0.000016     try
   16              0.000074       if a:name =~# '^&'
                                    return nvim_win_get_option(a:winid, a:name[1:])
   16              0.000013       else
   16              0.000161         return nvim_win_get_var(a:winid, a:name)
                                  endif
    4              0.000040     catch /E5555/
    4              0.000029       return get(a:, 1, v:null)
   16              0.000019     endtry
                              else
                                try
                                  return coc#api#exec('win_get_var', [a:winid, a:name, get(a:, 1, v:null)])
                                catch /Invalid window id/
                                  return get(a:, 1, v:null)
                                endtry
                              endif

FUNCTION  <SNR>70_compute_velocity_element()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-smoothie/autoload/smoothie.vim:115
Called 62 times
Total time:   0.000986
 Self time:   0.000986

count  total (s)   self (s)
   62              0.000546   let l:absolute_speed = g:smoothie_speed_constant_factor + g:smoothie_speed_linear_factor * pow(abs(a:target_distance_element), g:smoothie_speed_exponentiation_factor)
   62              0.000153   if a:target_distance_element < 0
                                return -l:absolute_speed
   62              0.000045   else
   62              0.000073     return l:absolute_speed
                              endif

FUNCTION  coc#highlight#highlight_lines()
    Defined: ~/.local/share/nvim/site/pack/packer/start/coc.nvim/autoload/coc/highlight.vim:383
Called 2 times
Total time:   0.014478
 Self time:   0.000424

count  total (s)   self (s)
    2              0.000010   let region_id = 1
    2              0.000054   let defined = []
    2              0.000004   let cmds = []
    4              0.000009   for config in a:blocks
    2              0.000009     let start = config['startLine'] + 1
    2              0.000020     let end = config['endLine'] == -1 ? len(getbufline(winbufnr(a:winid), 1, '$')) + 1 : config['endLine'] + 1
    2              0.000009     let filetype = get(config, 'filetype', '')
    2              0.000007     let hlGroup = get(config, 'hlGroup', '')
    2              0.000006     if !empty(hlGroup)
                                  call add(cmds, 'syntax region '.hlGroup.' start=/\%'.start.'l/ end=/\%'.end.'l/')
    2              0.000002     else
    2              0.000026       let filetype = matchstr(filetype, '\v^\w+')
    2              0.000022       if empty(filetype) || filetype == 'txt' || index(get(g:, 'coc_markdown_disabled_languages', []), filetype) != -1
                                    continue
    2              0.000002       endif
    2              0.000007       if index(defined, filetype) == -1
    2              0.000020         call add(cmds, 'syntax include @'.toupper(filetype).' syntax/'.filetype.'.vim')
    2              0.000006         call add(cmds, 'unlet! b:current_syntax')
    2              0.000005         call add(defined, filetype)
    2              0.000002       endif
    2              0.000026       call add(cmds, 'syntax region CodeBlock'.region_id.' start=/\%'.start.'l/ end=/\%'.end.'l/ contains=@'.toupper(filetype).' keepend')
    2              0.000005       let region_id = region_id + 1
    2              0.000001     endif
    4              0.000009   endfor
    2              0.000005   if !empty(cmds)
    2   0.014079   0.000025     call coc#compat#execute(a:winid, cmds, 'silent!')
    2              0.000001   endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  215   0.036485   0.006631  coc#rpc#notify()
    2   0.034776   0.009071  coc#dialog#create_cursor_float()
  170   0.028650   0.003350  <SNR>26_Autocmd()
  215   0.026890   0.024701  <SNR>29_notify()
    4   0.024221   0.008745  <SNR>7_SynSet()
   31   0.023831   0.001852  <SNR>70_animation_tick()
   31   0.021936   0.004811  <SNR>70_perform_animation_step()
    2   0.021452   0.000803  coc#float#create_float_win()
    4   0.020324   0.018335  <SNR>1_LoadFTPlugin()
   43   0.020097   0.014844  coc#util#editor_infos()
   92   0.016397   0.014285  <SNR>11_Highlight_Matching_Pair()
   45   0.016184   0.001226  CocActionAsync()
    2   0.015960   0.000141  <SNR>58_add_highlights()
    2   0.015819   0.000409  coc#highlight#add_highlights()
   45   0.014957   0.003771  <SNR>26_AsyncRequest()
    4   0.014732   0.001967  coc#compat#execute()
    2   0.014478   0.000424  coc#highlight#highlight_lines()
   43   0.012623   0.003791  coc#float#check_related()
    2   0.012388             coc#util#semantic_hlgroups()
   48   0.009533             coc#float#get_float_win_list()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  215   0.026890   0.024701  <SNR>29_notify()
    4   0.020324   0.018335  <SNR>1_LoadFTPlugin()
   43   0.020097   0.014844  coc#util#editor_infos()
   92   0.016397   0.014285  <SNR>11_Highlight_Matching_Pair()
    2              0.012388  coc#util#semantic_hlgroups()
   48              0.009533  coc#float#get_float_win_list()
    2   0.034776   0.009071  coc#dialog#create_cursor_float()
    4   0.024221   0.008745  <SNR>7_SynSet()
  215   0.036485   0.006631  coc#rpc#notify()
   31   0.005763   0.005199  <SNR>70_winrestview_optimized()
  113              0.004812  coc#window#is_float()
   31   0.021936   0.004811  <SNR>70_perform_animation_step()
   45              0.004550  coc#string#character_index()
  124              0.004375  <SNR>70_filter_dict()
   28              0.004054  coc#highlight#clear_match_group()
   43   0.012623   0.003791  coc#float#check_related()
   45   0.014957   0.003771  <SNR>26_AsyncRequest()
  170   0.028650   0.003350  <SNR>26_Autocmd()
    5              0.003346  <SNR>28_visible_ranges()
    4   0.003610   0.003159  <SNR>2_LoadIndent()

